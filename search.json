[{"title":"炼气技术栈shell 初识","path":"/2025/06/03/炼气技术栈shell：初识/","content":"简介简单来说，Shell脚本就是一系列命令的集合，这些命令被保存在一个文本文件中，然后通过Shell（一个解释执行命令的程序）来运行这个文件。就像你有一串指令，比如“先开门，再开灯，最后坐下”，Shell脚本就是把这些指令写下来，然后让电脑自动帮你完成这一系列动作。 应用领域 自动化 重复的任务可以自动化完成，节省时间。 批量处理 对大量文件或数据进行统一操作。 系统管理 管理员常用Shell脚本进行系统配置、监控和维护。 学习编程 Shell脚本是学习编程的入门语言之一，简单易懂。 基本结构一个基本的Shell脚本通常包含以下几个部分 Shebang（#!） 告诉系统这个脚本应该用哪个解释器来执行，比如#!/bin/bash表示使用Bash Shell。注释 以#开头，用于说明脚本的功能、作者等信息，不会被执行。命令 实际要执行的命令。 第一个脚本 创建文件 用文本编辑器（如nano、vim、gedit等）创建一个新文件，比如hello.sh。 123#!/bin/bash# 这是我的第一个Shell脚本echo &quot;Hello, World!&quot; 保存并退出 根据编辑器的不同，保存并退出编辑器。 赋予执行权限 在终端中，使用chmod +x hello.sh命令给脚本添加执行权限。 运行脚本 在终端中，输入./hello.sh来运行你的脚本，又或者用bash执行脚本 bash hello.sh。你应该会看到输出Hello, World!。 变量变量是存储数据的容器。在Shell脚本中，变量不需要声明类型，直接赋值即可使用。 赋值符号 = 两边不能有空格，否则会报错。 123#!/bin/bashname=&quot;Alice&quot;echo &quot;Hello, $name!&quot; 运行这个脚本，你会看到输出Hello, Alice!。 条件判断Shell脚本支持条件判断，比如if语句。 1234567#!/bin/bashage=20 # 注意=左右不能有空格if [ $age -ge 18 ]; then echo &quot;You are an adult.&quot;else echo &quot;You are a minor.&quot;fi 这个脚本会检查变量age的值，如果大于等于18，就输出“You are an adult.”，否则输出“You are a minor.”。 循环Shell脚本也支持循环，比如for循环。 1234#!/bin/bashfor i in &#123;1..5&#125;; do echo &quot;Number: $i&quot;done 这个脚本会输出数字1到5。 学习建议 多实践 理论结合实践，多写脚本，多尝试不同的命令和结构。 阅读文档 利用man命令查看命令的帮助文档，比如man echo。 参考示例 网上有很多Shell脚本的示例，可以参考学习。 总结Shell脚本是一个强大而灵活的工具，掌握它能让你的Linux&#x2F;Unix系统操作更加高效。希望这篇文章能帮让你对Shell脚本有个基本了解。","tags":["shell"]},{"title":"强烈推荐git入门图文教程","path":"/2025/05/30/强烈推荐git入门图文教程/","content":"转载自: https://www.cnblogs.com/anding/p/16987769.html 01、认识一下GitGit是当前最先进、最主流的分布式版本控制系统。代码的任何修改都会被记录并管理起来，意味着可以恢复到到以前任意时刻的状态。支持跨区域多人协作编辑，是团队项目开发的必备基础，所以Git也就成了程序员的必备技能。 🟢主要特点： 开源免费。 强大的文档（代码）的历史版本管理，直接记录完整快照（完整内容，而非差异），支持回滚、对比。 分布式多人协作，几乎所有操作都是本地执行的，支持代码合并、代码同步。 简单易用的分支管理，支持高效的创建分支、合并分支。 Git是Linux之父（Linus Benedic Torvalds）“被迫”开发的，为了解决Linux混乱的代码管理而开发的。 02、Git是干什么的？先了解下Git的基本概念，及基本框架、工作流程。 2.1、Git概念汇总🔥 概念名称 描述 工作区（Workspace） 就是在电脑里能看到的代码库目录，是我们搬砖的地方，新增、修改的文件会提交到暂存区 暂存区（stage 或 index） 用于临时存放文件的修改，实际上上它只是一个文件（.git/index），保存待提交的文件列表信息。 版本库&#x2F;仓库（Repository） Git的管理仓库，管理版本的数据库，记录文件&#x2F;目录状态的地方，所有内容的修改记录（版本）都在这里。 服务端&#x2F;远程仓库（origin 或 remote） 服务端的版本库，专用的Git服务器，为多人共享提供服务，承担中心服务器的角色。本地版本库通过push指令把代码推送到服务端版本库。 本地仓库 用户机器上直接使用的的的版本库 分支（Branch） 分支是从主线分离出去的“副本”，可以独立操作而互不干扰，仓库初始化就有一个默认主分支master。 头（HEAD） HEAD类似一个“指针”，指向当前活动 分支 的 最新版本。 提交（Commit） 把暂存区的所有变更的内容提交到当前仓库的活动分支。 推送（Push） 将本地仓库的版本推送到服务端（远程）仓库，与他人共享。 拉取（Pull） 从服务端（远程）仓库获取更新到本地仓库，获取他人共享的更新。 获取（Fetch） 从服务端（远程）仓库更新，作用同拉取（Pull），区别是不会自动合并。 冲突（Conflict） 多人对同一文件的工作副本进行更改，并将这些更改合并到仓库时就会面临冲突，需要人工合并处理。 合并（Merge） 对有冲突的文件进行合并操作，Git会自动合并变更内容，无法自动处理的冲突内容会提示人工处理。 标签（Tags） 标签指的是某个分支某个特定时间点的状态，可以理解为提交记录的别名，常用来标记版本。 master（或main） 仓库的“master”分支，默认的主分支，初始化仓库就有了。Github上创建的仓库默认名字为“main” origin&#x2F;master 表示远程仓库（origin）的“master”分支 origin&#x2F;HEAD 表示远程仓库（origin）的最新提交的位置，一般情况等于“origin/master” 2.2、工作区&#x2F;暂存区&#x2F;仓库 工作区、暂存区、版本库是Git最基本的概念，关系如下图： 🔸工作区（Workspace）就是在电脑里能看到的代码库目录，是我们搬砖的地方，新增、修改的文件会提交到暂存区。 在这里新增文件、修改文件内容，或删除文件。 🔸暂存区（stage或index） 用于临时存放文件的修改，实际上上它只是一个文件（.git&#x2F;index），保存待提交的文件列表信息。 用git add 命令将工作区的修改保存到暂存区。 🔸版本库&#x2F;仓库（Repository &#x2F;rɪˈpɑːzətɔːri&#x2F; 仓库）Git的管理仓库，管理版本的数据库，记录文件&#x2F;目录状态的地方，所有内容的修改记录（版本）都在这里。就是工作区目录下的隐藏文件夹.git，包含暂存区、分支、历史记录等信息。 用git commit 命令将暂存区的内容正式提交到版本库。 master 为仓库的默认分支master，HEAD是一个“指针”指向当前分支的最新提交，默认指向最新的master。 如上图，为对应本地仓库目录的结构关系。 KWebNote为项目目录，也就是Git工作区。 项目根目录下隐藏的.git目录就是Git仓库目录了，存放了所有Git管理的信息。 .git/config为该仓库的配置文件，可通过指令修改或直接修改。 index文件就是存放的暂存区内容。 2.3、Git基本流程（图）Git的工作流程核心就下面几个步骤，掌握了就可以开始写Bug了。 0、准备仓库：创建或从服务端克隆一个仓库。 1、搬砖：在工作目录中添加、修改代码。 2、暂存（git add）：将需要进行版本管理的文件放入暂存区域。 3、提交（git commit）：将暂存区域的文件提交到Git仓库。 4、推送（git push）：将本地仓库推送到远程仓库，同步版本库。 5、获取更新（fetch&#x2F;pull）：从服务端更新到本地，获取他人推送的更新，与他人协作、共享。 git commit -a指令省略了add到暂存区的步骤，直接提交工作区的修改内容到版本库，不包括新增的文件。 git fetch、git pull 都是从远程服务端获取最新记录，区别是git pull多了一个步骤，就是自动合并更新工作区。 git checkout .、git checkout [file] 会清除工作区中未添加到暂存区的修改，用暂存区内容替换工作区。 git checkout HEAD .、 git checkout HEAD [file] 会清除工作区、暂存区的修改，用HEAD指向的当前分支最新版本替换暂存区、工作区。 git diff 用来对比不同部分之间的区别，如暂存区、工作区，最新版本与未提交内容，不同版本之间等。 git reset是专门用来撤销修改、回退版本的指令，替代上面checkout的撤销功能。 2.4、Git状态（图）Git在执行提交的时候，不是直接将工作区的修改保存到仓库，而是将暂存区域的修改保存到仓库。要提交文件，首先需要把文件加入到暂存区域中。因此，Git管理的文件有三（+2）种状态： 未跟踪（untracked）：新添加的文件，或被移除跟踪的文件，未建立跟踪，通过git add添加暂存并建立跟踪。 未修改：从仓库签出的文件默认状态，修改后就是“已修改”状态了。 已修改（modified）：文件被修改后的状态。 已暂存（staged）：修改、新增的文件添加到暂存区后的状态。 已提交(committed)：从暂存区提交到版本库。 03、起步：Git安装配置Git官网：https://www.git-scm.com/ 下载安装包进行安装。Git的使用有两种方式： 命令行：Git的命令通过系统命令行工具，或Git提供的命令行工具运行（C:\\Program Files\\Git\\git-bash.exe） GUI工具：Windows(GUI)、Mac(GUI)工具，需单独安装，使用更简单、更易上手。 指令git --version查看安装版本号 123$ git --versiongit version 2.33.0.windows.2 📢 本文是在Windows 平台上完成的，不过这个对学习Git没什么影响。 3.1、Git的配置文件Git有三个主要的配置文件：三个配置文件的优先级是① &lt; ② &lt; ③ ① 系统全局配置(–system)：包含了适用于系统所有用户和所有仓库（项目）的配置信息，存放在Git安装目录下C:\\Program Files\\Git\\etc\\gitconfig。 ② 用户全局配置(–global)：当前系统用户的全局配置，存放用户目录：C:\\Users\\[系统用户名]\\.gitconfig。 ③ 仓库&#x2F;项目配置(–local)：仓库（项目）的特定配置，存放在项目目录下.git/config 123456789101112#查看git配置git config --listgit config -l #查看系统配置git config --system --list #查看当前用户（global）全局配置git config --list --global #查看当前仓库配置信息git config --local --list 仓库的配置是上面多个配置的集合： 12345678910111213141516$ git config --list$ git config -ldiff.astextplain.textconv=astextplainhttp.sslbackend=opensslhttp.sslcainfo=C:/Program Files/Git/mingw64/ssl/certs/ca-bundle.crtcore.autocrlf=truecore.fscache=truecore.symlinks=falsepull.rebase=falsecredential.helper=manager-corecredential.https://dev.azure.com.usehttppath=trueinit.defaultbranch=masteruser.name=Kandinguser.email=123anding@163.com 3.2、配置-初始化用户当安装Git后首先要做的事情是配置你的用户信息—— 告诉Git你是谁？配置 用户名、邮箱地址，每次提交文件时都会带上这个用户信息，查看历史记录时就知道是谁干的了。 配置用户信息： 123456789$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot;# 配置完后，看看用户配置文件：$ cat &#x27;C:\\Users\\Kwongad\\.gitconfig&#x27;[user] name = Kanding email = 123anding@163.com user.name为用户名，user.email为邮箱。 --global：config的参数，表示用户全局配置。如果要给特定仓库配置用户信息，则用参数--local配置即可，或直接在仓库配置文件.git/config里修改。 3.3、配置-忽略.gitignore工作目录中的文件并不是全都需要纳入版本管理，如日志、临时文件、私有配置文件等不需要也不能纳入版本管理，那该怎么办呢？ 在工作区根目录下创建“.gitignore”文件，文件中配置不需要进行版本管理的文件、文件夹。“.gitignore”文件本身是被纳入版本管理的，可以共享。有如下规则： #符号开头为注释。 可以使用Linux通配符。 星号（*）代表任意多个字符， 问号（？）代表一个字符， 方括号（[abc]）代表可选字符范围， 大括号（{string1,string2,…}）代表可选的字符串等。 感叹号（!）开头：表示例外规则，将不被忽略。 路径分隔符（&#x2F;f）开头：，表示要忽略根目录下的文件f。 路径分隔符（f&#x2F;）结尾：，表示要忽略文件夹f下面的所有文件。 1234567891011121314#为注释*.txt #忽略所有“.txt”结尾的文件#lib.txt除外!lib.txt #仅忽略项目根目录下的temp文件,不包括其它目录下的temp，如不包括“src/temp”/temp #忽略build/目录下的所有文件build/ #会忽略 doc/notes.txt 但不包括 doc/server/arch.txtdoc/*.txt 📢 各种语言项目的常用.gitignore文件配置：https://github.com/github/gitignore 04、Git的GUI工具们如果不想用命令行工具，完全可以安装一个Git的GUI工具，用的更简单、更舒服。不用记那么多命令了，极易上手，不过Git基础还是需要学习了解一下的。 ❓对于Git，建议用命令行，这样你才能真的理解Git的思想？✔️其实都只是工具而已，适合自己的就是最好的，没必要纠结，多写点Bug更重要！ TortoiseGit：小乌龟，SVN时代就很流行的代码管理GUI利器。 🚫只有Windows版本，支持中文，需要单独下载安装中文语言包。 ✔️开源，免费，与文件管理器的良好集成。 ✔️内置冲突对比解决工具。 Sourcetree：SourceTree是老牌的Git GUI管理工具了，也号称是最好用的Git GUI工具。 ✔️适用于 Windows 和 Mac 系统，内置中文版，自动识别语言。 ✔️免费、功能强大，使用简单。 ✔️功能丰富，基本操作和高级操作都设计得非常流畅，适合初学者上手，支持Git Flow。 🚫无冲突对比工具，支持配置第三方组件。 GitHub Desktop：Github官方出品的Git管理工具。 GitKraken：GitKraken是一个跨平台GUI Git客户端，有免费版，专业版和企业版，这些版本启用了不同的功能。 4.1、SourceTreeSourceTree的官网 下载安装包，支持Window、Mac系统，按照提示完成安装。 SourceTree支持管理多个仓库，通过+按钮，可选择多种方式添加仓库。 然后就是可视化的仓库管理了，不用记住繁琐的指令（参数）了，可视化操作。 4.2、TortoiseGit TortoiseGit 官网下载安装包，及中文语言包，按照提示完成安装。小乌龟的Git是集成到操作系统里的，直接右键文件夹就可以进行Git操作了。 先进入设置：右键文件夹菜单 –&gt; TortoiseGit –&gt; Settings 进入设置，设置中文语言。 小乌龟的各种Git操作都在右键菜单了，深度集成到了操作系统的资源管理器中了，文件图标也是有Git状态的，比较容易分辨。 4.3、VSCode中的GitVSCode自带的Git工具基本已经可以满足日常使用了，既有可视化功能，也能敲命令，习惯了不就不用安装其他GUI工具了。不过还是可以再安装一些VSCode插件，来增强Git功能。 GitLens ：在团队项目开发中非常实用，必备！！！用于快速查看代码提交历史记录，在代码上会显示最近的修改信息，包括提交者，只就这一点就值得推荐了。 Git History：可以轻松快速浏览Git文件操作历史记录的工具，可视化展示，操作简单。 05、Git使用入门5.1、创建仓库创建本地仓库的方法有两种： 一种是创建全新的仓库：git init，会在当前目录初始化创建仓库。 另一种是克隆远程仓库：git clone [url] 123456# 准备一个文件夹“KwebNote”作为仓库目录，命令行进入该文件夹$ cd /d/Project_Files/github.kwong/KwebNote # 开始初始化项目，也可指定目录：# git init [文件目录]$ git initInitialized empty Git repository in D:/Project_Files/github.Kwong/KwebNote/.git/ 📢注意：Git指令的执行，都需在仓库目录下。 创建完多出了一个被隐藏的.git目录，这就是本地仓库Git的工作场所。 克隆远程仓库，如在github上创建的仓库“https://github.com/kwonganding/KWebNote.git” 1$ git clone https://github.com/kwonganding/KWebNote.git 会在当前目录下创建“KWebNote”项目目录。 5.2、暂存区add可以简单理解为，git add命令就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到仓库。 指令 描述 git add [file1] [file2] 添加文件到暂存区，包括修改的文件、新增的文件 git add [dir] 同上，添加目录到暂存区，包括子目录 git add . 同上，添加所有修改、新增文件（未跟踪）到暂存区 git rm [file] 删除工作区文件，并且将这次删除放入暂存区 12345678# 添加指定文件到暂存区，包括被修改的文件$ git add [file1] [file2] ... # 添加当前目录的所有文件到暂存区$ git add . # 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ... # 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 修改文件“R.md”，未暂存： 执行git add .暂存： 5.3、提交commit-记录git commit提交是以时间顺序排列被保存到数据库中的，就如游戏关卡一样，每一次提交（commit）就会产生一条记录：id + 描述 + 快照内容。 🔸commit id：根据修改的文件内容采用摘要算法（SHA1）计算出不重复的40位字符，这么长是因为Git是分布式的，要保证唯一性、完整性，一般本地指令中可以只用前几位（6）。即使多年以后，依然可通过id找到曾经的任何内容和变动，再也不用担心丢失了。 🔸描述：针对本次提交的描述说明，建议准确填写，就跟代码中的注释一样，很重要。 🔸快照：就是完整的版本文件，以对象树的结构存在仓库下\\.git\\objects目录里，这也是Git效率高的秘诀之一。 SHA1 是一种哈希算法，可以用来生成数据摘要 Git不适合大的非文本文件，会影响计算摘要、快照的性能。 多个提交就形成了一条时间线，每次提交完，会移动当前分支master、HEAD的“指针”位置。 Sourcetree上的历史记录： 📢一般情况，每完成一个小功能、一个Bug就可以提交一次，这样会形成比较清晰的历史记录。 🔥指令： 指令 描述 git commit -m ‘说明’ 提交变更，参数-m设置提交的描述信息，应该正确提交，不带该参数会进入说明编辑模式 git commit -a 参数-a，表示直接从工作区提交到版本库，略过了git add步骤，不包括新增的文件 git commit [file] 提交暂存区的指定文件到仓库区 git commit –amend -m 使用一次新的commit，替代上一次提交，会修改commit的hash值（id） git log -n20 查看日志(最近20条)，不带参数-n则显示所有日志 git log -n20 –oneline 参数“--oneline”可以让日志输出更简洁（一行） git log -n20 –graph 参数“--graph”可视化显示分支关系 git log –follow [file] 显示某个文件的版本历史 git blame [file] 以列表形式显示指定文件的修改记录 git reflog 查看所有可用的历史版本记录（实际是HEAD变更记录），包含被回退的记录（重要） git status 查看本地仓库状态，比较常用的指令，加参数-s简洁模式 通过git log指令可以查看提交记录日志，可以很方便的查看每次提交修改了哪些文件，改了哪些内容，从而进行恢复等操作。 123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交所有修改到仓库$ git commit -a -m&#x27;修改README的版权信息&#x27; # 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message] # 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message] # 查看最近几条提交记录$ git log -n2# 用参数“--oneline”可以让日志输出更简洁（一行）$ git log -n2 --oneline 5.4、Git的“指针”引用们Git中最重要的就是提交记录了，其他如标签、分支、HEAD 都对提交记录的“指针”引用，指向这些提交记录，理解这一点很重要。 提交记录之间也存在“指针”引用，每个提交会指向其上一个提交。 标签 就是对某一个提交记录的的 固定 “指针”引用，取一个别名更容易记忆一些关键节点。存储在工作区根目录下.git\\refs\\tags。 分支 也是指向某一个提交记录的“指针”引用，“指针”位置可变，如提交、更新、回滚。存储在工作区根目录下.git\\refs\\heads。 HEAD：指向当前活动分支（最新提交）的一个“指针”引用，存在在“.git/HEAD”文件中，存储的内容为“ref: refs/heads/master”。 上图中： HEAD始终指向当前活动分支，多个分支只能有一个处于活动状态。 标签t1在某一个提交上创建后，就不会变了。而分支、HEAD的位置会改变。 打开这些文件内容看看，就更容易理解这些“指针”的真面目了。 12345678910111213141516171819# tag$ git tag -a &#x27;v1&#x27; -m &#x27;v1版本&#x27;$ cat .git/refs/tags/v1a2e2c9caea35e176cf61e96ad9d5a929cfb82461 # main分支指向最新的提交$ cat .git/refs/heads/main8f4244550c2b6c23a543b741c362b13768442090 # HEAD指向当前活动分支$ cat .git/HEADref: refs/heads/main # 切换到dev分支，HEAD指向了dev$ git switch devSwitched to branch &#x27;dev&#x27;$ cat .git/HEADref: refs/heads/dev 这里的主分支名字为“main”，是因为该仓库是从Github上克隆的，Github上创建的仓库默认主分支名字就是“main”，本地创建的仓库默认主分支名字为“master”。 📢“指针”引用：之所以用引号的“指针”，是为了便于统一和理解。和指针原理类似，都是一个指向，只是实际上可能更复杂一点，且不同的“指针”引用会有区别。 5.5、提交的唯一标识id，HEAD~n是什么意思？每一个提交都有一个唯一标识，主要就是提交的hash值commit id，在很多指令中会用到，如版本回退、拣选提交等，需要指定一个提交。那标识唯一提交有两种方式： 首先就是commit id，一个40位编码，指令中使用的时候可以只输入前几位（6位）即可。 还有一种就是HEAD~n，是基于当前HEAD位置的一个相对坐标。 HEAD 表示当前分支的最新版本，是比较常用的参数。 HEAD^上一个版本，HEAD^^ 上上一个版本。 HEAD~ 或HEAD~1 表示上一个版本，以此类推，HEAD^10 为最近第10个版本。 HEAD@&#123;2&#125;在git reflog日志中标记的提交记录索引。 通过git log、git reflog可以查看历史日志，可以看每次提交的唯一编号（hash）。区别是git reflog可以查看所有操作的记录（实际是HEAD变更记录），包括被撤销回退的提交记录。 123456789101112$ git reflog -n105acc914 (HEAD -&gt; main) HEAD@&#123;0&#125;: reset: moving to HEAD~738748b (dev) HEAD@&#123;1&#125;: reset: moving to HEAD~9312c3e HEAD@&#123;2&#125;: reset: moving to HEAD~db03fcb HEAD@&#123;3&#125;: reset: moving to HEAD~1b81fb3 HEAD@&#123;4&#125;: reset: moving to HEAD~41ea423 HEAD@&#123;5&#125;: reset: moving to HEAD~d3e15f9 HEAD@&#123;6&#125;: reset: moving to d3e15f91b81fb3 HEAD@&#123;7&#125;: reset: moving to HEAD~141ea423 HEAD@&#123;8&#125;: reset: moving to HEAD~d3e15f9 HEAD@&#123;9&#125;: reset: moving to HEAD~ 5.6、比较diffgit diff用来比较不同文件版本之间的差异。 指令 描述 git diff 查看暂存区和工作区的差异 git diff [file] 同上，指定文件 git diff –cached 查看已暂存的改动，就是暂存区与新版本HEAD进行比较 git diff –staged 同上 git diff –cached [file] 同上，指定文件 git diff HEAD 查看已暂存的+未暂存的所有改动，就是与最新版本HEAD进行比较 git diff HEAD~ 同上，与上一个版本比较。HEAD~表示上一个版本，HEAD~10为最近第10个版本 git diff [id] [id] 查看两次提交之间的差异 git diff [branch] 查看工作区和分支直接的差异 ☘️画个图更清晰些： 123456# 查看文件的修改$ git diff README.md # 查看两次提交的差异$ git diff 8f4244 1da22 # 显示今天你写了多少行代码：工作区+暂存区$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot; 06、远程仓库Git作为分布式的版本管理系统，每个终端都有自己的Git仓库。但团队协作还需一个中间仓库，作为中心，同步各个仓库。于是服务端（远程）仓库就来承担这个职责，服务端不仅有仓库，还配套相关管理功能。 可以用公共的Git服务器，也可以自己搭建一套Git服务器。 公共Git服务器，如Github、Gitlab、码云Gitee、腾讯Coding等。 搭建私有Git服务器，如开源的Gitlab、Gitea、等。 6.1、远程用户登录Git服务器一般提供两种登录验证方式： HTTS：基于HTTPS连接，使用用户名、密码身份验证。 每次都要输入用户名、密码，当然可以记住。 地址形式：https://github.com/kwonganding/KWebNote.git SSL：采用SSL通信协议，基于公私钥进行身份验证，所以需要额外配置公私秘钥。 不用每次输入用户名、密码，比较推荐的方法。 地址形式：git@github.com:kwonganding/KWebNote.git 1234567#查看当前远程仓库使用的那种协议连接：$ git remote -v origin git@github.com:kwonganding/KWebNote.git (fetch)origin https://github.com/kwonganding/KWebNote.git (push) # 更改为https地址，即可切换连接模式。还需要禁用掉SSL, 才能正常使用https管理gitgit config --global http.sslVerify false 🔑远程用户登录：HTTS基于HTTPS的地址连接远程仓库，Github的共有仓库克隆、拉取（pull）是不需要验证的。 12345678$ git clone &#x27;https://github.com/kwonganding/KWebNote.git&#x27;Cloning into &#x27;KWebNote&#x27;... # 仓库配置文件“.git/config”[remote &quot;origin&quot;] url = https://github.com/kwonganding/KWebNote.git fetch = +refs/heads/*:refs/remotes/origin/* pushurl = https://github.com/kwonganding/KWebNote.git 推送（push）代码的时候就会提示输入用户名、密码了，否则无法提交。记住用户密码的方式有两种： 🔸URL地址配置：在原本URL地址上加上用户名、密码，https://后加用户名:密码@ 12345# 直接修改仓库的配置文件“.git/config”[remote &quot;origin&quot;] url = https://用户名:密码@github.com/kwonganding/KWebNote.git fetch = +refs/heads/*:refs/remotes/origin/* pushurl = https://github.com/kwonganding/KWebNote.git 🔸本地缓存：会创建一个缓存文件.git-credentials，存储输入的用户名、密码。 123456# 参数“--global”全局有效，也可以针对仓库设置“--local”# store 表示永久存储，也可以设置临时存储git config --global credential.helper store # 存储内容如下，打开文件“仓库\\.git\\.git-credentials”https://kwonganding:[加密内容付费可见]@github.com 🔑远程用户登录：SSH SSH（Secure Shell，安全外壳）是一种网络安全协议，通过加密和认证机制实现安全的访问和文件传输等业务，多用来进行远程登录、数据传输。SSH通过公钥、私钥非对称加密数据，所以SSH需要生成一个公私钥对，公钥放服务器上，私有自己留着进行认证。 ① 生成公私钥：通过Git指令ssh-keygen -t rsa生成公私钥，一路回车即可完成。生成在“C:\\Users\\用户名\\.ssh”目录下，文件id_rsa.pub的内容就是公钥。 ② 配置公钥：打开id_rsa.pub文件，复制内容。Github上，打开Setting➤ SSH and GPG keys ➤ SSH keys ➤ 按钮New SSH key，标题（Title）随意，秘钥内容粘贴进去即可。 SSH配置完后，可用ssh -T git@github.com来检测是否连接成功。 123$ ssh -T git@github.comHi kwonganding! You&#x27;ve successfully authenticated, but GitHub does not provide shell access. 6.2、远程仓库指令🔥 指令 描述 git clone [git地址] 从远程仓库克隆到本地（当前目录） git remote -v 查看所有远程仓库，不带参数-v只显示名称 git remote show [remote] 显示某个远程仓库的信息 git remote add [name] [url] 增加一个新的远程仓库，并命名 git remote rename [old] [new] 修改远程仓库名称 git pull [remote] [branch] 取回远程仓库的变化，并与本地版本合并 git pull 同上，针对当前分支 git fetch [remote] 获取远程仓库的所有变动到本地仓库，不会自动合并！需要手动合并 git push 推送当前分支到远程仓库 git push [remote] [branch] 推送本地当前分支到远程仓库的指定分支 git push [remote] –force&#x2F;-f 强行推送当前分支到远程仓库，即使有冲突，⚠️很危险！ git push [remote] –all 推送所有分支到远程仓库 git push –u 参数–u表示与远程分支建立关联，第一次执行的时候用，后面就不需要了 git remote rm [remote-name] 删除远程仓库 git pull –rebase 使用rebase的模式进行合并 6.3、推送push&#x2F;拉取pullgit push、git pull是团队协作中最常用的指令，用于同步本地、服务端的更新，与他人协作。 🔸推送（push）：推送本地仓库到远程仓库。 如果推送的更新与服务端存在冲突，则会被拒绝，push失败。一般是有其他人推送了代码，导致文件冲突，可以先pull代码，在本地进行合并，然后再push。 🔸拉取（pull）：从服务端（远程）仓库更新到本地仓库。 git pull：拉取服务端的最新提交到本地，并与本地合并，合并过程同分支的合并。 git fetch：拉取服务端的最新提交到本地，不会自动合并，也不会更新工作区。 6.4、fetch与pull有什么不同？两者都是从服务端获取更新，主要区别是fetch不会自动合并，不会影响当前工作区内容。 git pull &#x3D; git fetch + git merge 如下面图中，git fetch只获取了更新，并未影响master、HEAD的位置。 要更新master、HEAD的位置需要手动执行git merge合并。 12345678910111213# fetch只更新版本库$ git fetchremote: Enumerating objects: 5, done.remote: Counting objects: 100% (5/5), done.remote: Compressing objects: 100% (3/3), done.remote: Total 3 (delta 2), reused 0 (delta 0), pack-reused 0Unpacking objects: 100% (3/3), 663 bytes | 44.00 KiB/s, done.From github.com:kwonganding/KWebNote 2ba12ca..c64f5b5 main -&gt; origin/main # 执行合并，合并自己$ git mergeUpdating 2ba12ca..c64f5b5Fast-forward README.md | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) 07、Git利器-分支分支是从主线分离出去的“副本”，分支就像是平行宇宙，可独立发展，独立编辑、提交，也可以和其他分支合并。分支是Git的核心必杀利器之一，分支创建、切换、删除都非常快，他非常的轻量。所以，早建分支！多用分支！ 7.1、分支Branch比如有一个项目团队，准备10月份发布新版本，要新开发一堆黑科技功能，占领市场。你和小伙伴“小美”一起负责开发一个新功能A，开发周期2周，在这两周你们的代码不能影响其他人，不影响主分支。这个时候就可以为这个新功能创建一个分支，你们两在这个分支上干活，2周后代码开发完了、测试通过，就可以合并进要发版的开发分支了。安全、高效，不影响其他人工作，完美！ 在实际项目中，一般会建几个主线分支。 🔸master：作为主分支，存放稳定的代码，就是开发后测试通过的代码，不允许随便修改和合并。 🔸开发分支：用于团队日常开发用，比如团队计划10月份开发10个功能并发版，则在此分支上进行，不影响主分支的稳定。 🔸功能A分支：开发人员根据自己的需要，可以创建一些临时分支用于特定功能的开发，开发完毕后再合并到开发分支，并删除该分支。 分支就是指向某一个提交记录的“指针”引用，因此创建分支是非常快的，不管仓库多大。当我们运行git branch dev创建了一个名字为dev的分支，Git实际上是在.git\\refs\\heads下创建一个dev的引用文件（没有扩展名）。 123$ git branch dev$ cat .git/refs/heads/devca88989e7c286fb4ba56785c2cd8727ea1a07b97 7.2、分支指令🔥 指令 描述 git branch 列出所有本地分支，加参数-v显示详细列表，下同 git branch -r 列出所有远程分支 git branch -a 列出所有本地分支和远程分支，用不同颜色区分 git branch [branch-name] 新建一个分支，但依然停留在当前分支 git branch -d dev 删除dev分支，-D（大写）强制删除 git checkout -b dev 从当前分支创建并切换到dev分支 git checkout -b feature1 dev 从本地dev分支代码创建一个 feature1分支，并切换到新分支 git branch [branch] [commit] 新建一个分支，指向指定commit id git branch –track [branch] [remote-branch] 新建一个分支，与指定的远程分支建立关联 git checkout -b hotfix remote hotfix 从远端remote的hotfix分支创建本地hotfix分支 git branch –set-upstream [branch] [remote-branch] 在现有分支与指定的远程分支之间建立跟踪关联： git branch --set-upstream hotfix remote/hotfix git checkout [branch-name] 切换到指定分支，并更新工作区 git checkout . 撤销工作区的（未暂存）修改，把暂存区恢复到工作区。 git checkout HEAD . 撤销工作区、暂存区的修改，用HEAD指向的当前分支最新版本替换 git merge [branch] 合并指定分支到当前分支 git merge –no-ff dev 合并dev分支到当前分支，参数--no-ff禁用快速合并模式 git push origin –delete [branch-name] 删除远程分支 git rebase master 将当前分支变基合并到master分支 ✅switch：新的分支切换指令 切换功能和checkout一样，switch只单纯的用于切换 git switch master 切换到已有的master分支 git switch -c dev 创建并切换到新的dev分支 📢关于 checkout 指令：checkout是Git的底层指令，比较常用，也比较危险，他会重写工作区。支持的功能比较多，能撤销修改，能切换分支，这也导致了这个指令比较复杂。在Git 2.23版本以后，增加了git switch、git reset指令。 git switch：专门用来实现分支切换。 git reset：专门用来实现本地修改的撤销，更多可参考后续“reset”内容。 1234# 列出了当前的所有分支，星号“*”开头的“main”为当前活动分支。$ git branch dev* main 7.3、分支的切换checkout代码仓库可以有多个分支，master为默认的主分支，但只有一个分支在工作状态。所以要操作不同分支，需要切换到该分支，HEAD就是指向当前正在活动的分支。 123456# 切换到dev分支，HEAD指向了dev# 此处 switch 作用同 checkout，switch只用于切换，不像checkout功能很多$ git switch devSwitched to branch &#x27;dev&#x27;$ cat .git/HEADref: refs/heads/dev 使用 git checkout dev切换分支时，干了两件事： ①、HEAD指向dev：修改HEAD的“指针”引用，指向dev分支。 ②、还原工作空间：把dev分支内容还原到工作空间。 此时的活动分支就是dev了，后续的提交就会更新到dev分支了。 ❓切换时还没提交的代码怎么办？ 如果修改（包括未暂存、已暂存）和待切换的分支没有冲突，则切换成功，且未提交修改会一起带过去，所以要注意！ 如果有冲突，则会报错，提示先提交或隐藏，关于隐藏可查看后续章节内容“stash”。 7.4、合并merge&amp;冲突把两个分支的修改内容合并到一起，常用的合并指令git merge [branch]，将分支[branch]合并到当前分支。根据要合并的内容的不同，具体合并过程就会有多种情况。 🔸快速合并（Fast forward）如下图，master分支么有任何提交，“git merge dev”合并分支dev到master，此时合并速度就非常快，直接移动master的“指针”引用到dev即可。这就是快速合并（Fast forward），不会产生新的提交。 合并dev到master，注意要先切换到master分支，然后执行git merge dev，把dev合并到当前分支。 📢强制不用快速合并：git merge --no-ff -m &quot;merge with no-ff&quot; dev，参数--no-ff不启用快速合并，会产生一个新的合并提交记录。 🔸普通合并如果master有变更，存在分支交叉，则会把两边的变更合并成一个提交。 如果两边变更的文件不同，没有什么冲突，就自动合并了。 如果有修改同一个文件，则会存在冲突，到底该采用哪边的，程序无法判断，就换产生冲突。冲突内容需要人工修改后再重新提交，才能完成最终的合并。 上图中，创建dev分支后，两个分支都有修改提交，因此两个分支就不在一条顺序线上了，此时合并dev到master就得把他们的修改进行合并操作了。 v5、v7共同祖先是v4，从这里开始分叉。 Git 会用两个分支的末端v6 和 v8以及它们的共同祖先v4进行三方合并计算。合并之后会生成一个新（合并）提交v9。 合并提交v9就有两个祖先v6、v8。 🔸处理冲突&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD在有冲突的文件中，&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD开头的内容就表示是有冲突的部分，需要人工处理，可以借助一些第三方的对比工具。人工处理完毕后，完成合并提交，才最终完成此次合并。=======分割线上方是当前分支的内容，下方是被合并分支的变更内容。 7.5、变基rebase把两个分支的修改内容合并到一起的办法有两种：merge 和 rebase，作用都是一样的，区别是rebase的提交历史更简洁，干掉了分叉，merge的提交历史更完整。 在dev上执行“git rebase master”变基，将dev分支上分叉的v7、v8生成补丁，然后在master分支上应用补丁，产生新的v7&#39;、v8&#39;新的提交。 然后回到master分支，完成合并git merge dev，此时的合并就是快速合并了。 最终的提交记录就没有分叉了。 1234567# 先切换到代合并分支dev, 完成rebase master后，dev和master就没有分叉了$ git checkout dev$ git rebase master# dev和master此时并无分叉，直接fast-forward合并$ git checkout master$ git merge dev 08、标签管理标签（Tags）指的是某个分支某个特定时间点的状态，是对某一个提交记录的的固定“指针”引用。一经创建，不可移动，存储在工作区根目录下.git\\refs\\tags。可以理解为某一次提交（编号）的别名，常用来标记版本。所以发布时，一般都会打一个版本标签，作为该版本的快照，指向对应提交commit。 当项目达到一个关键节点，希望永远记住那个特别的提交快照，你可以使用 git tag 给它打上标签。比如我们今天终于完成了V1.1版本的开发、测试，并成功上线了，那就可给今天最后这个提交打一个标签“V1.1”，便于版本管理。 默认标签是打在最新提交的commit上的，如果希望在指定的提交上打标签则带上提交编号（commit id）：git tag v0.9 f52c633 指令 描述 git tag 查看标签列表 git tag -l ‘a*‘ 查看名称是“a”开头的标签列表，带查询参数 git show [tagname] 查看标签信息 git tag [tagname] 创建一个标签，默认标签是打在最新提交的commit上的 git tag [tagname] [commit id] 新建一个tag在指定commit上 git tag -a v5.1 -m’v5.1版本’ 创建标签v5.1.1039，-a指定标签名，-m指定说明文字 git tag -d [tagname] 删除本地标签 git checkout v5.1.1039 切换标签，同切换分支 git push [remote] v5.1 推送标签，标签不会默认随代码推送推送到服务端 git push [remote] –tags 提交所有tag 如果要推送某个标签到远程，使用命令git push origin [tagname]，或者，一次性推送全部到远程：git push origin --tags 📢注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。 12345678# tag$ git tag -a &#x27;v1&#x27; -m&#x27;v1版本&#x27;$ cat .git/refs/tags/v1a2e2c9caea35e176cf61e96ad9d5a929cfb82461 # 查看标签列表$ git tagv1 09、后悔药-怎么撤销变更？发现写错了要回退怎么办？看看下面几种后悔指令吧！ ❓还没提交的怎么撤销？ —— checkout、reset 还未提交的修改（工作区、暂存区）不想要了，用签出指令（checkout）进行撤销清除。 或者用checkout的新版回滚指令reset。 ❓已提交但没有push的提交如何撤销？—— reset、revert ❓已push的提交如何撤销？—— 同上，先本地撤销，然后强制推送git push origin -f，⚠️注意慎用！ 记得先pull获取更新。 9.1、后悔指令🔥 指令 描述 git checkout . 撤销工作区的（未暂存）修改，把暂存区恢复到工作区。不影响暂存区，如果没暂存，则撤销所有工作区修改 git checkout [file] 同上，file指定文件 git checkout HEAD . 撤销工作区、暂存区的修改，用HEAD指向的当前分支最新版本替换工作区、暂存区 git checkout HEAD [file] 同上，file指定文件 git reset 撤销暂存区状态，同git reset HEAD，不影响工作区 git reset HEAD [file] 同上，指定文件file，HEAD可省略 git reset [commit] 回退到指定版本，清空暂存区，不影响工作区。工作区需要手动git checkout签出 git reset –soft [commit] 移动分支master、HEAD到指定的版本，不影响暂存区、工作区，需手动git checkout签出更新 git reset –hard HEAD 撤销工作区、暂存区的修改，用当前最新版 git reset –hard HEAD~ 回退到上一个版本，并重置工作区、暂存区内容。 git reset –hard [commit] 回退到指定版本，并重置工作区、暂存区内容。 git revert [commit] 撤销一个提交，会用一个新的提交（原提交的逆向操作）来完成撤销操作，如果已push则重新push即可 git checkout .、git checkout [file] 会清除工作区中未添加到暂存区的修改，用暂存区内容替换工作区。 git checkout HEAD .、 git checkout HEAD [file] 会清除工作区、暂存区的修改，用HEAD指向的当前分支最新版本替换暂存区、工作区。 1234567# 只撤销工作区的修改（未暂存）$ git checkout .Updated 1 path from the index # 撤销工作区、暂存区的修改$ git checkout HEAD .Updated 1 path from f951a96 9.2、回退版本resetreset是专门用来撤销修改、回退版本的指令，支持的场景比较多，多种撤销姿势，所以参数组合也比较多。简单理解就是移动master分支、HEAD的“指针”地址，理解这一点就基本掌握reset了。 如下图： 回退版本git reset --hard v4 或 git reset --hard HEAD~2，master、HEAD会指向v4提交，v5、v6就被废弃了。 也可以重新恢复到v6版本：git reset --hard v6，就是移动master、HEAD的“指针”地址。 reset有三种模式，对应三种参数：mixed（默认模式）、soft、hard。三种参数的主要区别就是对工作区、暂存区的操作不同。 mixed为默认模式，参数可以省略。 只有hard模式会重置工作区、暂存区，一般用这个模式会多一点。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 12345678910111213141516171819202122git reset [--soft | --mixed | --hard] [HEAD] # 撤销暂存区$ git resetUnstaged changes after reset:M R.md # 撤销工作区、暂存区修改$ git reset --hard HEAD # 回退版本库到上一个版本，并重置工作区、暂存$ git reset --hard HEAD~ # 回到原来的版本（恢复上一步的撤销操作），并重置工作区、暂存$ git reset --hard 5f8b961 # 查看所有历史提交记录$ git reflogccb9937 (HEAD -&gt; main, origin/main, origin/HEAD) HEAD@&#123;0&#125;: commit: 报表新增导入功能8f61a60 HEAD@&#123;1&#125;: commit: bug：修复报表导出bug4869ff7 HEAD@&#123;2&#125;: commit: 用户报表模块开发4b1028c HEAD@&#123;3&#125;: commit: 财务报表模块开发完成 9.3、撤销提交revert安全的撤销某一个提交记录，基本原理就是生产一个新的提交，用原提交的逆向操作来完成撤销操作。注意，这不同于reset，reset是回退版本，revert只是用于撤销某一次历史提交，操作是比较安全的。 如上图： 想撤销v4的修改，执行git revert v4，会产生一个新的提交v-4，是v4的逆向操作。 同时更新maser、HEAD“指针”位置，以及工作区内容。 如果已push则重新push即可。 1234# revert撤销指定的提交，“-m”附加说明$ git revert 41ea42 -m &#x27;撤销对***的修改&#x27;[main 967560f] Revert &quot;123&quot; 1 file changed, 1 deletion(-) 9.4、checkout&#x2F;reset&#x2F;revert总结 标题 \\ 指令 checkout reset revert 主要作用（撤销） 撤销工作区、暂存区未提交修改 回退版本，重置工作区、暂存区 撤销某一次提交 撤销工作区 git checkout [file] git reset HEAD [file] 撤销工作区、暂存区 git checkout HEAD [file] git reset –hard HEAD [file] 回退版本 git reset –hard [commit] 安全性 只针对未提交修改，安全 如回退了已push提交，不安全 安全 可看出reset完全可以替代checkout来执行撤销、回退操作，reset本来也是专门用来干这个事情的，可以抛弃checkout了（撤销的时候）。 10、工作中的Git实践10.1、Git flowGit flow（Git工作流程）是指软件项目中的一种Git分支管理模型，经过了大量的实践和优化，被认为是现代敏捷软件开发和DevOps（开发、技术运营和质量保障三者的交集）的最佳实践。Git flow主要流程及关键分支：原图地址-processon ✅主分支：master，稳定版本代码分支，对外可以随时编译发布的分支，不允许直接Push代码，只能请求合并（pull request），且只接受hotfix、release分支的代码合并。 ✅热修复分支：hotfix，针对线上紧急问题、bug修复的代码分支，修复完后合并到主分支、开发分支。 ① 切换到hotfix分支，从master更新代码； ② 修复bug； ③ 合并代码到dev分支，在本地Git中操作即可； ④ 合并代码到master分支。 ✅发版分支：release，版本发布分支，用于迭代版本发布。迭代开发完成后，合并dev代码到release，在release分支上编译发布版本，以及修改bug（定时同步bug修改到dev分支）。测试完成后此版本可以作为发版使用，然后把稳定的代码push到master分支，并打上版本标签。 ✅开发分支：dev，开发版本分支，针对迭代任务开发的分支，日常开发原则上都在此分支上面，迭代完成后合并到release分支，开发、发版两不误。 ✅其他开发分支：dev-xxx，开发人员可以针对模块自己创建本地分支，开发完成后合并到dev开发分支，然后删除本地分支。 10.2、金屋藏娇stash当你正在dev分支开发一个功能时，代码写了一半，突然有一个线上的bug急需要马上修改。dev分支Bug没写完，不方便提交，就不能切换到主分支去修复线上bug。Git提供一个stash功能，可以把当前工作区、暂存区 未提交的内容“隐藏”起来，就像什么都没发生一样。 1234567891011121314151617# 有未提交修改，切换分支时报错$ git checkout deverror: Your local changes to the following files would be overwritten by checkout: README.mdPlease commit your changes or stash them before you switch branches.Aborting # 隐藏$ git stashSaved working directory and index state WIP on main: 2bc012c # 查看被隐藏的内容$ git stash liststash@&#123;0&#125;: WIP on main: 2bc012c # 比较一下，什么都没有，一切都没有发生过！$ git diff # 去其他分支修改bug，修复完成回到当前分支，恢复工作区$ git stash pop 在上面示例中，有未提交修改，切换分支时报错。错误提示信息很明确了，commit提交或stash隐藏：Please commit your changes or stash them before you switch branches. 📢 如果切换分支时，未提交修改的内容没有冲突，是可以成功切换的，未提交修改会被带过去。 指令 描述 git stash 把未提交内容隐藏起来，包括未暂存、已暂存。 等以后恢复现场后继续工作 git stash list 查看所有被隐藏的内容列表 git stash pop 恢复被隐藏的内容，同时删除隐藏记录 git stash save “message” 同git stash，可以备注说明message git stash apply 恢复被隐藏的文件，但是隐藏记录不删除 git stash drop 删除隐藏记录 📢 当然这里先提交到本地也是可以的，只是提交不是一个完整的功能代码，而是残缺的一部分，影响也不大。 拣选提交cherry-pick当有一个紧急bug，在dev上修复完，我们需要把dev上的这个bug修复所做的修改“复制”到master分支，但不想把整个dev合并过去。为了方便操作，Git专门提供了一个cherry-pick命令，让我们能复制一个特定的提交到当前分支，而不管这个提交在哪个分支。 如上图，操作过程相当于将该提交导出为补丁文件，然后在当前HEAD上重放，形成无论内容还是提交说明都一致的提交。 希望把dev分支上的v7提交的内容合并到master，但不需要其他的内容。 在master分支上执行指令git cherry-pick v7，会产生一个新的v7&#39;提交，内容和v7相同。 同时更新master、HEAD，以及工作区。 12# 选择一个commit，合并进当前分支$ git cherry-pick [commit] 参考资料 博客园 | 深入浅出Git教程 猴子都能懂的GIT入门 廖雪峰的GIT教程 电子书《ProGit-Git教程》 Gitee码云的 Git 大全，真的挺全 敏捷过程实践-git代码分支管理规范 易百教程-Git教程？ 在线Git学习+练习 GUI Clients Git网站上的GUI工具列表 Git常用指令集合🔥🔥","tags":["git"]},{"title":"非常详细的git图文教程","path":"/2025/05/30/非常详细的git图文教程/","content":"转载自: https://blog.csdn.net/Javachichi/article/details/140660754 Git安装安装1.先去官网下载这个软件, 准备安装到本电脑中 https://git-scm.com/ 2.根据自己电脑系统下载此软件到本机 Windows 系统直接下载 .exe 文件即可，macOS 系统使用 Homebrew 命令行安装，终端输入 git --version 确认安装 3.默认选择默认安装路径即可，如若想更改路径，务必使用英文路径 4.对于 Windows 系统，查看安装是否成功: 在任意文件夹右键，查看是否有Git Base Here 选项，有就成功了 介绍Git 的三个区域： 工作区： 处理工作的区域 暂存区： 临时存放的区域 本地git仓库： 最终的存放区域 在文件夹的体现如下： 工作区： 在你电脑里看到的目录 暂存区： 在.git文件夹内的index中 (二进制记录) 版本库： 指的整个.git文件夹 (也认为是本地仓库) 在代码中的体现如下： Git使用官方文档：教程链接[1] 菜鸟教程：教程链接[2] Git配置安装完 Git 之后，要做的第一件事就是设置你的用户名和邮件地址。因为每一个 Git 提交都会使用这些信息 命令格式如下：中文自己看情况换 git config： 固定命令，设置git相关配置 –global： 全局配置；一次配置，整机在使用git时都生效 123git config --global user.name 你的用户名 git config --global user.email 你的邮箱地址 运行命令效果如下： 配置后，可以运行如下命令查看是否成功 123git config --list #如果信息太多，可以输入 q 退出 运行命令效果如下： 出现以上内容即为注册成功。如果后续想要修改，只需要重新执行一下命令即可 文件右侧标记一般使用 VSCode 打开一个包含git仓库的文件夹时，会有这些标记 右侧没有标记的时候为未修改 或 此文件&#x2F;文件夹，被git忽略不跟踪变化 M：已修改（Modified） - 文件已被修改但还没有被添加到暂存区 A：已添加（Added） - 文件已经被添加到暂存区，但还没有被提交 D：已删除（Deleted） - 文件已经被删除，并且已经被标记为删除，但还没有提交 R：已重命名（Renamed） - 文件已经被重命名，这也算作是一种修改，需要被添加到暂存区 C：已复制（Copied） - 文件已经被复制，这也算作是一种修改，需要被添加到暂存区 U：已更新但未融合（Updated but Unmerged） - 这表示一个文件已经被更新了，但在合并时发生了冲突，需要手动解决冲突后再标记为已解决 Git基础命令初始化空的Git仓库 新建一个文件夹或现有的文件夹并不是 git 仓库，因为文件夹内不包含 .git 文件夹，没有被 git 管理 可以在新文件夹或现有文件夹，运行如下命令得到 .git 文件夹，初始化成功则可让 git 开始准备管理 123# 初始化 git 仓库, 产物: .git 文件夹 (所在文件夹&quot;内&quot;被管理) git init 例如，在新文件夹中输入git init命令用于初始化空的git版本库 初始化空的 git 仓库成功后，在项目文件夹中，开启显示隐藏文件，即可查看 .git 文件夹 对于 Windows 系统，在查看里面勾选隐藏的项目选项 对于 macOS 系统，使用快捷键Command + Shift + .切换隐藏文件显示 记录更新到Git仓库 每当完成了一个阶段的目标，想要记录下它时，就将它提交到仓库 核心操作：工作区开发—&gt;将修改后的文件添加到暂存区—&gt;将暂存区的文件记录到版本库 把工作区变化放到暂存区中，执行如下命令 123456# 将 index.html 添加到暂存区 git add index.html # 将css目录下一切添加到暂存区 git add css 如下命令，可以一次性把所有变化文件放入暂存区 123# .的意思是当前目录下所有变化都暂存 git add . 把暂存区内容，提交到版本库，命令如下（此处文字说明可以不加引号） 12git commit -m &#x27;提交的内容说明&#x27; 过程图示： 以上命令相当于存档了一次，在版本库中产生一次提交记录并生成版本号 本次存档，不耽误我们在工作区 (项目文件夹) 下继续编写项目 Git日志及状态查看 查看所有提交的日志记录，命令如下 12git log 运行命令效果如下： 当我们的日志越来越多，可能想要简化查看，可以输入如下命令 –oneline：在一行显示简略信息 12git log --oneline 运行命令效果如下： 如果改的代码过多，忘记改过哪些了，可以运行如下命令来查看 git 仓库变化，只能看未提交的所有变更的文件状态 12git status 运行命令效果如下： 暂存并再次提交，产生一次版本记录 123git add . git commit -m &#x27;新建登录页面_和样式&#x27; 过程图示： Git版本回退 时光机，回到过去~ 回退命令语法如下 12git reset --hard 版本号 查看版本号（每次的版本号随机生成） 12git log --oneline 尝试回退到 477321b 这次记录上 12git reset --hard 477321b 观察工作区，回退成功 如果想要在回到最近一次提交的记录，但发现git log看不到未来的记录了，问题不大。输入git reflog命令，可以查看 git 所有的操作记录，包括你的reset记录 12git reflog 运行命令效果如下： 拓展命令： git bash（终端）清屏：clear git bash（终端）另起一页：Ctrl + L Git忽略文件 有的时候，我们某些文件或文件夹不想让 git 进行跟踪管理。这时候可以在 .git 文件夹同级目录下新增.gitignore的忽略文件并写入忽略规则（此处的文件名就是 .gitignore ，不是后缀） 项目文件夹结构如下： 1234567891011# .gitignore内容： password.txt 其余用法： # 忽略文件夹 css # 忽略文件夹下的某个文件 css/index.js # 忽略文件夹下某类文件 css/*.js 根目录新建 password.txt，查看 git 追踪到了哪些变化 12git status 运行命令效果如下： 发现只新增了.gitignore ，符合规则的都被忽略掉了 .gitignore文件在项目中可以根据脚手架自动生成，无需自己编写，当然如果你非要写，以下是Vue官方自动生成的.gitignore文件代码，可供复制使用 12345678910111213141516171819202122232425# Logs logs *.log npm-debug.log* yarn-debug.log* yarn-error.log* pnpm-debug.log* lerna-debug.log* node_modules dist dist-ssr *.local # Editor directories and files .vscode/* !.vscode/extensions.json .idea .DS_Store *.suo *.ntvs* *.njsproj *.sln *.sw? Git分支分支本质 分支其实就是一个叫HEAD的指针标记，每次代码提交，此HEAD指针都会往后移动一次，保证指向的 (并且工作区里的) 都是最后一次提交 例如：当我们输入命令：git reset --hard a3bcab2，HEAD指针会移动，而且HEAD移动后，会影响工作区里的代码 创建分支 创建分支命令如下 123# 创建分支 git branch 分支名 该命令创建分支后不会自动切换分支，我们可以运行命令查看现在这个 .git 版本库里所有分支 查看当前版本库所有分支命令如下 123# 查看当前版本库所有分支，绿色带*代表现在所处的分支 git branch 运行命令效果如下： 手动切换到分支上 123# 切换分支命令 git checkout 分支名 运行命令效果如下： 第一次创建并切换到 reg 分支，你会发现 master 分支上的所有代码 (和当前节点所有提交记录) 都被复制了过来 了，我们只需要在这个基础上接着往后开发就行 过程图示： 分支下开发流程 我们现在就可以在当前 reg 分支下来编写注册页面的逻辑代码，例如新建reg.html文件，并随便写点内容。随后暂存并提交一次，这次提交的记录会出现在这里，如图 以后在当前 reg 分支下开发，就会在 reg 范围内，每次提交产生一次版本记录，不会影响到别的分支 分支合并 我们可以把分支里写好的代码，合并到主分支或其他分支上，步骤如下： 首先，切换到你要合并到的目标分支上（以master主分支为例） 123# 切换分支 git checkout master 切换分支后，HEAD指针位置如下： 合并命令语法 123# 把目标分支名下的所有记录, 合并到当前分支下 git merge 目标分支名 这里我们执行命令git merge reg，执行后效果如图： 可见，reg 代码提交记录已经复制到了 master (主分支) 中 分支删除 假如注册功能开发完毕，代码已经合并到 master 分支上，我们已经不需要 reg 分支 命令如下 12git branch -d 分支名 如果分支的修改没有被合并到其他分支上，Git 会提示一个类似以下的错误信息： 12error: The branch &#x27;branch_name&#x27; is not fully merged. If you are sure you want to delete it, run &#x27;git branch -D branch_name&#x27;. 在这种情况下，Git 建议你确认是否要删除这个分支。如果你确定要删除该分支并且不在乎丢失该分支的修改，你可以使用git branch -D &lt;branch_name&gt;命令来强制删除该分支。但请注意，这样会丢失掉分支上的未合并修改 分支合并时的冲突问题 在两个分支修改了同一个文件并提交过，在合并的时候，就会产生冲突 这里模拟一次简单的冲突： 在 master 分支下，修改login.html的某行代码，并完成一次暂存提交 切换到 reg 分支下，也修改login.html的对应行代码，并完成一次暂存提交 再切换回到 master 分支下，用合并命令，把 reg 分支下代码和变化合并过来，不出意外就会出现冲突了 发生冲突后，VSCode界面 此时我们要进行抉择：采用当前更改、采用传入更改、全部保留 选择保留方式后，需要再次暂存提交一次 此时结束冲突状态，变回正常状态 打印冲突合并后的日志记录 总结：当我们合并遇到冲突了，应手动解决，然后暂存，提交一次即可 Git分支流程图详解（拓展）HEAD头指针，它指向当前所在的分支或者某个具体的提交记录。每次提交会产生新的记录master和HEAD会后移 以当前节点为基准创建新的分支 (包含之前的所有提交记录)，git branch reg 就会在当前的提交记录上创建一个新的指针，名称为reg git checkout reg切换的是HEAD指针指向 (切换分支) 注册页面新建后，git add .添加到暂存区，git commit -m 产生了一次提交记录 注册页面的样式新建后暂存提交，产生了一次提交记录 合并分支，例如把 A 合并到 B上 git checkout B，切换到目标分支 B git merge A，把 A 分支记录合并到所在 B 分支下 先切换到主分支git checkout master 合并reg分支git merge reg 在reg分支下，修改了index.html文件，并暂存提交，产生了记录 切换到master分支，并修改index.html文件(同一个文件)，暂存提交，产生了记录 在master分支中，想要把reg合并过来。由于修改了同一个文件，会报错，需要解决冲突 手动解决冲突后，会产生一个新的提交记录 删除reg分支，全部过程结束 Git远程仓库介绍 远程仓库是指托管在因特网或其他网络上的 Git 仓库，可以存储我们版本库的所有记录和存档记录 远程仓库在团队协作中发挥着重要的作用。它不仅可以充当备份存储，保护你的代码免受数据丢失的风险，还可以让团队成员之间轻松地共享代码、查看代码变更、进行代码审查等 主流的远程仓库有 GitHub (gay hub)全球最大的同行交友社区，以及服务器在国内的 gitee（码云）。由于 GitHub 服务器在国外，方便起见，这里以码云为例，供初学者参考，GitHub 流程与 gitee 类似 注册 注册登录 gitee.com 网站以后，添加主邮箱为自己本地 git 仓库设置的邮箱，注意一定要相同，否则无法正确提交 如果忘记了本地设置的邮箱地址： 可以打开控制台输入 git config --list 重新查看邮箱地址 当然也可以使用 git config --global user.email 你的邮箱地址重新覆盖原来的邮箱地址 邮箱设置界面不要勾选不公开我的邮箱地址，否则也无法正常提交 仓库新建 可以选择创建一个远程仓库的项目 (可以多个)，创建界面如下 勾选完成后选择创建，创建后， 会得到一个远程仓库的地址链接，一般是以.git结尾的地址 地址分为两种最常用的两种传输协议： HTTPS协议： 需要输入用户名和密码https://gitee.com/(userName)/(repositoryName).gitssh SSH协议： 需要配置密钥，可免密码登录git@gitee.com:userName/repositoryName.git 选择SSH路径，界面如下 SSH配置 我们可以在本机一次性配置 SSH 以后免密登录，SSH 密钥组成和作用如下： 作用： 实现本地仓库和 gitee 平台之间免登录的加密数据传输 组成： id_rsa (私钥文件，存放于客户端的电脑中即可)、id_rsa.pub (公钥文件，需要配置到 gitee 平台中) 私钥加密的信息，只能通过公钥解密。公钥加密的信息，只能通过私钥解密。安全性高！ SSH 密钥创建与使用步骤： 先在本机生成一个密钥 (以后也可以重新生成、重新配置)，打开一个终端，输入以下命令： 12ssh-keygen -t rsa -C &quot;你注册账号的邮箱&quot; 连续敲击 3 次回车，即可在C:\\Users\\用户名文件夹.ssh目录中生成id_rsa和id_rsa.pub两个文件 使用 VSCode 打开id_rsa.pub文件，复制里面的文本内容 粘贴配置到 码云 -&gt; 设置 -&gt; ssh 公钥 中即可 如果为 mac ，可进入以下教程查看：mac获取公钥 初始化空仓库 先给本地仓库配置个远程仓库的地址, 建立仓库之间的链接 由于每次 push 操作都需要带上远程仓库的地址，十分麻烦，我们可以给仓库设置一个别名 12345678910# 给远程仓库设置一个别名 git remote add 仓库别名 仓库地址 git remote add origin git@gitee.com:(username)/repository.git # 删除 origin 这个别名 git remote remove origin # 使用 -u 记录 push 到远端分支的默认值，将来直接 git push 即可 git push -u 仓库别名 分支名 下面为实际操作举例： 随便新建一个项目文件夹，初始化 git，随后在项目文件中随便填充点内容，这里我新增一个.gitignore文件，随后暂存提交到本地 git 库 输入以下命令： 123456789101112# 注意：这里的existing_git_repo是你的项目根路径 # 如果你是在项目文件夹开启的终端，忽略此行 cd existing_git_repo # 添加远程仓库关联，仓库别名origin，可以随意更改，后接ssh地址 # 此处的ssh是自动生成的，可以去gitee空仓库的代码页直接复制即可 git remote add origin git@gitee.com:li-houyi/test-factory.git # 第一次推送到远程时需要指定具体的分支，因为远程仓库并没有这个分支 # 使用 -u 记录 push 到远端分支的默认值，将来直接 git push 即可 git push -u origin &quot;master&quot; 出现此页面即为成功： 注意：推送的本地仓库一定要非空并且本地暂存提交过，不然会报错！这点也很好理解，你传个空的项目到一个空仓库，这可不得给你报错吗 推送成功后重新进入 gitee 仓库页面查看是否正确推送 空仓库创建成功后可以在管理页面将仓库开源，当然也可以不设置开源（默认私有） 克隆项目 如果你想要从远程仓库克隆一份项目代码到本地进行开发，可以使用 git clone 命令 123git clone [options] &lt;repository-url&gt; [directory] # directory（可选）克隆后的本地仓库所处的目录名称（默认创建与远程仓库名字相同的目录） 常见选项： -b &lt;branch&gt; 或 --branch &lt;branch&gt;： 指定要克隆的远程仓库的特定分支，它不会影响克隆操作所获取的分支数量，而只是指定了默认要检出的分支（不指定则默认克隆远程仓库的主分支） --depth &lt;depth&gt;： 指定克隆的深度，即只克隆指定数量的提交历史 –single-branch： 仅克隆指定分支以及该分支上的历史记录，不下载其他分支 –recurse-submodules： 初始化并克隆子模块的内容 -n 或 –no-checkout： 克隆后不立即检出任何分支，保留 HEAD 指向原始仓库的默认分支 -o &lt;name&gt; 或 --origin &lt;name&gt;： 自定义远程仓库的别名。 -u &lt;remote&gt; &lt;branch&gt; 或 --set-upstream-to=&lt;remote&gt;/&lt;branch&gt;： 设置追踪关系，使得本地分支自动与指定的远程分支关联 如果项目只有一个分支，那么以上代码执行完毕就已经克隆结束了（git clone 默认拉取 master 分支），不过实际开发中，并非只有一个分支，于是我们还需执行以下步骤： 在本地建分支，分支名与远程分支名相同，查看远程分支名使用git branch -r 12git checkout -b 对应远程分支名 拉取远程分支 (不要在 master 分支直接拉取对应分支的代码，切换到新建的分支) 123# 每次拉取都需要指定远程仓库名和分支名 git pull 远程仓库名 分支名 以上两行命令可以合并写做一行（创建并拉取远程分支代码） 12git checkout -b 分支名 origin/分支名 拓展: 设置 git pull 默认拉取的分支（设置本地分支与远程分支相关联） 12git branch --set-upstream-to=origin/远程分支名 本地分支名 Git远程仓库流程回顾 Step1： Step2： Step3： Step4： Git常用命令总览本命令默认远程仓库名为origin、默认远程仓库主分支名为master、&lt;&gt;为必填项，[]为可选项","tags":["git"]},{"title":"git快速入门教程","path":"/2025/05/29/git快速入门教程/","content":"转载自: https://blog.csdn.net/qq_16027093&#x2F;article&#x2F;details&#x2F;130503317 Git简介Git 是一种分布式版本控制系统，用于管理软件项目的源代码。它是由 Linux 之父 Linus Torvalds 开发的，并已经成为了现代软件开发领域中最流行的版本控制系统之一。 使用 Git 可以追踪代码的历史修改记录，方便团队协作、代码共享和代码重构。Git 的基本工作流程如下： 在开始编写代码之前，首先需要创建一个 Git 仓库（repository），用于存储代码和版本历史记录。 在编写代码时，可以通过 git add 命令将更改的文件添加到 Git 的暂存区（staging area）中。 通过 git commit 命令将暂存区中的更改提交到本地 Git 仓库中，并生成一个新的版本号（commit hash）。 如果需要撤销某个提交，可以使用 git revert 命令来创建一个新的提交，该提交将会抵消先前的提交效果。 如果需要合并不同分支的代码，可以使用 git merge 命令进行合并。 如果需要查看代码的历史提交记录，可以使用 git log 命令来获取详细信息。 如果需要将代码推送到远程仓库，可以使用 git push 命令将本地代码推送到远程仓库。 如果需要从远程仓库获取代码，可以使用 git pull 命令将远程代码拉取到本地。 Workspace：工作区 Index &#x2F; Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 SVN与Git的的区别SVN和Git都是版本控制系统，但它们有以下区别： 分布式 vs 集中式：Git 是一种分布式版本控制系统，而 SVN 是一种集中式版本控制系统。在 Git 中，每个开发者都拥有本地代码库的完整副本，可以离线工作并在不同的工作流程之间自由转换。而在 SVN 中，所有开发者共享同一个中央代码库，并且需要有网络连接才能进行版本控制操作。 分支管理：Git 在分支管理方面比 SVN 更加强大和灵活。Git 的分支非常轻量级，创建和合并分支也很容易，因此可以轻松实现多人协作和并行开发。而在 SVN 中，分支比较重量级（即创建和合并分支需要花费相对更多的时间和资源），因此往往只用于重要的版本分支。 版本号：Git 使用 SHA-1 哈希值来标识每个提交，而 SVN 采用递增的数字版本号来标识每个提交。SHA-1 哈希值保证了每个提交的唯一性，而递增版本号则简化了版本控制过程。 安全性：由于 SVN 是一种集中式版本控制系统，因此所有数据都存储在中央代码库中。如果中央代码库损坏或丢失，可能会导致数据丢失或无法恢复。而 Git 是一种分布式版本控制系统，每个开发者都拥有完整的代码库副本，保证了代码的整体性和可靠性。 性能：Git 比 SVN 更快，特别是在处理大型仓库、分支合并以及比较代码差异时。Git 使用基于内容的哈希算法来检测文件是否修改，而 SVN 则需要检查文件的元数据（如时间戳和文件大小）来确定是否修改。 总之，虽然 SVN 和 Git 都是版本控制系统，但它们的设计和实现方式存在较大差异，开发人员应根据自身需求选择最适合的版本控制系统。 常规操作创建版本库首先，打开终端或命令行界面，进入要创建版本库的目录下。 接着，使用以下命令初始化一个空的 Git 仓库： 1git init 然后，将需要管理的文件添加到暂存区： 1git add &lt;file&gt; 你也可以使用以下命令一次性将所有变更添加到暂存区： 1git add . 接下来，提交暂存区中的变更到本地仓库，并添加一个描述信息： 1git commit -m &quot;Initial commit&quot; 现在，你已经成功地创建了一个版本库。你可以使用其他 Git 命令来管理它，例如： git status：查看当前工作区和暂存区的状态。 git log：查看提交记录。 git branch：管理分支。 git remote：管理远程仓库。 版本回退要将Git存储库版本回退，请使用git reset命令。如果您想要撤消上次提交并返回到上一个提交，则可以使用以下命令： 12# 将HEAD指针移动到上一个提交，本地仓库回退到上一个提交，暂存区和工作区不变git reset HEAD~1 这将使HEAD指向上一个提交，但不会删除您最新的更改。如果您希望完全返回到以前的提交并放弃所有更改，则可以添加–hard选项： 12# 把本地仓库，暂存区，工作区都回退到上一个提交git reset --hard HEAD~1 请注意，此操作将永久删除您最新的更改，请谨慎使用。如果您已经将更改推送到远程存储库，则在执行此操作之前应先备份这些更改。 理解工作区与暂存区的区别Git有三个主要的工作区域：工作区（working directory）、暂存区（staging area）和版本库（repository）。 工作区是指您电脑文件系统上用于修改文件的目录。在这里，您可以创建、编辑和删除文件。 暂存区是一个中间状态，它充当了您提交更改的缓冲区。在Git中，您必须明确地将文件添加到暂存区，然后才能将其提交到版本库中。这样做的好处是，您可以对每个更改进行精细控制，并确保只提交需要保存的更改。 版本库包含Git存储库的所有历史记录和元数据。它是Git存储库的核心组成部分，是由Git自动维护的。 简而言之，工作区是您正在处理的实际文件，而暂存区是下一次提交所需更改的文件列表。它们之间的区别在于，您可以对工作区中的任何文件进行修改，但只有将它们添加到暂存区并将其提交到版本库中，它们才会成为Git跟踪的部分。 Git撤销修改和删除文件操作要撤销对文件的修改，可以使用git checkout命令： 12# 将工作区中的文件还原为暂存区的状态git checkout -- &lt;filename&gt; 此命令将覆盖工作树中指定文件的更改，还原为最近提交或上次检出的状态。 要删除文件并将此更改提交到Git存储库中，可以使用git rm命令： 123git rm &lt;filename&gt;git commit -m &quot;Remove file&quot; 这将从工作树和版本历史记录中删除指定的文件。如果只是想从Git版本库中删除文件但保留在工作树中，则可以使用git rm命令的–cached选项： 123git rm --cached &lt;filename&gt;git commit -m &quot;Remove file from repository&quot; 这将从版本历史记录中删除指定的文件，但保留在工作树中。 远程仓库如何添加远程仓库要将本地代码库连接到远程仓库，可以使用以下git命令： 首先，将本地代码库初始化为Git仓库（如果尚未完成）：git init 添加远程仓库的URL，其中&lt;remote-name&gt;是自定义名称，&lt;remote-url&gt;是远程仓库的URL：git remote add &lt;remote-name&gt; &lt;remote-url&gt; 可以使用以下命令确认远程仓库是否已成功添加：git remote -v 此后，您就可以使用git push命令将代码推送到远程仓库，或使用git pull命令从远程仓库拉取代码。 如何从远程库克隆要从远程仓库克隆代码到本地，可以使用以下git命令： 1git clone &lt;remote-url&gt; 其中&lt;remote-url&gt;是远程仓库的URL。执行此命令后，Git将在当前目录下创建一个新目录，其中包含克隆的代码库副本。如果想指定不同的目录名，可以将目录名作为可选参数添加到命令中： 1git clone &lt;remote-url&gt; &lt;directory-name&gt; 在执行git clone命令时，还可以通过添加其他标志来更改默认行为，例如指定要克隆的分支、禁用克隆时自动检查的文件等。有关详细信息，请参阅相应的文档。 创建与合并分支创建一个新的分支可以使用以下命令： 12git branch &lt;branch_name&gt; 这将在当前所在的提交上创建一个名为 &lt;branch_name&gt; 的新分支。 要切换到新创建的分支，可以使用以下命令： 1git checkout &lt;branch_name&gt; 基于当前分支创建新分支并立即切换到新分支，可以使用以下命令： 12git checkout -b &lt;branch_name&gt; 合并分支可以使用以下命令： 1git merge &lt;branch_name&gt; 这将将 &lt;branch_name&gt; 分支中的更改合并到当前分支。 处理冲突当两个分支上的代码修改了同一部分，并且尝试将这两个分支合并时，就会发生代码冲突。Git提供了以下步骤来解决冲突： 运行 git status 命令查看哪些文件包含冲突。 编辑有冲突的文件，手动解决文件中的冲突。 对编辑后的文件进行 git add，标记为已解决冲突的文件。 使用 git commit 提交更改，Git 会自动生成一个合并提交，其中包含各自分支中的更改。 注意：在解决冲突前，最好先备份当前的代码状态，以免不小心破坏代码库。另外，在处理冲突之前，可以通过运行 git diff 命令来查看冲突的源代码，以便更好地理解要解决的问题。 分支管理策略在 Git 中，常见的分支管理策略包括以下几个方面： 主分支：主分支通常是最稳定的分支，用于发布生产版本。在 Git 中，主分支通常是 master 分支或者 main 分支。 开发分支：开发分支通常从主分支派生而来，在其上进行新功能或修复错误的开发。在 Git 中，通常使用 develop 分支作为开发分支。 特性分支：特性分支是为了开发单独的功能而创建的分支。这些分支通常从开发分支派生而来，并在实现目标后被合并回开发分支。在 Git 中，通常使用 feature/ 分支命名约定来表示特性分支。 发布分支：发布分支是用于准备发布版本的分支，通常从主分支派生而来。这些分支应该包含与发布相关的所有更改，并且应该经过全面测试和审核后再合并回主分支。在 Git 中，通常使用 release/ 分支命名约定来表示发布分支。 热修复分支：热修复分支通常用于快速修复紧急问题，例如安全漏洞或崩溃。这些分支通常从主分支派生而来，并且只包含必要的更改。在 Git 中，通常使用 hotfix/ 分支命名约定来表示热修复分支。 通过采用合适的 Git 分支管理策略，可以帮助团队更好地组织和管理代码，提高团队的协作能力和生产效率。除了上述常见的分支管理策略，还可以根据团队的具体需求和工作流程定制适合自己的分支管理策略。 bug分支在 Git 中，通常使用 bug 分支用于修复代码中的错误或缺陷。当发现 bug 时，可以从当前开发分支（如 develop 分支）创建一个 bug 分支，在该分支上进行错误修复。修复完成后，可以将更改提交到 bug 分支，并将其合并回开发分支和主分支。 以下是一个典型的使用 Git bug 分支的流程： 从当前开发分支（如 develop 分支）创建一个新的 bug 分支： 12git checkout -b bug/fix-xxx 在 bug 分支上进行错误修复，包括必要的测试和代码审查。 提交更改并推送到远程仓库： 1234git add .git commit -m &quot;Fix xxx bug&quot;git push origin bug/fix-xxx 将 bug 分支合并回开发分支（如 develop 分支）： 123git checkout developgit merge --no-ff bug/fix-xxx 测试修复是否正确，如果一切正常，则将开发分支合并回主分支（如 master 分支）： 123git checkout mastergit merge --no-ff develop 通过使用 Git bug 分支，可以帮助团队更好地管理和修复代码中的错误和缺陷，同时保持代码库的稳定性和可靠性。 多人协作Git 是一个优秀的多人协作工具，以下是 Git 多人协作的一些最佳实践： 使用分支：使用分支可以帮助团队成员在不影响主分支的情况下进行开发和测试，避免代码冲突和错误。建议采用主分支、开发分支、特性分支、发布分支、热修复分支等分支管理策略。 提交规范：每次提交代码时应该附加有意义的提交信息，描述本次提交的更改内容和目的。建议采用语义化版本号和提交信息模板等规范，以便更好地记录和追踪代码变更历史。 定期合并：团队成员应该定期将自己的分支合并回主分支或者开发分支。这可以避免较大的代码冲突和错误，并且保持代码库的整洁和可维护性。 代码审查：通过代码审查可以确保代码的质量和一致性，并且可以识别和纠正潜在的问题和错误。建议采用 pull request 和 code review 等工具和流程，以便团队成员对彼此的代码进行审查和反馈。 团队协作：团队成员之间应该保持及时和有效的沟通，共享技术和经验，并尽可能避免个人行为和偏见对项目和团队产生不良影响。 通过采用上述最佳实践，可以帮助团队高效协作、保证代码质量和稳定性，并提高团队的生产力和创造力。 推送分支在 Git 中，推送分支指将本地的分支提交到远程仓库中，使得其他团队成员可以访问和获取该分支的代码。以下是在 Git 中推送分支的一些常用命令： 推送当前分支到远程仓库，并与远程分支关联： 1git push -u origin &lt;branch-name&gt; 推送当前分支到远程仓库，并与远程分支合并： 1git push origin &lt;branch-name&gt; 强制推送当前分支到远程仓库： 1git push -f origin &lt;branch-name&gt; 删除远程分支： 1234git push origin :&lt;branch-name&gt;或git push --delete origin &lt;branch-name&gt; 在推送分支时，通常会遇到冲突等问题。如果发生冲突，需要先解决冲突，然后再进行推送。 另外，在多人协作项目中，建议采用 pull request 和 code review 等工具和流程来对分支进行审查和反馈，以确保代码质量和稳定性。同时，也应该避免直接向主分支（如 master 分支）提交代码，而是应该使用分支管理策略来组织和管理代码。 抓取分支在 Git 中，抓取分支指从远程仓库拉取最新的代码和分支信息，并在本地创建相应的分支。以下是在 Git 中抓取分支的一些常用命令： 拉取所有远程分支并更新本地分支： 1git fetch --all 拉取一个特定的远程分支到本地： 12git fetch origin &lt;branch-name&gt; 在本地创建基于远程分支的新分支： 12git checkout -b &lt;new-branch-name&gt; origin/&lt;remote-branch-name&gt; 拉取远程分支并自动与本地分支关联： 1234git checkout --track origin/&lt;remote-branch-name&gt;或git checkout -t origin/&lt;remote-branch-name&gt; 抓取分支时，需要注意避免覆盖当前分支中未提交的更改。如果本地分支和远程分支存在冲突，需要解决冲突后才能将更改合并到本地分支中。 通过抓取分支可以使得开发者获取最新的代码和分支信息，在本地进行代码修改和测试，并将更改推送回远程仓库以进行协作开发。 git可视化工具Git 可视化工具可以帮助开发者更直观地查看和管理代码版本控制历史，以下是几个常用的 Git 可视化工具： GitKraken： GitKraken 是一款简单易用的 Git 可视化工具，支持 Windows、Mac 和 Linux 等多个平台。它提供了强大的图形界面，包括代码历史记录、分支管理、合并冲突解决等功能。 Sourcetree：Sourcetree 是由 Atlassian 公司开发的一款免费 Git 可视化工具，支持 Windows 和 Mac 平台。它提供了友好的用户界面，可以轻松地进行代码提交、分支管理和冲突解决等操作。 GitHub Desktop：GitHub Desktop 是 GitHub 公司出品的一款免费 Git 可视化工具，支持 Windows 和 Mac 平台。它提供了清晰明了的界面，可视化显示代码历史记录、分支管理、拉取请求（pull request）等功能，以及与 GitHub 网站的集成支持。 Git GUI：Git GUI 是 Git 官方提供的一个图形化界面的工具，支持 Windows、Mac 和 Linux 等多个平台。它虽然不如前面提到的工具那样友好易用，但是对于习惯命令行操作的开发者来说，Git GUI 可以提供便捷的图形化界面。 使用 Git 可视化工具可以帮助开发者更直观地理解和管理 Git 中的代码版本控制历史，提高协作效率和代码质量。","tags":["git"]},{"title":"vim快速入门教程","path":"/2025/05/28/vim快速入门教程/","content":"转载自: https://www.jianshu.com/p/af14f639dadb 一、移动光标字符级 命令 功能 h 向 左 移动一个字符单位 l 向 右 移动一个字符单位 j 向 下 移动一个字符单位 k 向 上 移动一个字符单位 单词级 命令 功能 w/W 向 右 移动到下一单词开头 e/E 向 右 移动到单词结尾 b/B 向 左 移动到单词开头 PS：所谓“单词”，是按照英文的书写和使用习惯来定义的。用在中文上，一般就会以标点符号和空格作为“单词”的界限。所以常常是一句话一句话地跳转。 块级 命令 功能 0 移动到当前行的第一个字符 ^ 移动到当前行第一个非空白字符 $ 移动到当前行行尾 + 移动到下一行的首字母 - 移动到上一行的首字母 gg 移动到文档第一行 G 移动到文档最后一行 H 移动到当前屏幕的第一行 M 移动到当前屏幕的中间一行 L 移动到当前屏幕的最后一行 :&lt;n&gt; 或 &lt;n&gt;gg 跳转到第 n 行 :+&lt;n&gt; 或 &lt;n&gt;j 从当前位置向下跳 n 行 :-&lt;n&gt; 或 &lt;n&gt;k 从当前位置向上跳 n 行 滚动屏幕 命令 功能 Ctrl-d 向下滚动半页 Ctrl-u 向上滚动半页 Ctrl-f 向下移滚动一页 Ctrl-b 向上滚动一页 z&lt;Enter&gt; 将当前行滚动到屏幕顶部 z. 将当前行滚动到屏幕中间 z- 将当前行滚动到屏幕底部 PS：绝大部分命令前都可以加一个数字 n ，通常表示对其后的命令连续执行 n 次。所以 3j 可以表示向下移动 3 个字符单位（即下移 3 行）。3l 表示向右移动 3 个字符单位。相当于连续执行了 l 命令 3 次。而 9z. 则表示光标移动到第 9 行的同时，滚动屏幕并使得第 9 行位于屏幕中间。（这个 9 的含义不同于 3l 命令中的 3） 前面带冒号的命令（如 :+&lt;n&gt;，命令内容会显示在底部）是需要手动输入回车后才执行的。而不带冒号的命令（如 &lt;n&gt;gg）需要在键盘上不间断地按下，之后命令会自动执行。 二、文档操作 插入 命令 功能 i 当前字符前插入 a 当前字符后插入 I 行首插入 A 行尾插入 o 在下一行插入 O 在上一行插入 PS：以上命令会使 vim 进入 insert 模式（即编辑模式），此时输入的任何命令都会作为字符插入到文档中。按 esc 键可退出 insert 模式。 删除 命令 功能 x 删除当前字符（等于 insert 模式下的 Delete） X 删除前一个字符（等于 insert 模式下的 Backspace） dd 删除当前行 d&lt;x&gt; 删除指定内容 D 删除当前光标位置到行尾的所有内容。等于 d$ cc 替换整行内容。即将整行内容删除并进入 insert 模式 c&lt;x&gt; 删除指定内容后，进入 insert 模式。相当于 d&lt;x&gt;a C 替换当前光标位置到行尾的所有内容。等于 c$ &lt;x&gt; 部分用于指定删除的范围。如 j 表示将光标向下移动一个字符单位（即下移一行），则 dj 表示删除当前行和下一行的内容。G 表示将光标移动到文档末尾，则在光标定位在文档首行时，使用 dG 命令可以清空整个文档的内容。 PS：使用以上命令删除的内容会自动保存到 vim 的剪贴板中，即所谓“删除”实际上是“剪切”，使用 p 命令即可粘贴删除的内容。而且该剪贴板限于 vim 内部，不是系统剪贴板。 复制与粘贴 命令 功能 yy 复制当前内容到 vim 剪贴板 y&lt;x&gt; 复制指定内容到 vim 剪贴板 p 在当前位置后粘贴 P 在当前位置前粘贴 J 将当前行与下一行内容合并为一行 y&lt;x&gt; 命令中的 &lt;x&gt; 同样用于指定复制的范围。如 4j 表示将光标下移 4 行，则 y4j 表示将当前行及其后 4 行内容复制到 vim 剪贴板。8gg 表示将光标定位至第 8 行，则 y8gg 表示复制当前行到第 8 行的所有内容。当 vim 剪贴板中的内容为整行时，则粘贴命令（p/P）执行时，也会变成在当前行的前（后）一行粘贴。 查找行内查找 命令 功能 f&lt;x&gt; 当前行向行尾方向查找并定位到字符 x F&lt;x&gt; 当前行向行首方向查找并定位到字符 x t&lt;x&gt; 当前行向行尾方向查找并定位到字符 x 之前 T&lt;x&gt; 当前行向行首方向查找并定位到字符 x 之后 ; 继续向当前方向查找下一个字符 , 向当前方向的相反方向查找下一个字符 文档内查找 命令 功能 * 向后查找光标当前所在单词 # 向前查找光标当前所在单词 /&lt;pattern&gt; 向后查找指定字符串或模式 ?&lt;pattern&gt; 向前查找指定字符串或模式 n 继续查找下一个（依照原方向继续查找） N 继续查找上一个（依照原方向进行反向查找） PS：vim 中可使用 % 对括号 ()[]&#123;&#125; 进行匹配查找，当光标位于其中一个符合上时，按下 % 会跳转到与之匹配的另外一个符合上。 替换 命令 功能 r&lt;x&gt; 将当前字符替换为字符 x s 删除当前字符并进入 insert 模式 R 进入 replace 模式，逐字对当前字符进行替换操作，可以移动光标定位需要替换的字符。直到按下 ESC 键退出该模式 ~ 对当前字符进行大小写切换（即大写转小写，小写转大写） gu&lt;x&gt; 将指定的文本转换为小写 gU&lt;x&gt; 将指定的文本转换为大写 g~&lt;x&gt; 将指定文本进行大小写切换 :&lt;n1&gt;,&lt;n2&gt;s/&lt;pattern&gt;/&lt;replace&gt; 以某个模式（pattern）检索整个文档，并将第 n1 行到第 n2 行中的匹配项替换为指定内容（replace） :%s/&lt;pattern&gt;/&lt;replace&gt; 以某个模式（pattern）检索整个文档并将匹配项替换为指定内容（replace）。等同于 :1,$s/&lt;pattern&gt;/&lt;replace&gt; PS：:%s/&lt;pattern&gt;/&lt;replace&gt; 命令中的 &lt;pattern&gt; 可以是正则表达式，且该命令只替换每行中的第一个匹配项。如需要全局匹配，可以使用 :%s/&lt;pattern&gt;/&lt;replace&gt;/g 命令 撤销、重做 命令 功能 . 重复执行上一次的命令 u 撤销 U 撤销对当前行的所有操作 Ctrl-r 重做 打开、关闭文档 命令 功能 :e &lt;filename&gt; 打开名为 filename 的文件，如文件不存在则创建 :Ex 在 vim 中打开目录树，光标选定后回车打开对应文件（- 命令进入上级目录） :w 保存当前文件 :wa 保存全部文件 :wq 或 ZZ 保存文件并退出 vim :q! 或 ZQ 强制退出 vim ，不保存文件 :r &lt;filename&gt; 读入另一个文档（filename）的数据，并将其内容附加到当前文档光标所在行的后面 :saveas &lt;new_filename&gt; 文件另存为 :w &lt;new_name&gt; 另存为一份名为 new_name 的副本并继续编辑原文件 :&lt;n1&gt;,&lt;n2&gt;w &lt;new_name&gt; 将 n1 行到 n2 行的所有内容保存到名为 new_name 的新文档中 buffer缓冲区Buffer（缓冲区）指 vim 中打开的文件所占的内存空间，当未写入磁盘时，所有的修改都发生在内存中。vim 打开过的每个文件都会放到一个 Buffer 中，可以随意切换已打开的 Buffer。 命令 功能 :ls 或 :buffers 查看 buffer 列表 :bn 打开缓冲区中下一个文件 :bp 打开缓冲区中上一个文件 :b&lt;n&gt; 打开缓冲区中第 n 个文件 :bdelete&lt;n&gt; 删除需要关闭的缓冲区文件 三、其他技巧缩进 &gt;&gt; 向右缩进当前行 &lt;&lt; 向左缩进当前行 4&gt;&gt; 向右缩进当前行的同时，缩进当前行下面的 3 行内容 &gt;G 向右缩进当前行到文档末尾的所有内容 自动排版 == 自动排版当前行 gg=G 自动排版整个文档 &lt;n&gt;== 对从当前行开始的 n 行进行自动排版 =&lt;n&gt;j 对当前行以及下面的 n 行进行自动排版 执行 shell 命令:!&lt;command&gt; 可以执行相应的 shell 命令，命令执行完成后按 Enter 回到 vim 界面。如使用 :1,9!sort 命令可以将当前文件中第 1 行到第 9 行的内容重新排序。:r !&lt;command&gt; 可以将相应 shell 命令执行后的输出读取到当前文件中。如使用 :r !date 命令可以将当前详细的时间日期插入到 vim 编辑的文件中。 四、分屏与标签页 窗口分屏 分屏方式 :split 或 :sp 或 Ctrl-w s ：上下分屏 :vsplit 或 :vs 或 Ctrl-w v ：左右分屏 :diffsplit 或 :diffs ：diff 模式打开一个分屏，后面可以加 &lt;filename&gt; 窗口跳转 Ctrl-w w ：激活下一个窗口 Ctrl-w j ：激活下方窗口 Ctrl-w k ：激活上方窗口 Ctrl-w h ：激活左侧窗口 Ctrl-w l ：激活右侧窗口 屏幕缩放 Ctrl-w = ：平均窗口尺寸 Ctrl-w + ：增加当前窗口高度 Ctrl-w - ：缩减窗口高度 Ctrl-w _ ：最大窗口高度 Ctrl-w &gt; ：增加窗口宽度 Ctrl-w &lt; ：缩减窗口宽度 Ctrl-w | ：最大窗口宽度 标签页 创建标签页:tabnew 或 :tabedit 或 :tabe ：打开新标签页该命令包括上面的分屏命令（:sp 或 :vs 等）后面都可以跟 &lt;filename&gt; 选项，用以在新标签页（或窗口）中打开指定文件 切换标签页 gt 或 :tabnext 或 :tabn ：切换到下一个标签页（最后一个会循环到第一个） gT 或 :tabprevious 或 :tabp ：切换到上一个标签页 :tabrewind 或 :tabr 或 :tabfir ：切换到第一个标签页 :tablast 或 :tabl ：切换到最后一个标签页 关闭标签页 :tabclose 或 :tabc ：关闭当前标签页 :-tabc ：关闭上一个标签页 :+tabc ：关闭下一个标签页 :tabonly 或 :tabo ：关闭其他标签页 附录：vim 模式介绍大致上 vim 分为三种模式，分别是命令模式（Command mode），编辑模式（Insert mode）和底线命令模式（Last line mode）。 1. 命令模式vim 启动即进入命令模式。此时敲击键盘动作会被识别为命令，而不是作为字符插入到文档中。如： i 切换到输入模式（在当前字符前插入） : 切换到底线命令模式，此时输入的命令显示在最底下一行， : 符号后面命令模式下只有一些最基本的命令，而底线命令模式下拥有更多的命令。 2. 编辑模式在命令模式下键入 i （或 a、e 等）即进入编辑模式在编辑模式下，可以像在记事本中那样，使用键盘输入或修改文档内容。注意编辑完成时，可使用 ESC 键退出编辑模式，回到命令模式。 3. 底线命令模式在命令模式下按下 : 即进入底线命令模式该模式下可以输入单个或多个字符的命令，以完成比命令模式下更复杂的操作（如 :wq 保存文件并退出）按 ESC 键可随时退出底线命令模式。 参考书籍vimtutorLearning The Vi And Vim Editors, 7th Edition","tags":["vim","linux"]},{"title":"IPv6地址格式详解","path":"/2025/04/21/IPv6地址格式详解/","content":"IPV6地址格式详解 转载自: https://www.cnblogs.com/cyrusxx/p/12824147.html ＜IPV6地址的表示方法＞IPv4 点分十进制 32bitIPv6 冒号分十六进制 128bit 0000:0000:0000:0000:0000:0000:0000:0000&#x3D;&gt;::0000:0000:0000:0000:0000:0000:0000:0001&#x3D;&gt;0:0:0:0:0:0:0:1&#x3D;&gt;::12001:0000:0000:1234:0000:0000:0567:00ff&#x3D;&gt;2001::1234:0:0:567:ff 只能有一个::fe80:0000:0000:0000:0000:0000:0000:0009&#x3D;&gt;fe80::9 内嵌IPV4地址的IPV6地址1、IPV4兼容的IPV6地址–用于在IPV4网络上建立自动隧道，以传输IPV6数据包。 其中高96bit设为0，后面跟32bit的IPV4地址 0000:0000:0000:0000:0000:0000:206.123.31.2 0000:0000:0000:0000:0000:0000:ce7b:1f01 由于这种机制不太好，现在已经不再使用，转而采用更好的过渡机制2、映射IPV4的IPV6地址–仅用于拥有IPV4和IPV6双协议栈节点的本地范围 其中高80bit设为0,后16bit设为1，再跟IPV4地址 0000:0000:0000:0000:0000:ffff:206.123.31.2 0000:0000:0000:0000:0000:ffff:ce7b:1f01 URL的IPV6地址表示 为了区分IPV6地址中的冒号和端口号前的冒号，要把IPV6地址用[]括起来 www.example.net:8080/index.html https:\\[2001:410:0:1:250:fcee:e450:33ab\\]:8443/abc.html IPV6中掩码的表示：在IPV6中掩码只能使用CIDR表示法2001:410:0:1::45ff&#x2F;1282001:410::1&#x2F;64注意：在IPV6中没有广播地址和网络号保留地址 ＜IPV6的地址类型＞单播–Unicast : one to one·单播地址用于一对一的连接·IPv6单播地址有以下六种类型： －Unspecified Address 0:0:0:0:0:0:0:0&#x2F;128 &#x3D;&gt; ::&#x2F;128 －Loopback Address 0:0:0:0:0:0:0:1&#x2F;128 &#x3D;&gt; ::1&#x2F;128 －IPv4 Compatible Address ::192.168.30.1 &#x3D;&gt; ::C0A8:1E01 －Link Local Address FE80::&#x2F;10(前10位以FE80开头) －Site Local Address (Private) FEC0::&#x2F;10 -Aggregate Global Unicast Address 2xxx:xxxxx&#x2F;3 - 3FFF: :FFFF 2001::&#x2F;16 IPV6因特网地址 2002::&#x2F;16 6to4过渡地址 以下是一些单播地址的具体说明：本地链路地址：link-local address当在一个节点启用IPV6，启动时节点的每个接口自动生成一个link-local address其前缀64位为标准指定的，其后64位按EUI-64格式来构造注意：在本链路上，路由表中看到的下一跳都是对端的Link Local地址,不是公网IP地址 前缀：FE80::&#x2F;10范围：只能在本地链路使用，不能在子网间路由 为何需要link-local–在一个接口可以配置很多IPv6地址，所以学习路由就有可能出现很多下一跳。所以出现Link Local地址唯一标识一个节点。在本地链路看到下一跳都是对端的Link Local地址。在网络重新编址过程中，节点和路由器的Link Local地址不会发生变化，可以很容易地做一个修改，不用担心网络不可达。 EUI-64的构造规则–根据接口的MAC地址再加上固定的前缀来生成一个IPV6的link-local地址 例如：MAC地址–0010.7b80.032f以此为例来生成一个IPV6地址1、将MAC地址从中间分为两段，0010.7b和80.032f2、在两段的中间加入ff.fe–0010.7b.ff.fe.80.032f3、将第7个比特位转换（0转1,1转0）–0210.7bff.fe80.32f4、加上前缀–FE80::0210:7BFF:FE80:032F这是link-local地址再生成被请求节点的组播地址–FF02::1:FF80:32F直接将后24位移下来就可 R1（config-if）#ipv6 address FE80:0:0:0:0123:0456:0789:0abc link-local 手工指定link-local地址 本地站点地址：site-local addressIPV6的私网地址，就像IPV4中的私网保留地址一样只占用到整个IPV6地址空间的0.1% 前缀：FEC0::&#x2F;10 其后的54比特用于子网ID 最后64位用于主机ID范围：只能在本站点内使用，不能在公网上使用 例如：在本地分配十个子网1、FEC0:0:0:0001::&#x2F;642、FEC0:0:0:0002::&#x2F;643、FEC0:0:0:0003::&#x2F;6410、FEC0:0:0:000A::&#x2F;64 本地站点地址被设计用于永远不会与全球IPV6因特网进行通信的设备，比如：打印机、内部网服务器、网络交换机等 可聚合全球单播地址Aggregate global unicast address 由IANA分配的可在全球路由的公网IP地址 目前已分配的前缀：2000::&#x2F;3 占用了12.5%的IPV6地址空间2000:0000:0000:0000:0000:0000:0000:0000–3FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF 这个前缀中总共包含8192个&#x2F;16的前缀目前实际用于IPV6因特网运作的前缀：2001::&#x2F;162002::&#x2F;16 为使用6-TO-4过渡机制的节点保留3ffe::&#x2F;16 用于6bone测试目的的前缀 未指定地址Unspecified address 形式：0:0:0:0:0:0:0:0 表示地址未指定，或者在写默认路由时代表所有路由 回环地址Loopack address 形式：0:0:0:0:0:0:0:1同IPV4中127.0.0.1地址的含义一样，表示节点自已 组播地址Multicast在IPV6中没有广播，用组播来代替 前缀：FF00::&#x2F;8 占用了0.38%的IPV6地址空间 1111 1111 4bit 4bit ｜→固定值←｜|→标志←| |→范围←| 标志位为0000表示是永久保留的组播地址，分配给各种技术使用标志位为0001表示是用户可自定义的临时组播地址 范围段定义了组播地址的范围，其定义如下： 二进制 十六进制 范围类型0001 1 本地接口范围0010 2 本地链路范围0011 3 本地子网范围 0100 4 本地管理范围0101 5 本地站点范围1000 8 组织机构范围1110 E 全球范围 下面是一些组播指定地址：FF02::1 all nodes 在本地链路范围的所有节点FF02::2 all routers 在本地链路范围的所有路由器FF02::5 all ospf routersFF02::9 all rip routers 所有运行RIP的路由器FF02::A all eigrp routers 所有运行eigrp的路由器FF05::2 在一个站点范围内的所有路由器 被请求节点的组播地址solicited-node multicast address–重要的东东一种特殊的组播地址，对于节点或路由器的接口上配置的每个单播和任意播地址，都会自动生成一个对应的被请求节点组播地址。注意link-local address也会生成一个被请求节点的组播地址。 工作范围：只在本地链路上有效特点 ：1 在本地链路上，被请求接点的组播地址中只包含一个用户2 只要知道一个接点的ipv6地址，就能计算出他的被请求节点的组播地址作用：1、在IPV6中，没有ARP。ICMP代替了ARP的功能，被请求节点的组播地址被节点用来获得相同本地链路上邻居节点的链路层地址 2、用于重复地址检测DAD，在使用无状态自动配置将某个地址配置为自已的IPV6地址之前，节点利用DAD验证在其本地链路上该地址是否已经被使用。 前缀：FF02:0000:0000:0000:0000:0001:FFxx:xxxx&#x2F;104 FF02::1:FFxx:xxxx&#x2F;104 如何产生：被请求节点组播地址的前104位固定，将IP地址的后24位移下来填充到后面就可以了 例如：IPv6—2001::1234:5678&#x2F;64 被请求节点组播地址—FF02::1:FF34:5678&#x2F;104 其中FF02::1:FF为固定部分，共104位 组播IP地址到MAC地址的映射： 映射规则：组播MAC地址的前16位固定为0x3333，将组播IPV6地址的后32位直接映射到组播MAC地址的后32位就可以了。例：IPV6地址为–FF12::1234:5678&#x2F;64 对应的组播MAC地址为–3333:1234:5678 0x3333为固定前缀 例：所有节点的组播地址：FF02::0001 对应的组播MAC地址：3333:0000:0001 任意播地址Anycast address应用在one-to-nearest（一到近）模式 组播的接受对象是一组成员,是个群体.任意播是多个设备共享一个地址.分配IPv6单播(unicast)地址给拥有相同功用的一些设备.发送方发送一个以任意播为目标地址的包,当路由器接受到这个包以后,就转发给具有这个地址的离它最近的设备.单播地址用来分配任意播地址.对于那些没有配备任意播的的地址就是单播地址;但是当一个单播地址分配给不止一个接口的时候,单播地址就成了任意播地址。 例如：Mobile方面的特性，移动设备漫游到其他区域，不必接入原始的接入点，只需要找到最近的即可。 必须的IPV6地址： 一旦节点启用IPV6，那么接口就会自动生成下列地址1、本地链路地址2、回环地址3、所有节点多播地址FF01::1和FF02::1 如果接口配了一个IPV6的单播地址，还会产生被请求节点的组播地址 EUI-64格式：在IPV6中，无状态自动配置机制使用EUI-64格式来自动配置IPV6地址所谓无状态自动配置是指在网络中没有DHCP服务器的情况下，允许节点自行配置IPV6地址的机制。工作原理：自动将48bit的以太网MAC地址扩展成64bit，再挂在一个64bit的前缀后面，组成一个IPV6地址MAC地址是48位的，从中间断开各24位，在中间加上FF FE，再把加上后地址的第7位0改成1，如果是1则改成0 一、将48位的MAC地址从中间分开，插入一个固定数值FFFE 0050:3EE4:4C00–&gt;0050:3EFF:FEE4:4C00 二、将第7个比特位反转，如果原来是0，就变为1,如果原来是1，就变为0 0050:3EFF:FEE4:4C00–&gt;0250:3EFF:FEE4:4C00 反转的原因： 在MAC地址中，第7比特为1表示本地管理，为0表示全球管理 在EUI-64格式中，第7位为1表示全球惟一，为0表示本地唯一","tags":["Ipv6"],"categories":["network"]},{"title":"一起聊聊IPv4/IPv6和局域网","path":"/2025/04/21/一起聊聊IPv4-IPv6和局域网/","content":"转载自: https://www.cnblogs.com/poloyy/p/14926631.html 背景 谁都知道 IP 地址是干嘛的，但是它出现的前因后果你真的知道吗？ 我觉得很有必要重新复习下计算机网络基础知识，实在太太太重要了 本篇文章素材均来自：https://www.bilibili.com/video/BV1DD4y127r4；这个 UP 感觉还是很不错 by the way：有时候学习一个知识点，官网的确是最准确的， 但一定不是通俗易懂的，借助大神做的一些动态图和类比场景，能更快吸收一个知识点 最佳学习方式：看一遍官方，看一遍别人做的学习视频，再看一遍手动记录干货，形成自己的知识体系 为什么会出现 IP 地址假设只有一台电脑 所有数据就会存储在这台电脑的硬盘上，和其他电脑本身不存在任何干系 但一台电脑能做的事情是非常少的，很可能会出现多台电脑协同工作 假设有两台电脑 两台电脑协同工作，那肯定会出现数据交互的需求，那就需要用中间介质（比如 U 盘）来交换 这种方式既不是数据实时传输，也非常耗时耗力 线缆（网线）的出现两台电脑之间可以通过网线来实时传输数据 但假设有很多台电脑，那每两台电脑间都需要一条网线来连接，随着设备数量上升，需要的接口数量和线材数量也会越来越多，这是十分不合理的 交换机的出现 电脑和电脑之间的连接不再是点对点连接了 而是全部都接入交换机，由交换机去分发来自不同设备的数据 交换机的类型 很多个接口的常规网络交换机 服务器 家里的路由器 交换机详细介绍等后面的文章吧 非点对点连接的问题 点对点连接时，两台电脑交互数据的是通过对应接口的，所以数据一定会传送到目标主机上 但是接入交换机之后，就不清楚数据发送给哪个目标主机了 类比：网购发货，没有填清楚收件人的地址，所以无法精准送货 数字虚拟地址 为了解决上述非点对点连接的问题，诞生了数字虚拟地址 电脑发送数据的时候，带上这个数字虚拟地址，就能知道目标主机是谁了 栗子：182.168.0.1 主机要发送数据给 192.168.0.3 主机，就在数据的抬头（包头）上加上 192.168.0.1，这样数据到达交换机后就能准确发送给对应目标主机了 说明 此处采用的交换机是三层交换机，具有 DHCP 分配 IP 的功能 MAC 地址为物理层面设备识别 数据传输依赖 TCP&#x2F;UDP IP 地址来了 其实数字虚拟地址就是 IP 地址 类比：网购发货的时候，发送的物品就是数据，收件人地址可以理解为 IP 地址 局域网每个电脑都拥有自己的 IP 以后，加上连接的交换机，就能组成一个小的可以用来交换数据的网络，这就是局域网 新加入一个局域网需要把两个局域网的交换机连接起来，组成一个更大的局域网 随着时间的推移，可能需要连接的局域网也会越来越大，那么局域网之间又会通过一个新的交换机来连接 广域网 上面有说到，随着局域网越来越多，这个网络也会变得越来越大，用户只需要连接一个交互机可能就能访问世界上绝大多数的设备，这就是广域网 广域网就是一个设备数量超级庞大的局域网 想要把世界各地的设备连接起来并不容易 需要在多个重要城市架设骨干服务器，还要在不同区域布置分支服务器，然后让大家接入 这需要大量的资金成本、后期维护 做这种吃力不讨好活的就是 ISP（互联网服务提供商），在中国有联通、电信、移动 正需要资金成本和维护成本，所以你的手机流量和家用宽带都是计费的 IPV 4 由 32 位二进制数构成 理论上，可以提供 2^32 约 42.28 亿 个地址 转成十进制为了方便记忆和输入，每 8 个二进制数划分为一组，然后转换为十进制数，变成常用的 4 个 0-255 数字 IP 地址的分类一些地址有特殊的用途，所以被保留下来不允许被大众使用，最后可能真正可用的 IP 地址只有 36.74 亿个 全球 IPV4 地址不够用现在全球有75亿个人，假设只有四分之一的人用互联网，那么也有 18 亿人 但每个人的设备数量可能有多个，比如手机+IPAD+电脑，如果都想要独立的 IP 地址，那么 IPV4 很明显不够用 IPV4 已经枯竭 2011 年底，打包分配的 IPV4 地址已经枯竭了 2020 年底，亚太互联网信息中心将发布不出来一个新的地址 除非有人返还旧的地址 NAT 网络地址转换为了解决 IPV4 地址枯竭的问题，引入了 NAT 地址转换 上图 五台电脑接入一个路由器 路由器接入广域网的 IP 是 6.6.6.6 对于家用来说，路由器由于是接入广域网并执行 NAT 的，所以路由器就是网关 传输场景，引入 NAT 假设电脑 A 需要访问外部的 8.8.8.8 设备 那么就会将数据包发送给路由器 路由器发现这个数据包是要发送给 8.8.8.8 的，就会将 IP 映射成自己的 IP 6.6.6.6，并记录成映射表 最后，8.8.8.8 设备接收到的数据包的 IP 是 6.6.6.6 这样五台电脑发送出去的数据包，都能通过路由器转换为 6.6.6.6，以这个 IP 去传输数据 就能实现五台设备共用一个 IP 接收方也可以作为网关这样它下面就会连接了很多台设备，那它们也可以共用 8.8.8.8 这个 IP 存在问题 左侧五台设备都是通过 6.6.6.6 来发送数据包的，但是右侧接收方并不知道发送过来的数据包应该给哪台设备接收 而 8.8.8.8 的下行数据发送到 6.6.6.6 之后，也不知道给五台设备中的哪一台来接收 端口映射为了解决上面存在的问题，引入了端口映射 具体表现方式 其实就是在 IP 后面加端口 6.6.6.6:8080 网关就会以不同的端口去和外网交互，然后把这些端口映射给局域网内的各个设备 传输数据包的时候，除了 IP 地址需要映射为网关 IP 之外，还需要将端口映射为网关的端口 这样就能实现共用一个 IP 还能精准传送数据了（解决上面存在的问题），以实现 PAT 多对一映射了 其实就是因为 NAT 和端口映射的存在，才让 IPV4 即使在不够用的情况下还能坚持这么久 公有 IP 和私有 IP 前面有说到 A、B、C、D、E 五台设备共同连接一个路由器，那么这五个设备就是寄宿在 6.6.6.6 网关下的私有 IP 网关所拥有的的可以直接用来在广域网上交互数据的 6.6.6.6 就是公网IP 类比的栗子 比如你居住在一个名叫月亮湾的小区，具体地址是15号楼二单元101 假设全球只有一个小区叫这个名，那么只要别人提起月亮湾就知道是哪个月亮湾了，这种能直接通过地址访问，可以拿到大的层面上直接使用的地址就是公网 IP 而小区内部其实就是局域网，你只要在小区内说是15号楼二单元101的，别人就知道你在哪 假设隔壁小区也有15号楼二单元101，隔壁的隔壁小区也有15号楼二单元101，寄快递的时候只写15号楼二单元101不写月亮湾，那么快递肯定不知道寄去哪里 像这种只能在小区内（局域网内）使用的 IP 就是私有 IP，它只有连同一个局域网的其他设备才会知道 IPV 6 能支持 3.4 * 10^ 38 个 IPV6 地址，这应该是多少亿亿亿个了吧…给每个生物分配一个都够用了 数字0-9，大写字母A-F ipv4 和 ipv6 是两个完全不同的两个协议 它们之间不能直接互通，必须要借助其他的设备去做转换和映射 导致在短时间内，IPV6 替换 IPV4 是很困难的 会持续更新知识点 背景 为什么会出现 IP 地址 假设只有一台电脑 假设有两台电脑 线缆（网线）的出现 交换机的出现 交换机的类型 非点对点连接的问题 数字虚拟地址 说明 IP 地址来了 局域网 新加入一个局域网 广域网 IPV 4 转成十进制 IP 地址的分类 全球 IPV4 地址不够用 IPV4 已经枯竭 NAT 网络地址转换 上图 传输场景，引入 NAT 接收方也可以作为网关 存在问题 端口映射 具体表现方式 公有 IP 和私有 IP 类比的栗子 IPV 6 ipv4 和 ipv6 是两个完全不同的两个协议","tags":["network","IPv6"],"categories":["network"]},{"title":"浅说虚拟列表实现原理","path":"/2025/04/21/浅说虚拟列表实现原理/","content":"转载自: https://segmentfault.com/a/1190000016734597 在前端性能优化的众多方案中，虚拟列表可以说是一个既经典又常见的话题。虽然很多开发者对它有所耳闻，但当被问到具体实现原理时，往往会觉得无从下手。今天，让我们用最直观的方式来一探虚拟列表的究竟。 虚拟列表的实现有多种方案，本文以 react-virtual-list 组件为基础进行分析。原文链接：https://github.com/dwqs/blog/… 什么是虚拟列表？想象一下你正在刷抖音：屏幕上虽然只显示一个视频，但你知道下面还有数不清的内容在等着你。虚拟列表就是这样一个聪明的技术 —— 它只把你眼前能看到的内容渲染出来，而不是一股脑儿地把所有内容都显示出来。这就像是魔术师的手法，让你感觉整个列表都在那里，实际上却只有一小部分在起作用。 要理解虚拟列表,我们需要先搞清楚三个关键概念: 1. 滚动容器这是承载内容的”视口”(Viewport),可以理解为一个固定尺寸的框。它可以是浏览器窗口,也可以是页面中某个固定高度的div元素。就像是你在看一卷长画轴,滚动容器就是那个让你能通过它观看画作的框框。 2. 可滚动区域这是内容的真实区域,决定了滚动条的高度。继续用画轴的比喻 —— 如果你有一卷100米长的画轴,那么可滚动区域就是这100米。在虚拟列表中,如果你有1000条数据,每条高度50像素,那么可滚动区域的高度就是50000像素。这个高度是虚拟的,但对用户来说,滚动体验和真实渲染是完全一致的。 3. 可视区域这是用户通过滚动容器实际能看到的内容区域。还是用画轴的例子 —— 虽然画轴有100米长,但你通过框框一次只能看到20厘米的内容。在虚拟列表中,如果滚动容器高度是400像素,那么可视区域一次可能只能显示8-10条数据。 这三者的关系可以用一个简单的类比来理解: 滚动容器就像是火车车窗 可滚动区域就像是火车外的整个风景 可视区域就是你透过车窗在某一时刻看到的那部分风景 虚拟列表的核心就是只渲染可视区域的内容,而不是整个可滚动区域的内容。当用户滚动时,我们动态计算并更新可视区域中应该显示的内容,从而大大减少了DOM节点的数量,提升了页面性能。 实现虚拟列表的具体步骤如下： 根据滚动条的位置，计算可见区域该展示长列表中哪部分的数据，得到这部分可视数据的 startIndex 根据可见区域的高度，计算可容纳的列表项个数，结合 startIndex 得到可视数据的 endIndex 根据 startIndex 和 endIndex 提取可视数据，并渲染可视数据列表 因为滚动容器已向上滚动scrollTop, 所以可视数据列表需要paddingTop，top偏移同样的距离startOffset才能显示在可视区域 由于需要用可视数据列表的上下padding来模拟完整列表的真实高度，得到真实的滚动条，所以还需要计算 endIndex 对应的数据相对于可滚动区域最底部的偏移位置 endOffset，并设置可视数据列表paddingBottom 建议参考下图理解一下上面的步骤： 元素 L 代指当前列表中的最后一个元素 从上图可以看出，startOffset 和 endOffset 会撑开容器元素的内容高度，让其可持续的滚动；此外，还能保持滚动条处于一个正确的位置。 为什么需要虚拟列表？虚拟列表是对长列表的一种优化方案。在前端开发中，会碰到一些不能使用分页方式来加载列表数据的业务场景，我们称这种列表叫做长列表。比如，在一些外汇交易系统中，前端会准实时的展示用户的持仓情况(收益、亏损、手数等)，此时对于用户的持仓列表一般是不能分页的。 在本篇文章中，我们把长列表定义成数据长度大于 999，并且不能使用分页的形式来展示的列表。 如果对长列表不作优化，完整地渲染一个长列表，到底需要多长时间呢？接下来会写一个简单的 demo 来测试以下。 本文 demo 的测试环境：Macbook Pro(Core i7 2.2G, 16G), Chrome 69，React 16.4.1 在 demo 中，我们先测一下浏览器渲染 10000 个简单的节点需要多长时间： 12345678910111213141516171819202122232425262728293031323334353637383940import React from &#x27;react&#x27;const count = 10000function createMarkup (doms) &#123; return doms.length ? &#123; __html: doms.join(&#x27; &#x27;) &#125; : &#123; __html: &#x27;&#x27; &#125;&#125;export default class DOM extends React.Component &#123; constructor (props) &#123; super(props) this.state = &#123; simpleDOMs: [] &#125; this.onCreateSimpleDOMs = this.onCreateSimpleDOMs.bind(this) &#125; onCreateSimpleDOMs () &#123; const array = [] for (var i = 0; i &lt; count; i++) &#123; array.push(&#x27;&lt;div&gt;&#x27; + i + &#x27;&lt;/div&gt;&#x27;) &#125; this.setState(&#123; simpleDOMs: array &#125;) &#125; render () &#123; return ( &lt;div style=&#123;&#123; marginLeft: &#x27;10px&#x27; &#125;&#125;&gt; &lt;h3&gt;Creat large of DOMs：&lt;/h3&gt; &lt;button onClick=&#123;this.onCreateSimpleDOMs&#125;&gt;Create Simple DOMs&lt;/button&gt; &lt;div dangerouslySetInnerHTML=&#123;createMarkup(this.state.simpleDOMs)&#125; /&gt; &lt;/div&gt; ) &#125;&#125; 当点击 Button 时，会调用 onCreateSimpleDOMs 创建 10000 个简单节点。从 Chrome 的 Performance 标签页看到的数据如下： 从上图可以看到，从 Event Click 到 Paint，总共用了大约 693ms，渲染时的主要时间消耗情况如下： Recalculate Style：40.80ms Layout：518.55ms Update Layer Tree：11.84ms 在 Recalculate Style 和 Layout 阶段，ReactDOM 调用了 setInnerHTML 方法，其内部主要通过 innerHTML 方法，将创建好的 html 片段添加到对应节点 然后，我们创建 10000 个稍微复杂点的节点。修改组件如下： 123456789101112131415161718192021222324252627282930313233343536373839404142import React from &#x27;react&#x27;function createMarkup (doms) &#123; return doms.length ? &#123; __html: doms.join(&#x27; &#x27;) &#125; : &#123; __html: &#x27;&#x27; &#125;&#125;export default class DOM extends React.Component &#123; constructor (props) &#123; super(props) this.state = &#123; complexDOMs: [] &#125; this.onCreateComplexDOMs = this.onCreateComplexDOMs.bind(this) &#125; onCreateComplexDOMs () &#123; const array = [] for (var i = 0; i &lt; 5000; i++) &#123; array.push(` &lt;div class=&#x27;list-item&#x27;&gt; &lt;p&gt;#$&#123;i&#125; eligendi voluptatem quisquam&lt;/p&gt; &lt;p&gt;Modi autem fugiat maiores. Doloremque est sed quis qui nobis. Accusamus dolorem aspernatur sed rem.&lt;/p&gt; &lt;/div&gt; `) &#125; this.setState(&#123; complexDOMs: array &#125;) &#125; render () &#123; return ( &lt;div style=&#123;&#123; marginLeft: &#x27;10px&#x27; &#125;&#125;&gt; &lt;h3&gt;Creat large of DOMs：&lt;/h3&gt; &lt;button onClick=&#123;this.onCreateComplexDOMs&#125;&gt;Create Complex DOMs&lt;/button&gt; &lt;div dangerouslySetInnerHTML=&#123;createMarkup(this.state.complexDOMs)&#125; /&gt; &lt;/div&gt; ) &#125;&#125; 当点击 Button 时，会调用 onCreateComplexDOMs。从 Chrome 的 Performance 标签页看到的数据如下： 从上图可以看到，从 Event Click 到 Paint，总共用了大约 964.2ms，渲染时的主要时间消耗情况如下： Recalculate Style：117.07ms Layout：538.00ms Update Layer Tree：31.15ms 对于上述测试各进行 5 次，然后取各指标的平均值，统计结果如下： - Recalculate Style Layout Update Layer Tree Total 渲染简单节点 199.66ms 523.72ms 12.572ms 735.952ms 渲染复杂节点 114.684ms 806.05ms 31.328ms 952.512ms Total &#x3D; Recalculate Style + Layout + Update Layer Tree demo 的测试代码：test code 从上面的测试结果中可以看到，渲染 10000 个节点就需要 700ms+，实际业务中的列表每个节点都需要 20 个左右的节点，布局也会复杂很多，在 Recalculate Style 和 Layout 阶段也会耗费更长的时间。那么，700ms 也仅能渲染 300 ~ 500 个左右的列表项，所以完整的长列表渲染基本上很难达到业务上的要求的。而非完整的长列表渲染一般有两种方式：按需渲染和延迟渲染(即懒渲染)。常见的无限滚动便是延迟渲染的一种实现，而虚拟列表则是按需渲染的一种实现。 延迟渲染不在本文讨论范围。接下来，本文会简单介绍虚拟列表的一种实现方案。 实现本章节将会创建一个 VirtualizedList 组件，并结合代码，慢慢梳理虚拟列表的实现。 为了简化，我们设定 window 为滚动容器元素，给 html 和 body 元素均添加样式规则 height: 100%，设定可视区域为浏览器的窗口大小。VirtualizedList 在 DOM 元素的布局上将参考Twitter 的移动端： 123456789101112131415161718192021222324252627282930class VirtualizedList extends Component &#123; constructor (props) &#123; super(props) this.state = &#123; startOffset: 0, endOffset: 0, visibleData: [] &#125; this.data = new Array(1000).fill(true) this.startIndex = 0 this.endIndex = 0 this.scrollTop = 0 &#125; render () &#123; const &#123;startOffset, endOffset&#125; = this.state return ( &lt;div className=&#x27;wrapper&#x27;&gt; &lt;div style=&#123;&#123; paddingTop: `$&#123;startOffset&#125;px`, paddingBottom: `$&#123;endOffset&#125;px` &#125;&#125;&gt; &#123; // render list &#125; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125; 在虚拟列表上的实现上，也分为两种情形：列表项是固定高度的和列表项是动态高度的。 列表项是固定高度的既然列表项是固定高度的，那约定没个列表项的高度为 60，列表数据的长度为 1000。 首先，我们根据可视区域的高度估算可视区域能渲染的元素个数： 12345const height = 60const bufferSize = 5// ...this.visibleCount = Math.ceil(window.clientHeight / height) 然后，计算 startIndex 和 endIndex，并先初始化初次需要渲染的数据： 12345678910111213141516171819// ...updateVisibleData (scrollTop) &#123; const visibleData = this.data.slice(this.startIndex, this.endIndex) const endOffset = (this.data.length - this.endIndex) * height this.setState(&#123; startOffset: 0, endOffset, visibleData &#125;)&#125;componentDidMount () &#123; // 计算可渲染的元素个数 this.visibleCount = Math.ceil(window.innerHeight / height) + bufferSize this.endIndex = this.startIndex + this.visibleCount this.updateVisibleData()&#125; 如上文所说，endOffset 是计算 endIndex 对应的数据相对于可滚动区域底部的偏移位置。在本 demo 中，可滚动区域的高度就是 1000 60，因而 endIndex 对应的数据相距底部的偏移就是 (1000 - endIndex) 60。 由于是初始化初次需要渲染的数据，因而 startOffset 的初始值是 0。 根据上述代码，可以得知，要计算可见区域需要渲染的数据，只要计算出 startIndex 就行，因为 visibleCount 是一个定值，bufferSize 是一个缓冲值，用来增加一定的缓存区域，让正常滑动速度的时候不会显得那么突兀。而 endIndex 的值就等于 startIndex 加上 visibleCount；同时，当用户滚动改变可见区域的数据时，还需要计算 startOffset 的值，以保证新的数据会出现在用户浏览器的视口中： 如果不计算 startOffset 的值，那本应该渲染在可视区域内的元素会渲染到可视区域之外。从上图可以看到，startOffset 的值就是元素8的上边框 (可视区域内最上面一个元素) 到元素1的上边框的偏移量。元素8称为 锚点元素，即可视区域内的第一个元素。 因而，我们需要定义一个变量来缓存锚点元素的一些位置信息，同时也要缓存已渲染的元素的位置信息： 1234567891011121314151617181920212223// ...// 缓存已渲染元素的位置信息this.cache = []// 缓存锚点元素的位置信息this.anchorItem = &#123; index: 0, // 锚点元素的索引值 top: 0, // 锚点元素的顶部距离第一个元素的顶部的偏移量(即 startOffset) bottom: 0 // 锚点元素的底部距离第一个元素的顶部的偏移量&#125;// ...cachePosition (node, index) &#123; const rect = node.getBoundingClientRect() const top = rect.top + window.pageYOffset this.cache.push(&#123; index, top, bottom: top + height &#125;)&#125;// ... 方法 cachePosition 会在每个列表项组件渲染完后(componentDidMount)进行调用，node 是对应的列表项节点元素，index 是节点的索引值： 12345678910111213141516171819// Item.jsx// ...componentDidMount () &#123; this.props.cachePosition(this.node, this.props.index)&#125;render () &#123; /* eslint-disable-next-line */ const &#123;index&#125; = this.props return ( &lt;div className=&#x27;list-item&#x27; ref=&#123;node =&gt; &#123; this.node = node &#125;&#125;&gt; &lt;p&gt;#$&#123;index&#125; eligendi voluptatem quisquam&lt;/p&gt; &lt;p&gt;Modi autem fugiat maiores. Doloremque est sed quis qui nobis. Accusamus dolorem aspernatur sed rem.&lt;/p&gt; &lt;/div&gt; )&#125;// ... 缓存了锚点元素和已渲染元素的位置信息之后，接下来就可以处理用户的滚动行为了。以用户向下滚动(scrollTop 值增大的方向)为例： 1234567891011121314151617181920212223242526272829303132333435// ...// 计算 startIndex 和 endIndexupdateBoundaryIndex (scrollTop) &#123; scrollTop = scrollTop || 0 //用户正常滚动下，根据 scrollTop 找到新的锚点元素位置 const anchorItem = this.cache.find(item =&gt; item.bottom &gt;= scrollTop) this.anchorItem = &#123; ...anchorItem &#125; this.startIndex = this.anchorItem.index this.endIndex = this.startIndex + this.visibleCount&#125;// 滚动事件处理函数handleScroll (e) &#123; if (!this.doc) &#123; // 兼容 iOS Safari/Webview this.doc = window.document.body.scrollTop ? window.document.body : window.document.documentElement &#125; const scrollTop = this.doc.scrollTop if (scrollTop &gt; this.scrollTop) &#123; if (scrollTop &gt; this.anchorItem.bottom) &#123; this.updateBoundaryIndex(scrollTop) this.updateVisibleData() &#125; &#125; else if (scrollTop &lt; this.scrollTop) &#123; // 向上滚动(`scrollTop` 值减小的方向) &#125; this.scrollTop = scrollTop&#125;// ... 在滚动事件处理函数中，会去更新 startIndex、endIndex 以及新的锚点元素的位置信息(即更新 startOffset)，然后就可以动态的去更新可视区域的渲染数据了： 完整的代码在可以戳：固定高度的虚拟列表实现 列表项是动态高度的这种情形下，实现的思路和列表项固高大同小异。而小异之处就在于缓存列表项的位置信息时，怎么拿到列表项的精确高度？首先要更改 cachePosition 的部分逻辑： 123456789101112// ...cachePosition (node, index) &#123; const rect = node.getBoundingClientRect() const top = rect.top + window.pageYOffset this.cache.push(&#123; index, top, bottom: top + rect.height // 将 height 更为 rect.height &#125;)&#125;// ... 由于列表项的高度不固定，那要怎么计算 visibleCount 呢？我们先考虑每个列表项只是渲染一些纯文本。在实际项目中，有的列表项可能只有一行文本，有的列表项可能有多行文本，此时，我们要基于项目的实际情况，给列表项一个预估的高度：estimatedItemHeight。 比如，有一个长列表要渲染用户的文章摘要，并规定摘要显示不超过三行，那么我们取列表的前 10 个列表项的高度平均值作为预估高度。当然，为了预估高度更精确，我们是可以扩大取样样本的。 既然有了预估高度，那么将原先代码中的 height 替换成 estimatedItemHeight，就可以计算出 visibleCount 了： 123456789// ...const estimatedItemHeight = 80// ...// 计算可渲染的元素个数this.visibleCount = Math.ceil(window.innerHeight / estimatedItemHeight) + bufferSize// ... 我们通过 faker.js 来创建一些随机数据，并赋值给 data： 123456789101112131415161718// ...function fakerData () &#123; const a = [] for (let i = 0; i &lt; 1000; i++) &#123; a.push(&#123; id: i, words: faker.lorem.words(), paragraphs: faker.lorem.sentences() &#125;) &#125; return a&#125;// ...this.data = fakerData()// ... 修改一下列表项的 render 逻辑，其它不变： 12345678910111213141516// Item.jsx// ...render () &#123; /* eslint-disable-next-line */ const &#123;index, item&#125; = this.props return ( &lt;div className=&#x27;list-item&#x27; style=&#123;&#123; height: &#x27;auto&#x27; &#125;&#125; ref=&#123;node =&gt; &#123; this.node = node &#125;&#125;&gt; &lt;p&gt;#$&#123;index&#125; &#123;item.words&#125;&lt;/p&gt; &lt;p&gt;&#123;item.paragraphs&#125;&lt;/p&gt; &lt;/div&gt; )&#125;// ... 此时，列表项的高度已经是动态的了，根据渲染的实际情况，我们给的预估高度是 80： 完整的代码在可以戳：动态高度的虚拟列表实现 那如果列表项渲染的不是纯文本呢？比如渲染的是图文，那在 Item 组件的 componentDidMount 去调用 cachePosition 方法时，能拿到对应节点的正确高度吗？在渲染图文的情况下，因为图片会发起网络请求，此时并不能保证在列表项组件挂载(执行 componentDidMount)的时候图片渲染好了，那此时对应节点的高度就是不准确的，因而在用户滚动改变可见区域渲染的数据时，就可能出现元素相互重叠的情况： 在这种情况下，如果我们能监听 Item 组件节点的大小变化就能获取其正确的高度了。ResizeObserver 或许就可以满足我们的需求，其提供了监听 DOM 元素大小变化的能力，但在撰写本文时，仅 Chrome 67 及以上版本支持，其它主流浏览器均为提供支持。以下是我搜集的一些资料，供你参考(自备梯子)： ResizeObserver: It’s Like document.onresize for Elements ResizeObserver caniuse#resizeobserver 总结在本文中，首先对虚拟列表进行了简单的定义，然后从长列表的角度分析了为什么需要虚拟列表，最后就列表项固高和不固高两个场景下以一个简单的 demo 详细讲述了虚拟列表的实现思路。 在列表项是动态高度的场景下，分析了渲染纯文本和图文混合的场景。前者给出了一个具体的 demo，针对后者对于怎么监听元素大小的变化提供了参考的 ResizeObserver 方案。基于 ResizeObserver 的方案呢，我也实现了一个支持渲染图文混合(当然也支持纯文本)的虚拟列表组件 react-virtual-list，供你参考。 当然，这并不是唯一一种实现虚拟列表的方案。在组件 react-virtual-list 的实现过程中，也阅读了不同虚拟列表组件的源码，如: react-tiny-virtual-list、react-window、react-virtualized 等，后续的系列文章我会从源码的角度逐一分析。","tags":["front-end","performance"]},{"title":"three.js轻松入门","path":"/2025/04/10/three-js轻松入门/","content":"本文使用原生三件套的方式去学习 Three.js。是一篇面向小白的笔记~ Three.js 官网 下载 Three.jsThree.js GitHub地址 通过上面的地址，可以下载 Three.js 这是下载下来解压后的文件 创建项目我习惯使用 vs code 编写前端代码，如果是用原生三件套学习，我还会使用 Live Server 插件辅助开发。 创建 Three-study-demo 目录，用来存放本例代码。 目录如下所示 1234567- /Three-study-demo |- /js |- Three |- Three下载下来的包，把src里的东西搬过来 |- /01起步 |- index.html 把刚刚从 Three.js 下载下来的包解压后，找到 src/Three.js ，并将其复制到 Three-study-demo/js 里 项目到此就算创建好了。 引入 Three.js在 vs code 里打开 index.html ，然后引入 Three.js 123&lt;script type=&quot;module&quot;&gt; import * as THREE from &quot;../js/Three/Three.js&quot;&lt;/script&gt; 注意，上面的 script 标签中使用了 type=&quot;module&quot; ，在写本文时 Chrome 已经支持这种写法，这种写法允许我们使用 import 的方式引入第三方包。 右键，选择 Open with Live Server 运行该页面。 Live Server 这个插件每当你保存时，页面都会自动刷新。减少很多手动操作。 基础概念在学习 Three.js 前，需要了解几个概念，毕竟是 3D 库。 属性名称 描述 场景(Scene) 是物体、光源等元素的容器，可以配合 chrome 插件使用，抛出 window.scene 即可实时调整 obj 的信息和材质信息。 相机(Camera) 场景中的相机，代替人眼去观察，场景中只能添加一个，一般常用的是透视相机(PerspectiveCamera)。 物体对象(Mesh) 包括二维物体（点、线、面）、三维物体、模型等等。 光源(Light) 场景中的光照，如果不添加光照场景将会是一片漆黑，包括全局光、平行光、点光源等。 渲染器(Renderer) 场景的渲染方式，如 WebGL、canvas2D、css3D。 控制器(Control) 可通过键盘、鼠标控制相机的移动。 除了上面这些属性，还有 材质 、音频 、动画 等其他知识点。这些后面会讲到。 对于刚起步的同学来讲，先让浏览器有点东西显示出来才是最重要的。 所以只需大概理解以下几个属性就能在浏览器渲染出东西： 场景：用来放物体、光源等元素的容器。 相机：相当于你的眼睛，相机拍摄到的东西就是你看到的东西。 物体对象：就是物体，对应真实世界的苹果香蕉之类的东西。 渲染器：将相机拍摄下来的图片，放到浏览器中去显示。 起步了解上面所说的 基础概念 后，我们根据 官方文档 上面的案例创建出第一个场景。 本文的第一个场景会比 Three.js 官网上的更加简单，步骤如下： 创建 HTML 容器，用来绑定画布的。 创建一个场景，用来放物体。 创建一个相机，代表我们的眼睛去看东西。 创建一个物体，不然没东西看了。 创建一个渲染器，并把场景和相机放到渲染器里渲染，最后将渲染器添加到页面中。 让物体动起来。 代码将根据上面 6个步骤 进行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;style&gt; body &#123; margin: 0; padding: 0; &#125;&lt;/style&gt;&lt;!-- 【步骤1】 --&gt;&lt;div id=&quot;canvasBox&quot;&gt;&lt;/div&gt;&lt;!-- 引入Three.js --&gt;&lt;!-- 注意这里有个 module --&gt;&lt;script type=&quot;module&quot;&gt; /** * 引入相关要素 */ import &#123; Scene, // 场景 PerspectiveCamera, // 相机 WebGLRenderer, // 渲染器 // 下面3个都是创建“物体”需要的要素，等下用到的时候会逐一解释 BoxGeometry, MeshBasicMaterial, Mesh &#125; from &quot;../js/Three/Three.js&quot; // 【步骤2】 // 场景对象 // 场景是一个容器，主要用于保存、跟踪所要渲染的物体和使用的光源 // 如果没有场景对象就无法渲染任何物体 const scene = new Scene() // 【步骤3】 // 透视相机 // 摄像机决定了能够在场景中看到什么 // 我们基于摄像机的角度来计算场景对象在浏览器中会渲染成什么样子 // 第一个参数：视野角度（FOV）。视野角度就是无论在什么时候，你所能在显示器上看到的场景的范围，它的单位是角度(与弧度区分开)。 // 第二个参数：宽高比 // 第三个参数：近截面（near） // 第四个参数：远截面（far） const camera = new PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000) // 【步骤4】 // 创建一个立方几何体 const geometry = new BoxGeometry() // 材质 const material = new MeshBasicMaterial(&#123; color: 0x002299 &#125;) // 组合立方几何体和材质，创建出一个新的网格对象 const cube = new Mesh(geometry, material) // 将立方体网格追加到场景中 scene.add(cube) // 设置摄像机在z轴上的距离（也就是在屏幕上的距离） camera.position.z = 5 // 【步骤5】 // 创建渲染器 const renderer = new WebGLRenderer() // 设置渲染器的大小 renderer.setSize(window.innerWidth, window.innerHeight) // 将渲染器添加到div中 document.getElementById(&#x27;canvasBox&#x27;).appendChild(renderer.domElement) // 【步骤6】 // 通过修改 cube 的 rotation 的属性，改变立方体的角度。最后再不断刷新画布做出动画效果。 function animate() &#123; requestAnimationFrame( animate ) cube.rotation.x += 0.01 cube.rotation.y += 0.01 // 将场景和摄像机传入到渲染器中 renderer.render( scene, camera ) &#125; // 执行动画函数 animate()&lt;/script&gt; 第一次敲代码，先别管那些 api 的详细用法。先理解上面说到的 6个步骤 。 如果你不想显示动画，也可以把 animate 函数删掉，直接写 renderer.render( scene, camera ) 即可。 有场景，有相机，有物体，有渲染器。存在这4个，页面就会有东西显示。 跟着敲两遍，之后再看看 官方示例 ，深入理解下每个 api 的用法。你就算是入门了 Three.js 。","tags":["three.js","Canvs"],"categories":["Canvas"]},{"title":"聊聊canvas绘图状态管理","path":"/2025/04/08/聊聊canvas绘图状态管理/","content":"本文简介canvas 绘图时会根据当前状态来绘制。很多的 canvas 库都利用到这一特性。比如 p5.js 利用了 canvas 状态特性衍生出 push 和 pop 函数实现状态隔离（既然提到了，下一篇就讲这个）。 有兴趣了解 p5.js 的工友推荐阅读 《p5.js光速入门》。 什么是 Canvas 状态canvas 是根据状态来绘图的。所谓的状态就是指当前画布正在使用什么填充色(fill)、什么描边色(stroke) 等样式。 比如当前的填充色(fill) 是红色，接下来所有图形的填充色都会是红色。 如果想在某一刻恢复到指定的填充色，就可以使用 canvas 提供的状态机制来实现了。 使用方法canvas 提供了 save() 和 restore() 两个方法去操作状态。这两个方法通常也会成对出现。 save(): “打标记”，记录当前状态 restore(): 恢复到 save() 记录的状态 举个例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;canvas id=&quot;c&quot; width=&quot;300&quot; height=&quot;200&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const context = document.getElementById(&#x27;c&#x27;) const ctx = context.getContext(&#x27;2d&#x27;) ctx.fillStyle = &#x27;red&#x27; // 设置填充色为红色 ctx.strokeStyle = &#x27;blue&#x27; // 设置描边色为蓝色 ctx.lineWidth = 6 // 描边宽度 6 ctx.save() // 保存当前状态 // 第一个矩形 ctx.rect(10, 10, 100, 60) ctx.fill() ctx.stroke() ctx.fillStyle = &#x27;pink&#x27; // 设置填充色为粉色 ctx.strokeStyle = &#x27;green&#x27; // 设置描边色为绿色 ctx.lineWidth = 10 // 描边宽度 10 ctx.beginPath() // 第二个矩形 ctx.rect(140, 10, 100, 60) ctx.fill() ctx.stroke() ctx.fillStyle = &#x27;orange&#x27; // 设置填充色为橙色 ctx.strokeStyle = &#x27;hotpink&#x27; // 设置描边色为亮粉 ctx.lineWidth = 2 // 描边宽度 2 ctx.beginPath() // 第三个矩形 ctx.rect(10, 100, 100, 60) ctx.fill() ctx.stroke() ctx.restore() // 恢复到之前保存的状态 ctx.beginPath() // 第四个矩形 ctx.rect(140, 100, 100, 60) ctx.fill() ctx.stroke()&lt;/script&gt; 从上面的例子可以看出，经过几轮的样式修改，在绘制第四个矩形时，想使用第一个矩形的样式，只需要在设置完第一个矩形的样式时使用 save() 做个标记，之后再使用 restore() 恢复一下即可。 需要注意的是，每次绘制矩形之前都需要使用 beginPath() 告诉 canvas 要重新绘制了。不然前面所绘制的矩形会被后面设置的样式覆盖掉。这个“问题”在 《Canvas 从进阶到退学》 里也有讲到，有兴趣的工友可以去瞧瞧。 canvas 状态可以将裁剪区域还原到指定状态，可以将变形的画布还原到指定状态，还可以将大部分样式还原到指定状态。有兴趣的工友可以自己动手尝试一下~ 代码仓库⭐雷猴 Canvas 推荐阅读👍《Canvas 从入门到劝朋友放弃（图解版）》 👍《Canvas 从进阶到退学》 👍《Canvas 10款基础滤镜（原理篇）》 👍《p5.js 光速入门》 👍《Fabric.js 从入门到膨胀》 👍《前端需要的免费在线api接口》","tags":["Canvas"],"categories":["Canvas"]},{"title":"canvas进阶知识图解","path":"/2025/04/08/canvas进阶知识图解/","content":"本文简介本文会涉及到 canvas 的知识包括：变形、像素控制、渐变、阴影、路径 变形这里说的变形是基于画布，全局进行变形。 变形主要包括：平移 translate、缩放 scale、旋转操作 rotate。 除了对应的方法外，还可以使用 transform 和 setTransform 对上面三种操作进行配置，这称为“变换矩阵”。 在学习“变形”之前，需要了解 W3C坐标系： 箭头所指是各轴自己的正方向，x轴越往右（正方向）值越大，y轴越往下（正方向）值越大。 平移使用 translate() 方法可以实现平移效果（位移）。 translate(x, y) 接收2个参数，第一个参数代表x轴方向位移距离，第二个参数代表y轴方向位移距离。 正数代表向正方向位移，负数代表向反方向位移。 演示平移效果之前，我先创建一个矩形，长宽都是100，位置在画布的原点 (0, 0) ，也就是紧贴画布的左上角。 123456789&lt;canvas id=&quot;c&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const context = document.getElementById(&#x27;c&#x27;) const ctx = context.getContext(&#x27;2d&#x27;) // 紧贴原点的矩形，默认是黑色[] ctx.fillRect(0, 0, 100, 100)&lt;/script&gt; 如果此时在 fillRect 之前设置 translate 就可以实现整个画布位移的效果。 1234567// 省略部分代码// 平移，往右平移10，往下平移20ctx.translate(10, 20)// 渲染矩形ctx.fillRect(0, 0, 100, 100) 从上图可以看出，矩形距离画布顶部的距离是20，距离画布左侧的距离是10。 注意：平移 translate() 要写在 “绘制操作(本例是 fillRect)” 之前才有效。 如果在使用 translate 的前后都有渲染操作，画布会多次渲染，并不会自动清屏。 比如这样 123456789101112&lt;canvas id=&quot;c&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const context = document.getElementById(&#x27;c&#x27;) const ctx = context.getContext(&#x27;2d&#x27;) ctx.fillRect(0, 0, 100, 100) ctx.translate(10, 20) ctx.fillRect(0, 0, 100, 100)&lt;/script&gt; 再做个明显点的效果，每秒平移一次 1234567891011121314&lt;canvas id=&quot;c&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const context = document.getElementById(&#x27;c&#x27;) const ctx = context.getContext(&#x27;2d&#x27;) ctx.fillRect(0, 0, 100, 100) setInterval(() =&gt; &#123; ctx.translate(10, 20) ctx.fillRect(0, 0, 100, 100) &#125;, 1000)&lt;/script&gt; 可以看出，每次使用 translate() 平移画布，都会基于上一次画布所在的位置进行平移。 上图效果是 canvas 的默认效果，所以在执行 translate 之前可以执行 “清屏操作”。 清屏 123456789101112131415&lt;canvas id=&quot;c&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const context = document.getElementById(&#x27;c&#x27;) const ctx = context.getContext(&#x27;2d&#x27;) ctx.fillRect(0, 0, 100, 100) setInterval(() =&gt; &#123; ctx.clearRect(0, 0, context.width, context.height) ctx.translate(10, 20) ctx.fillRect(0, 0, 100, 100) &#125;, 1000)&lt;/script&gt; 缩放缩放画布用到的方法是 scale(x, y) ，接收2个参数，第一个参数是x轴方向的缩放，第二个参数是y轴方向的缩放。 当 x 或者 y 的值是 0 ~ 1 时代表缩小，比如取值为 0.5 时，表示比原本缩小一半；值为2时，比原本放大一倍。 12345678910111213141516&lt;canvas id=&quot;c&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const context = document.getElementById(&#x27;c&#x27;) const ctx = context.getContext(&#x27;2d&#x27;) ctx.font = &#x27;60px Arial&#x27; ctx.strokeStyle = &#x27;hotpink&#x27; ctx.strokeText(&#x27;雷猴&#x27;, 40, 100) // 缩小 ctx.scale(0.5, 0.5) // 重新渲染 ctx.strokeText(&#x27;雷猴&#x27;, 40, 100)&lt;/script&gt; scale() 方法同样会保留原本已经渲染的内容。 如果不需要保留原本内容，可以使用 “清屏操作”。 注意：scale() 会以上一次缩放为基准进行下一次缩放。 副作用： 其实从上面的例子就可以看出 scale() 存在一点副作用的，从图中可以看出，缩放后文本的左上角坐标发生了“位移”，文本描边粗细也发生了变化。 虽然说是副作用，但也很容易理解，整块画布缩放了，对应的坐标比例其实也跟着缩放嘛。 旋转使用 rotate(angle) 方法可以旋转画布，但默认的旋转原点是画布的左上角，也就是 (0, 0) 坐标。 我计算旋转角度通常是用 角度 * Math.PI / 180 的方式表示。 虽然这样书写代码看上去很长，但习惯后就比较直观的看出要旋转多少度。 rotate(angle) 中的参数 angle 代表角度，angle 的取值范围是 -Math.PI * 2 ~ Math.pi * 2。 当旋转角度小于 0 时，画布逆时针旋转；反之顺时针旋转。 12345678910111213141516&lt;canvas id=&quot;c&quot; height=&quot;300&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const context = document.getElementById(&#x27;c&#x27;) const ctx = context.getContext(&#x27;2d&#x27;) ctx.font = &#x27;60px Arial&#x27; ctx.strokeStyle = &#x27;pink&#x27; ctx.strokeText(&#x27;雷猴&#x27;, 40, 100) // 旋转 45° ctx.rotate(45 * Math.PI / 180) // 重新渲染 ctx.strokeText(&#x27;雷猴&#x27;, 40, 100)&lt;/script&gt; 修改原点如果需要修改旋转中心，可以使用 translate() 方法平移画布，通过计算移动到指定位置。 12345678910111213141516171819&lt;canvas id=&quot;c&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const context = document.getElementById(&#x27;c&#x27;) const ctx = context.getContext(&#x27;2d&#x27;) ctx.font = &#x27;60px Arial&#x27; ctx.strokeStyle = &#x27;pink&#x27; ctx.strokeText(&#x27;雷猴&#x27;, 40, 100) // 设置旋转中心 ctx.translate(90, -50) // 旋转 ctx.rotate(45 * Math.PI / 180) // 重新渲染 ctx.strokeText(&#x27;雷猴&#x27;, 40, 100)&lt;/script&gt; 变换矩阵变换矩阵常用方法有 transform() 和 setTransform() 两个方法。 变换矩阵是一个稍微进阶一点的知识了，别怕！ 前面的 平移 translate、缩放 scale、旋转操作 rotate 可以说都是 transform() 的 “语法糖”。 变换矩阵已经涉及到一点数学知识了，但本文不会讲到这些知识，只会讲讲 transform() 是怎么用的。 transformtransform() 一个方法就可以实现 平移、缩放、旋转 三种功能，它接收6个参数。 transform(a, b, c, d, e, f) a: 水平缩放（x轴方向），默认值是 1； b: 水平倾斜（x轴方向），默认值是 0； c: 垂直倾斜（y轴方向），默认值是 0； d: 垂直缩放（y轴方向），默认值是 1； e: 水平移动（x轴方向），默认值是 0； f: 垂直移动（y轴方向），默认值是 0； 这默认值看上去很乱，但如果这样排列一下是不是就比较容易理解了： (acebdf001)\\begin{pmatrix}a &amp; c &amp; e \\\\\\\\ b &amp; d &amp; f \\\\\\\\ 0 &amp; 0 &amp; 1 \\end{pmatrix}⎝⎛​ab0​cd0​ef1​⎠⎞​ 随便修改几个值试试效果： 123456789101112&lt;canvas id=&quot;c&quot; width=&quot;400&quot; height=&quot;400&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const context = document.getElementById(&#x27;c&#x27;) const ctx = context.getContext(&#x27;2d&#x27;) // 变换矩阵 ctx.transform(1, 1, 1, 2, 30, 40) // 绘制矩形 ctx.fillRect(10, 10, 100, 100)&lt;/script&gt; setTransformsetTransform(a, b, c, d, e, f) 同样接收6个参数，和 transform() 一样 123456789101112&lt;canvas id=&quot;c&quot; width=&quot;400&quot; height=&quot;400&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const context = document.getElementById(&#x27;c&#x27;) const ctx = context.getContext(&#x27;2d&#x27;) // 变换矩阵 ctx.setTransform(2, 1, 1, 2, 20, 10) // 绘制矩形 ctx.fillRect(10, 10, 100, 100)&lt;/script&gt; transform 和 setTransform 的区别transform() 每次执行都会参考上一次变换后的结果 比如下面这个多次执行的情况： 1234567891011121314151617181920212223&lt;canvas id=&quot;c&quot; width=&quot;400&quot; height=&quot;400&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const context = document.getElementById(&#x27;c&#x27;) const ctx = context.getContext(&#x27;2d&#x27;) ctx.fillStyle = &#x27;rgba(10, 10, 10, 0.2)&#x27; ctx.fillRect(10, 10, 100, 100) ctx.transform(1, 0, 0, 1, 10, 10) ctx.fillRect(10, 10, 100, 100) ctx.transform(1, 0, 0, 1, 10, 10) ctx.fillRect(10, 10, 100, 100) ctx.transform(1, 0, 0, 1, 10, 10) ctx.fillRect(10, 10, 100, 100) ctx.transform(1, 0, 0, 1, 10, 10) ctx.fillRect(10, 10, 100, 100)&lt;/script&gt; 而 setTransform() 每次调用都会基于最原始是状态进行变换。 1234567891011121314151617181920212223&lt;canvas id=&quot;c&quot; width=&quot;400&quot; height=&quot;400&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const context = document.getElementById(&#x27;c&#x27;) const ctx = context.getContext(&#x27;2d&#x27;) ctx.fillStyle = &#x27;rgba(10, 10, 10, 0.2)&#x27; ctx.fillRect(10, 10, 100, 100) ctx.setTransform(1, 0, 0, 1, 10, 10) ctx.fillRect(10, 10, 100, 100) ctx.setTransform(1, 0, 0, 1, 10, 10) ctx.fillRect(10, 10, 100, 100) ctx.setTransform(1, 0, 0, 1, 10, 10) ctx.fillRect(10, 10, 100, 100) ctx.setTransform(1, 0, 0, 1, 10, 10) ctx.fillRect(10, 10, 100, 100)&lt;/script&gt; 不管改变多少次，setTransform() 都会参考原始状态进行变换。 控制像素位图是由像素点组成的，canvas 提供了几个 api 可以操作图片中的像素。 很多工具网站也常用接下来说到的几个 api 做图片滤镜。 需要注意的是，canvas 提供的操作像素的方法，必须使用服务器才能运行起来，不然没有效果的。 可以搭建本地服务器运行本文案例，方法有很多种。 比如你使用 Vue 或者 React 的脚手架搭建的项目，运行后就能跑起本文所有案例。 又或者使用 http-server 启动本地服务。 getImageData()首先要介绍的是 getImageData() 方法，这个方法可以获取指定区域内的所有像素。 getImageData(x, y, width, height) 接收4个参数，这4个参数表示选区范围。 x 和 y 代表选区的左上角坐标，width 表示选区宽度，height 表示选区高度。 还是举例说明比较清楚。下图渲染到画布上的是我的猫_Bubble_。 12345678910111213141516171819&lt;canvas id=&quot;c&quot; width=&quot;400&quot; height=&quot;400&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const context = document.getElementById(&#x27;c&#x27;) const ctx = context.getContext(&#x27;2d&#x27;) const img = new Image() // 创建图片对象 img.src = &#x27;./bubble.jpg&#x27; // 加载本地图片 // 图片加载完成后在执行其他操作 img.onload = () =&gt; &#123; // 渲染图片 ctx.drawImage(img, 0, 0) // 获取图片信息 const imageData = ctx.getImageData(0, 0, img.width, img.height) console.log(imageData) &#125;&lt;/script&gt; 打印出来的信息可以点开大图看看 data: 图片像素数据集，以数组的形式存放，这是本文要讲的重点，需要关注！ colorSpace: 图片使用的色彩标准，这个属性在 Chrome 里有打印出来，Firefox 里没打印。不重要~ height: 图片高度 width: 图片宽度 通过 getImageData() 获取到的信息中，需要重点关注的是 data ，它是一个一维数组，仔细观察发现里面的值没一个是大于255的，也不会小于0。 其实 data 属性里记录了图片每个像素的 rgba 值分别是多少。 r 代表红色 g 代表绿色 b 代表蓝色 a 透明度 这个和 CSS 里的 rgba 是同一个意思。 data 里，4个元素记录1个像素的信息。也就是说，1个像素是由 r、g、b、a 4个元素组成。而且每个元素的取值范围是 0 - 255 的整数。 1data: **[r1, g1, b1, a1, r2, g2, b2, a2, ......]** 像素点 值 颜色通道 imgData.data[0] 49 红色 r imgData.data[1] 47 绿色 g imgData.data[2] 51 蓝色 b imgData.data[3] 255 透明度 a …… …… …… imgData.data[n-4] 206 红色 r imgData.data[n-2] 200 绿色 g imgData.data[n-3] 200 蓝色 b imgData.data[n-1] 255 透明度 a 如果一张图只有10个像素，通过 getImageData() 获取到的 data 信息中就有40个元素。 putImageData()putImageData(imageData, x, y) 可以将 ImageData 对象的数据（图片像素数据）绘制到画布上。 putImageData(imgData, x, y, dirtyX, dirtyY, dirtyWidth, dirtyHeight) 也可以接收更多参数。 imageData: 规定要放回画布的 ImageData 对象 x: ImageData 对象左上角的 x 坐标，以像素计 y: ImageData 对象左上角的 y 坐标，以像素计 dirtyX: 可选。水平值（x），以像素计，在画布上放置图像的位置 dirtyY: 可选。水平值（y），以像素计，在画布上放置图像的位置 dirtyWidth: 可选。在画布上绘制图像所使用的宽度 dirtyHeight: 可选。在画布上绘制图像所使用的高度 比如，我要将图片复制到另一个位置 123456789101112131415161718192021&lt;canvas id=&quot;c&quot; width=&quot;500&quot; height=&quot;500&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const context = document.getElementById(&#x27;c&#x27;) const ctx = context.getContext(&#x27;2d&#x27;) const img = new Image() // 创建图片对象 img.src = &#x27;./bubble.jpg&#x27; // 加载本地图片 // 图片加载完成后在执行其他操作 img.onload = () =&gt; &#123; // 渲染图片 ctx.drawImage(img, 0, 0) // 获取图片信息 const imageData = ctx.getImageData(0, 0, img.width, img.height) // 将图片对象输出到 (100, 100) 的位置上 ctx.putImageData(imageData, 100, 100) &#125;&lt;/script&gt; 可以实现复制的效果。 透明知道前面两个 api 就可以实现透明效果了。 前面讲到，通过 getImageData() 获取的是一个数组类型的数据，每4个元素代表1个像素，就是rgba，而 a 表示透明通道，所以只需修改每组像素的最后1个元素的值，就能修改图片的不透明度。 12345678910111213141516171819202122232425&lt;canvas id=&quot;c&quot; width=&quot;500&quot; height=&quot;500&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const context = document.getElementById(&#x27;c&#x27;) const ctx = context.getContext(&#x27;2d&#x27;) const img = new Image() // 创建图片对象 img.src = &#x27;./bubble.jpg&#x27; // 加载本地图片 // 图片加载完成后在执行其他操作 img.onload = () =&gt; &#123; // 渲染图片 ctx.drawImage(img, 0, 0) // 获取图片信息 const imageData = ctx.getImageData(0, 0, img.width, img.height) for (let i = 0; i &lt; imageData.data.length; i += 4) &#123; imageData.data[i + 3] = imageData.data[i + 3] * 0.5 &#125; // 将图片对象输出到 (100, 100) 的位置上 ctx.putImageData(imageData, 100, 100) &#125;&lt;/script&gt; 滤镜要做不同的滤镜效果，其实就是通过不同的算法去操作每个像素的值，我在 《Canvas 10款基础滤镜（原理篇）》 讲到相关知识，有兴趣的工友可以点进去看看 渐变在 css 和 svg 里都有渐变，canvas 肯定也不会缺失这个能力啦。 canvas 提供了 线性渐变 createLinearGradient 和 **径向渐变 createRadialGradient**。 线性渐变 createLinearGradient在 canvas 中使用线性渐变步骤如下： 创建线性渐变对象: createLinearGradient(x1, y1, x2, y2) 添加渐变颜色: addColorStop(stop, color) 设置填充色或描边颜色: fillStyle 或 strokeStyle createLinearGradient(x1, y1, x2, y2) 在 createLinearGradient(x1, y1, x2, y2) 中，x1, y1 表示渐变的起始位置，x2, y2 表示渐变的结束位置。 比如水平方向的从左往右的线性渐变，此时的 y1 和 y2 的值是一样的。 两个点就可以确定一个渐变方向。 addColorStop(stop, color) addColorStop(stop, color) 方法可以添加渐变色。 第一个参数 stop 表示渐变色位置的偏移量，取值范围是 0 ~ 1。 第二个参数 color 表示颜色。 填充渐变实际编码演示一下 12345678910111213141516171819&lt;canvas id=&quot;c&quot; width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const context = document.getElementById(&#x27;c&#x27;) const ctx = context.getContext(&#x27;2d&#x27;) // 1. 创建线性渐变对象 const lgrd = ctx.createLinearGradient(10, 10, 200, 10) // 2. 添加渐变颜色 lgrd.addColorStop(0, &#x27;pink&#x27;) lgrd.addColorStop(1, &#x27;yellow&#x27;) // 设置填充色 ctx.fillStyle = lgrd // 创建矩形，填充 ctx.fillRect(10, 10, 200, 200)&lt;/script&gt; 如果想修改渐变的方向，只需在使用 createLinearGradient() 时设置好起点和终点坐标即可。 除了填充色，描边渐变和文本渐变同样可以做到。 描边渐变 12345678910111213141516&lt;canvas id=&quot;c&quot; width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const context = document.getElementById(&#x27;c&#x27;) const ctx = context.getContext(&#x27;2d&#x27;) const lgrd = ctx.createLinearGradient(10, 10, 200, 10) lgrd.addColorStop(0, &#x27;pink&#x27;) lgrd.addColorStop(1, &#x27;yellow&#x27;) ctx.strokeStyle = lgrd ctx.lineWidth = 10 ctx.strokeRect(10, 10, 200, 200)&lt;/script&gt; 文本渐变 12345678910111213141516&lt;canvas id=&quot;c&quot; width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const context = document.getElementById(&#x27;c&#x27;) const ctx = context.getContext(&#x27;2d&#x27;) const lgrd = ctx.createLinearGradient(10, 10, 200, 10) lgrd.addColorStop(0, &#x27;pink&#x27;) lgrd.addColorStop(1, &#x27;yellow&#x27;) const text = &#x27;雷猴&#x27; ctx.font = &#x27;bold 100px 黑体&#x27; ctx.fillStyle = lgrd ctx.fillText(text, 10, 100)&lt;/script&gt; 多色线性渐变在 0 ~ 1 的范围内，addColorStop 可以设置多个颜色在不同的位置上。 1234// 省略部分代码lgrd.addColorStop(0, &#x27;#2a9d8f&#x27;) // 绿色lgrd.addColorStop(0.5, &#x27;#e9c46a&#x27;) // 黄色lgrd.addColorStop(1, &#x27;#f4a261&#x27;) // 橙色 径向渐变 createRadialGradient径向渐变是从一个点到另一个点扩散出去的渐变，是圆形（椭圆也可以）渐变。 直接看效果 12345678910111213&lt;canvas id=&quot;c&quot; width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const context = document.getElementById(&#x27;c&#x27;) const ctx = context.getContext(&#x27;2d&#x27;) const rgrd = ctx.createRadialGradient(70, 70, 0, 70, 70, 60) rgrd.addColorStop(0, &#x27;yellow&#x27;) rgrd.addColorStop(1, &#x27;pink&#x27;) ctx.fillStyle = rgrd ctx.fillRect(10, 10, 120, 120)&lt;/script&gt; 用 createRadialGradient 可以创建一个径向渐变的对象。使用步骤和 createLinearGradient 一样，但参数不同。 createRadialGradient(x1, y1, r1, x2, y2, r2) x1, y1: 渐变开始的圆心坐标 r1: 渐变开始的圆心半径 x2, y2: 渐变结束的圆心坐标 r2: 渐变结束的圆心半径 同样使用 addColorStop 设置渐变颜色，同样支持多色渐变。 渐变的注意事项渐变的定位坐标是参照画布的，超出定位的部分会使用最临近的那个颜色。 我用线性渐变举例。 1234567891011121314151617181920212223242526272829303132&lt;canvas id=&quot;c&quot; width=&quot;600&quot; height=&quot;600&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const context = document.getElementById(&#x27;c&#x27;) const ctx = context.getContext(&#x27;2d&#x27;) const lgrd = ctx.createLinearGradient(200, 0, 400, 400) lgrd.addColorStop(0, &#x27;pink&#x27;) lgrd.addColorStop(1, &#x27;yellow&#x27;) ctx.fillStyle = lgrd ctx.fillRect(10, 10, 160, 160) ctx.fillRect(220, 10, 160, 160) ctx.fillRect(430, 10, 160, 160) ctx.fillRect(10, 210, 160, 160) ctx.fillRect(220, 210, 160, 160) ctx.fillRect(430, 210, 160, 160) ctx.fillRect(10, 430, 160, 160) ctx.fillRect(220, 430, 160, 160) ctx.fillRect(430, 430, 160, 160)&lt;/script&gt; 上面的例子中，我只创建了一个渐变，然后创建了9个正方形。 此时正方形的填充色取决于出现在画布中的位置。 可以修改一下 createLinearGradient() 的定位数据对照理解。 12// 省略部分代码const lgrd = ctx.createLinearGradient(200, 0, 400, 400) 如果想每个图形都有自己的渐变色，这需要定制化配置，每个创建每个图形之前都单独创建一个渐变色。 1234567891011121314151617181920&lt;canvas id=&quot;c&quot; width=&quot;600&quot; height=&quot;600&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const context = document.getElementById(&#x27;c&#x27;) const ctx = context.getContext(&#x27;2d&#x27;) // 粉 - 黄 渐变 const lgrd1 = ctx.createLinearGradient(10, 10, 160, 160) lgrd1.addColorStop(0, &#x27;pink&#x27;) lgrd1.addColorStop(1, &#x27;yellow&#x27;) ctx.fillStyle = lgrd1 ctx.fillRect(10, 10, 160, 160) // 橘黄 - 蓝紫 渐变 const lgrd2 = ctx.createLinearGradient(210, 10, 380, 160) lgrd2.addColorStop(0, &#x27;bisque&#x27;) lgrd2.addColorStop(1, &#x27;blueviolet&#x27;) ctx.fillStyle = lgrd2 ctx.fillRect(220, 10, 160, 160)&lt;/script&gt; 所以不管是填充色还是秒变颜色，每个元素最好都自己重新设定一下。不然可能会出现意想不到的效果~ 阴影阴影在前端也是很常用的特效。 依稀记得当年还用 png 做阴影效果。 在 canvas 中，和阴影相关的属性主要有以下4个： shadowOffsetX: 设置或返回阴影与形状的水平距离。默认值是0。大于0时向正方向偏移。 shadowOffsetY: 设置或返回阴影与形状的垂直距离。默认值是0。大于0时向正方向偏移。 shadowColor: 设置或返回用于阴影的颜色。 默认黑色。 shadowBlur: 设置或返回用于阴影的模糊级别。 默认值是0，数值越大模糊度越强。 相信使用过 css 阴影属性的工友，理解起 canvas 阴影也会非常轻松。 12345678910111213141516&lt;canvas id=&quot;c&quot; width=&quot;300&quot; height=&quot;200&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const context = document.getElementById(&#x27;c&#x27;) const ctx = context.getContext(&#x27;2d&#x27;) ctx.shadowOffsetX = 10 // x轴偏移量 ctx.shadowOffsetY = 10 // y轴偏移量 ctx.shadowColor = &#x27;#f38181&#x27; // 阴影颜色 ctx.shadowBlur = 10 // 阴影模糊度，默认0 ctx.fillStyle = &#x27;#fce38a&#x27; // 填充色 ctx.fillRect(30, 30, 200, 100) console.log(ctx.shadowOffsetX) // 输出阴影x轴方向的偏移量：10&lt;/script&gt; 除了图形外，文本和图片都可以设置阴影效果。 12345678910111213141516&lt;canvas id=&quot;c&quot; width=&quot;300&quot; height=&quot;200&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const context = document.getElementById(&#x27;c&#x27;) const ctx = context.getContext(&#x27;2d&#x27;) ctx.shadowOffsetX = 10 // x轴偏移量 ctx.shadowOffsetY = 10 // y轴偏移量 ctx.shadowColor = &#x27;#b83b5e&#x27; // 阴影颜色 ctx.shadowBlur = 10 // 阴影模糊度，默认0 const text = &#x27;雷猴&#x27; ctx.font = &#x27;bold 100px 黑体&#x27; ctx.fillStyle = &#x27;#fce38a&#x27; ctx.fillText(text, 10, 100)&lt;/script&gt; 路径在 Canvas 从入门到劝朋友放弃（图解版） —— 新开路径 中我讲到 新开路径 和 关闭路径 的用法，本节会在上篇的基础上丰富更多使用细节。 本节要讲的是 beginPath(): 新开路径 closePath(): 关闭路径 isPointInPath(): 判断某个点是否在当前路径内 beginPath()beginPath() 方法是用来开辟一条新的路径，这个方法会将当前路径之中的所有子路径都清除掉，以此来重置当前路径。 如果你的画布上有几个基础图形（直线、多边形、圆形、弧、贝塞尔曲线），如果样式相互之间受到影响，那你可以立刻想想在绘制新图形之前是不是忘了使用 beginPath() 。 先举几个例子说明一下。 污染：颜色、线条粗细受到污染后面的样式覆盖了前面的样式。 12345678910111213141516171819&lt;canvas id=&quot;c&quot; width=&quot;300&quot; height=&quot;200&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const context = document.getElementById(&#x27;c&#x27;) const ctx = context.getContext(&#x27;2d&#x27;) // 第一条线，粉色 ctx.moveTo(50, 40) ctx.lineTo(150, 40) ctx.strokeStyle = &#x27;pink&#x27; // 粉色描边 ctx.stroke() // 第二条线，红色 ctx.moveTo(50, 80) ctx.lineTo(150, 80) ctx.strokeStyle = &#x27;red&#x27; // 红色描边 ctx.lineWidth = 10 // 表面粗细 ctx.stroke()&lt;/script&gt; 污染：图形路径污染比如画布上有一条直线和一个圆形，不使用 beginPath() 开辟新路径的话，它们可能会“打架”。 1234567891011121314151617&lt;canvas id=&quot;c&quot; width=&quot;300&quot; height=&quot;200&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const context = document.getElementById(&#x27;c&#x27;) const ctx = context.getContext(&#x27;2d&#x27;) // 第一条线，粉色 ctx.moveTo(50, 40) ctx.lineTo(150, 40) ctx.strokeStyle = &#x27;pink&#x27; // 粉色描边 ctx.stroke() // 圆形 ctx.arc(150, 120, 40, 0, 360 * Math.PI / 180) ctx.lineWidth = 4 ctx.stroke()&lt;/script&gt; 明明直线和圆形是没有交集的，为什么会有一条倾斜的线把两个元素连接起来？ 解决办法除了上面两种情况外，可能还有其他更加奇怪的情况（像极喝醉了假酒），都可以先考虑是不是要使用 beginPath() 。 比如这样做。 1234567891011121314151617181920&lt;canvas id=&quot;c&quot; width=&quot;300&quot; height=&quot;200&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const context = document.getElementById(&#x27;c&#x27;) const ctx = context.getContext(&#x27;2d&#x27;) // 第一条线，粉色 ctx.moveTo(50, 40) ctx.lineTo(150, 40) ctx.strokeStyle = &#x27;pink&#x27; // 粉色描边 ctx.lineWidth = 10 ctx.stroke() // 圆形 ctx.beginPath() // 开辟新的路径 ctx.arc(150, 120, 40, 0, 360 * Math.PI / 180) ctx.strokeStyle = &#x27;skyblue&#x27; // 蓝色描边 ctx.lineWidth = 4 ctx.stroke()&lt;/script&gt; 在使用 arc 或者 moveTo 方法之前加上一句 ctx.beginPath() 就可以有效解决以上问题。 这个例子中，如果没用 ctx.beginPath() ，canvas 就会以为 线 和 圆形 都属于同一个路径，所以在画圆形时，下笔的时候就会把线的“结束点”和圆的“起点”相连起来。 stroke() 和 fill() 都是以最近的 beginPath() 后面所定义的状态样式为基础进行绘制的。 注意事项前面的样式会覆盖后面元素的默认样式，即使使用了 beginPath() 。 12345678910111213141516171819&lt;canvas id=&quot;c&quot; width=&quot;300&quot; height=&quot;200&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const context = document.getElementById(&#x27;c&#x27;) const ctx = context.getContext(&#x27;2d&#x27;) // 第一条线，粉色 ctx.moveTo(50, 40) ctx.lineTo(150, 40) ctx.strokeStyle = &#x27;pink&#x27; // 粉色描边 ctx.lineWidth = 10 // 表面粗细 ctx.stroke() // 第二条线，红色 ctx.beginPath() ctx.moveTo(50, 80) ctx.lineTo(150, 80) ctx.stroke()&lt;/script&gt; 第一条先设置了 strokeStyle 和 lineWidth ，第二条线并没有设置这两个属性，即使在绘制第二条线的开始时使用了 ctx.beginPath() ，第二条线也会使用第一条线的 strokeStyle 和 lineWidth 。除非第二条线自己也有设置这两个属性，不然就会沿用之前的配置项。 “特殊情况”还要补充一个 “特殊情况”。 1234567891011121314151617&lt;canvas id=&quot;c&quot; width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const cnv = document.getElementById(&#x27;c&#x27;) const ctx = cnv.getContext(&#x27;2d&#x27;) // 第一条线，粉色 ctx.moveTo(50, 30) ctx.lineTo(150, 30) ctx.strokeStyle = &#x27;pink&#x27; // 粉色描边 ctx.lineWidth = 10 // 描边粗细 ctx.stroke() // 矩形 ctx.strokeStyle = &#x27;red&#x27; // 红色描边 ctx.strokeRect(50, 50, 200, 100)&lt;/script&gt; 这个例子中，绘制矩形 rect 前并没有用 beginPath() ，但矩形的红色描边并没有影响直线的粉色描边。 其实还不止 strokeRect() ，还有 fillRect()、strokeText()、fillText() 都不会影响其他图形，这些方法都只会绘制图形，不会影响原本路径。 closePath()closePath() 方法可以关闭当前路径，它可以显示封闭某段开放的路径。这个方法常用于关闭圆弧路径或者由圆弧、线段创建出来的开放路径。 closePath() 是关闭路径，并不是结束路径。 关闭路径，指的是连接起点与终点，也就是能够自动封闭图形。 结束路径，指的是开始新的路径。 基础用法举个例子会更直观 1234567891011&lt;canvas id=&quot;c&quot; width=&quot;300&quot; height=&quot;200&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const context = document.getElementById(&#x27;c&#x27;) const ctx = context.getContext(&#x27;2d&#x27;) ctx.moveTo(50, 40) ctx.lineTo(150, 40) ctx.lineTo(150, 140) ctx.stroke()&lt;/script&gt; 上面的代码通过 moveTo 和 lineTo 画了3个点，使用 stroke() 方法把这3个点连起来，就形成了上图效果。 但如果此时在 stroke() 前使用 closePath() 方法，最终出来的路径将自动闭合（将起点和终点连接起来）。 123456789101112&lt;canvas id=&quot;c&quot; width=&quot;300&quot; height=&quot;200&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const context = document.getElementById(&#x27;c&#x27;) const ctx = context.getContext(&#x27;2d&#x27;) ctx.moveTo(50, 40) ctx.lineTo(150, 40) ctx.lineTo(150, 140) ctx.closePath() // 关闭路径 ctx.stroke()&lt;/script&gt; 注意事项看到上面的例子后，可能有些工友会觉得使用 ctx.lineTo(50, 40) 连接回起点也有同样效果。 123456// 省略部分代码ctx.moveTo(50, 40)ctx.lineTo(150, 40)ctx.lineTo(150, 140)ctx.lineTo(50, 40)ctx.stroke() 确实在描边为1像素时看上去效果是差不多的，但如果此时将 lineWidth 的值设置得大一点，就能看到明显区别。 1234567// 省略部分代码ctx.lineWidth = 10ctx.moveTo(50, 40)ctx.lineTo(150, 40)ctx.lineTo(150, 140)ctx.lineTo(50, 40) // 连接回起点ctx.stroke() 如果用 closePath() 自动闭合路径的话，会出现以下效果 1234567// 省略部分代码ctx.lineWidth = 10ctx.moveTo(50, 40)ctx.lineTo(150, 40)ctx.lineTo(150, 140)ctx.closePath() // 关闭路径ctx.stroke() 本文到此就完结了，但 canvas 的知识点还没完，还有很多很多，根本学不完的那种。 接下来 本专栏 的文章会偏向于 知识点 + 案例 的方式讲解 canvas 。 代码仓库⭐雷猴 Canvas 推荐阅读👍《Canvas 从入门到劝朋友放弃（图解版）》 👍《Canvas 10款基础滤镜（原理篇）》 👍《Fabric.js 从入门到膨胀》 👍《『Three.js』起飞！》 👍《p5.js 光速入门》 👍《SVG 从入门到后悔，怎么不早点学起来（图解版）》","tags":["Canvas"],"categories":["Canvas"]},{"title":"强大的canvas库Fabric.js基础图解","path":"/2025/03/29/强大的canvas库Fabric-js基础图解/","content":"转载自: https://juejin.cn/post/7026941253845516324 简介Fabric.js 简介 Fabric.js 是一个功能强大且操作简单的 Javascript HTML5 canvas 工具库。 如果你需要用 canvas 做特效，那我推荐你使用 Fabric.js ，因为 Fabric.js 语法更加简单易用，而且还提供了很多交互类的 api。 Fabric.js 简化了很多 Canvas 里的概念，代码看上去也更加语义化。 Fabric.js 能做什么？ 可以打开 『Fabric.js 官网首页』 直接看例子，也可以看看 『Fabric.js Demos』 查看更炫酷的例子。 本文简介如果是 0基础 的读者，希望可以从头读到尾，读完起码大概知道 Fabric.js 有哪些功能。 本文是根据我的学习过程来编写的，只要跟着本文一步一步操作，一定可以入门 Fabric.js ，同时还能改善您的睡眠质量、解决毛发过多等诸多问题。 由于我使用 Fabric.js 的时间不长，这份笔记在各个知识点的内容肯定不够全面的，也不一定完全正确。读者们如果发现本文存在不正确的地方请大胆指出，我会改的~ 本文适合人群： 有原生三件套基础的开发者 最好有 canvas 基础（这是加分项，完全没有也没关系的） 本文主要讲解 Fabric.js 基础，包括： 画布的基本操作 基础图形绘制方法（矩形、圆形、三角形、椭圆、多边形、线段等） 图片和滤镜的使用 文本和文本框 动画 分组和打散分组 基础事件 自由绘画 裁剪 序列化和反序列化 …… 除此之外，还会讲一些进阶一点的操作，比如： 自定义操作角样式和状态 自定义控件 复制粘贴图形 使用事件方式操作图形和分组 …… 除了上述内容外，我还会根据日后的工作中整理出更多常用和好玩的操作，本文即学习仓库会不定期更新！！！ 相关链接『Fabric.js npm地址』 『Fabric.js github地址』 🎁本文案例在线预览 🎁本文所有案例仓库地址 【欢迎Star，不定期更新！！！】 开发环境搭建环境和版本说明 本文使用 Fabric.js 的版本是 4.6。 本文的开发环境是使用 Vite 构建的 Vue 3.2 项目。 没有 Vite 和 Vue3.2 基础的同学也不用怕，因为 Vite 真的足够简单。 本文的目的是讲解 Fabric.js ，所以用到 Vue 3.2 的地方其实很少，用到时我也会有详细说明。 如果你不打算使用 Vite 和 Vue 3.2 也没关系，用你喜欢的方式去搭建项目即可。 现在只需跟着以下步骤搭建项目即可。 搭建环境（Vite + Vue3）Vite 官网 Vue3 官网 如果你不想使用 Vite + Vue3 的话，可以跳过本节。 我也建议你直接使用原生 (HTML+CSS+JS) 的方式直接学习 Fabric.js，因为这样上手速度最快。 1. 搭建Vite项目1npm init @vitejs/app 2. 给项目起个名，并选择 Vue 之后会让你选 vue 或者 vue + ts，我选择了 vue ，你随意。 为什么不选 ts ？因为一人开发的练手项目使用 ts 有点得不偿失。 3. 初始化项目其实做完上一步就会给出提示（3条命令），跟着敲完就能运行项目了 12345678# 进入项目目录cd fabric-demo# 初始化项目npm install# 运行项目npm run dev 如果 npm 太慢的话，可以使用 cnpm 。 如果不知道 cnpm 怎么搞，请自行百度。 安装Fabric.js方式1：CDN1&lt;script src=&quot;https://unpkg.com/fabric@4.6.0/dist/fabric.min.js&quot;&gt;&lt;/script&gt; 你可以使用 CDN 的方式引入，因为这样对学习来说是最快捷的。 方式2：npm本文使用该方法！！！ 1npm i fabric --save 安装完后，package.json 会出现箭头指向的那行代码。 起步只需 3个操作 就能展示点东西了。 1. 新建页面并引入 Fabric.js如果是原生项目，使用 &lt;script&gt; 标签引入即可： 1&lt;script src=&quot;https://unpkg.com/fabric@4.6.0/dist/fabric.min.js&quot;&gt;&lt;/script&gt; 本文使用了 Vite 构建的项目，所以可以使用 import 引入 1import &#123; fabric &#125; from &#x27;fabric&#x27; 2. 创建 canvas 容器在 HTML 中创建 &lt;canvas&gt;，并设置容器的 id 和 宽高，width/height 1&lt;canvas width=&quot;400&quot; height=&quot;400&quot; id=&quot;c&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt; 这里创建了一个 canvas 容器，**id&#x3D;”c”**。 指定长宽都为 400px ，值得注意的是，这里不需要加 px 这个单位。 style=&quot;border: 1px solid #ccc;&quot; 这句其实可以不加，这里只是为了在浏览器看到 canvas 元素到底在哪。 3. 使用 fabric 接管容器，并画一个矩形在 JS 中实例化 fabric ，之后就可以使用 fabric 的 api 管理 canvas 了。 123456789101112131415161718192021222324252627&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27; // 引入 fabricfunction init() &#123; const canvas = new fabric.Canvas(&#x27;c&#x27;) // 这里传入的是canvas的id // 创建一个长方形 const rect = new fabric.Rect(&#123; top: 30, // 距离容器顶部 30px left: 30, // 距离容器左侧 30px width: 100, // 宽 100px height: 60, // 高 60px fill: &#x27;red&#x27; // 填充 红色 &#125;) // 在canvas画布中加入矩形（rect）。add是“添加”的意思 canvas.add(rect)&#125;// 需要在页面容器加载完才能开始初始化（页面加载完才找到 canvas 元素）// onMounted 是 Vue3 提供的一个页面生命周期函数：实例被挂载后调用。// onMounted 官方文档说明：https://v3.cn.vuejs.org/guide/composition-api-lifecycle-hooks.htmlonMounted(() =&gt; &#123; init() // 执行初始化函数&#125;)&lt;/script&gt; 详情请看代码中每一行注释。 &lt;script setup&gt; 是 Vue 3.2 的一个新语法，普通项目直接使用 &lt;script&gt; 就行了。 就算我不写备注也可以看出 Fabric.js 的代码是极具语义化的，看单词就大概能猜出代码效果。 如果是用原生的 canvas 方法来写，没了解过的同学根本看不懂在写啥。 画布Fabric.js 的画布操作性是非常强的，这里我列举几个常用例子，其他操作可以查看官方文档。 『Fabric.js 画布操作 - 文档』 🎁 本节案例在线预览 - 画布 🎁 本节代码仓库 基础版（可交互） 基础版就是“起步”章节所说的那个例子。 123456789101112131415161718192021222324252627&lt;template&gt; &lt;canvas width=&quot;400&quot; height=&quot;400&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27; // 引入 fabricfunction init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) // 这里传入的是canvas元素的id // 创建一个长方形 const rect = new fabric.Rect(&#123; top: 100, // 距离容器顶部 100px left: 100, // 距离容器左侧 100px width: 30, // 矩形宽度 30px height: 30, // 矩形高度 30px fill: &#x27;red&#x27; // 填充 红色 &#125;) canvas.add(rect) // 将矩形添加到 canvas 画布里&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 不可交互 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;canvas width=&quot;400&quot; height=&quot;400&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27; // 引入 fabricfunction init() &#123; // 使用 StaticCanvas 创建一个不可操作的画布 const canvas = new fabric.StaticCanvas(&#x27;canvas&#x27;) // 这里传入的是canvas元素的id // 创建一个长方形 const rect = new fabric.Rect(&#123; top: 100, // 距离容器顶部 100px left: 100, // 距离容器左侧 100px width: 30, // 矩形宽度 30px height: 30, // 矩形高度 30px fill: &#x27;red&#x27; // 填充 红色 &#125;) canvas.add(rect) // 将矩形添加到 canvas 画布里&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 创建不可交互的画布，其实只需把 new fabric.Canvas 改成 new fabric.StaticCanvas 即可。 在js设定画布参数 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27; // 引入 fabricfunction init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;, &#123; width: 300, // 画布宽度 height: 300, // 画布高度 backgroundColor: &#x27;#eee&#x27; // 画布背景色 &#125;) // 圆形 const circle = new fabric.Circle(&#123; radius: 30, // 圆的半径 top: 20, // 距离容器顶部 20px left: 20, // 距离容器左侧 20px fill: &#x27;pink&#x27; // 填充 粉色 &#125;) canvas.add(circle) // 将圆形添加到 canvas 画布里&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; new fabric.Canvas 的第二个参数是用来设置画布基础功能的。更多配置参数可以查看 『官方文档』。 使用背景图 123456789101112131415161718192021222324&lt;template&gt; &lt;canvas width=&quot;400&quot; height=&quot;400&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) // 设置背景图 // 参数1：背景图资源（可以引入本地，也可以使用网络图） // 参数2：设置完背景图执行以下重新渲染canvas的操作，这样背景图就会展示出来了 canvas.setBackgroundImage( &#x27;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27d1b4e5f8824198b6d51a2b1c2d0d75~tplv-k3u1fbpfcp-zoom-crop-mark:400:400:400:400.awebp&#x27;, canvas.renderAll.bind(canvas) )&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; setBackgroundImage 这个很好懂，设置背景图片。 需要注意的是，在 Fabric.js 里使用 gif 只会渲染第一帧。 旋转背景图 123456789101112131415161718192021222324252627&lt;template&gt; &lt;canvas width=&quot;400&quot; height=&quot;400&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) // 设置背景图 // 参数1：背景图资源（可以引入本地，也可以使用网络图） // 参数2：设置完背景图执行以下重新渲染canvas的操作，这样背景图就会展示出来了 canvas.setBackgroundImage( &#x27;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27d1b4e5f8824198b6d51a2b1c2d0d75~tplv-k3u1fbpfcp-zoom-crop-mark:400:400:400:400.awebp&#x27;, canvas.renderAll.bind(canvas), &#123; angle: 15 // 旋转背景图 &#125; )&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; setBackgroundImage 还有第三个参数，嘿嘿嘿没想到吧 第三个参数除了旋转，还可以设置 scaleX、scaleY 之类的操作。 更多设置可以查看 『文档』 。 但这个例子存在一个问题，如果图片的尺寸没 canvas 容器大，就填不满，否则就溢出（只显示图片的局部）。 解决方案请看下一个案例。 拉伸背景图 12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;canvas width=&quot;400&quot; height=&quot;400&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) // fabric.Image.fromURL：加载图片的api // 第一个参数：图片地址（可以是本地的，也可以是网络图） // 第二个参数：图片加载的回调函数 fabric.Image.fromURL( &#x27;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27d1b4e5f8824198b6d51a2b1c2d0d75~tplv-k3u1fbpfcp-zoom-crop-mark:400:400:400:400.awebp&#x27;, (img) =&gt; &#123; // 设置背景图 canvas.setBackgroundImage( img, canvas.renderAll.bind(canvas), &#123; scaleX: canvas.width / img.width, // 计算出图片要拉伸的宽度 scaleY: canvas.height / img.height // 计算出图片要拉伸的高度 &#125; ) &#125; )&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 这个例子使用了 fabric.Image.fromURL 这个 api 来加载图片，第一个参数是图片地址，第二个参数是回调函数。 拿到图片的参数和画布的宽高进行计算，从而使图片充满全屏。 重复背景图 123456789101112131415161718192021&lt;template&gt; &lt;canvas width=&quot;400&quot; height=&quot;400&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) canvas.setBackgroundColor(&#123; source: &#x27;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27d1b4e5f8824198b6d51a2b1c2d0d75~tplv-k3u1fbpfcp-zoom-crop-mark:40:40:40:40.awebp&#x27;, repeat: &#x27;repeat&#x27; &#125;, canvas.renderAll.bind(canvas))&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 这个例子使用的图片尺寸是比较小的，所以在 setBackgroundColor 的第3个参数中设置了 repeat: &#39;repeat&#39; ，表示重复渲染图片。 重叠影象 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;canvas width=&quot;400&quot; height=&quot;375&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;import jailCellBars from &#x27;@/assets/images/jail_cell_bars.png&#x27; // 引入背景图function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) canvas.add( new fabric.Circle(&#123; radius: 30, // 圆形半径 fill: &#x27;#f55&#x27;, top: 70, left: 70 &#125;) ) // 设置覆盖图像的画布 canvas.setOverlayImage( // setOverlayImage(image, callback, optionsopt) jailCellBars, // 图片，script开头import进来的 canvas.renderAll.bind(canvas) )&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 值得注意的2点： 使用 canvas.setOverlayImage 代替原本的 canvas.setBackgroundImage 。 所使用的图片最好是带透明层的 png ，这样就能展示案例所示的效果，背景图叠在图案元素上面。 🎁 本例所使用的图片地址 基础图形Fabric.js 提供了以下几种基础图形： 『矩形』 『圆形』 『椭圆形』 『三角形』 『线段』 『折线』 『多边形』 🎁 本节案例在线预览 - 基础图形 🎁 本节代码仓库 矩形 123456789101112131415161718192021222324252627&lt;template&gt; &lt;canvas width=&quot;400&quot; height=&quot;375&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) // 绑定canvas，传入id const rect = new fabric.Rect(&#123; top: 100, // 距离容器顶部 100px left: 100, // 距离容器左侧 100px fill: &#x27;orange&#x27;, // 填充 橙色 width: 100, // 宽度 100px height: 100 // 高度 100px &#125;) // 将矩形添加到画布中 canvas.add(rect)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 使用 new fabric.Rect 创建 矩形。 圆角矩形 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;canvas width=&quot;400&quot; height=&quot;375&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) // 绑定canvas，传入id const rect = new fabric.Rect(&#123; top: 100, // 距离容器顶部 100px left: 100, // 距离容器左侧 100px fill: &#x27;orange&#x27;, // 填充 橙色 width: 100, // 宽度 100px height: 100, // 高度 100px rx: 20, // x轴的半径 ry: 20 // y轴的半径 &#125;) // 将矩形添加到画布中 canvas.add(rect)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 画圆角矩形，需要添加 rx 和 ry，这两个属性的值可以不一样，如果知道 css 圆角的原理，其实对 rx 和 ry 不难理解。 自己修改一下这两个值看看效果理解会更深刻。 圆形 123456789101112131415161718192021222324&lt;template&gt; &lt;canvas width=&quot;400&quot; height=&quot;375&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) const circle = new fabric.Circle(&#123; top: 100, left: 100, radius: 50, // 圆的半径 50 fill: &#x27;green&#x27; &#125;) canvas.add(circle)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 使用 new fabric.Circle 创建圆形。 圆形需要使用 radius 设置半径大小。 椭圆形 12345678910111213141516171819202122232425&lt;template&gt; &lt;canvas width=&quot;400&quot; height=&quot;375&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) const ellipse = new fabric.Ellipse(&#123; top: 20, left: 20, rx: 70, ry: 30, fill: &#x27;hotpink&#x27; &#125;) canvas.add(ellipse)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 需要使用 new fabric.Ellipse 创建 椭圆。 和圆形不同，椭圆不需要设置 radius ，但要设置 rx 和 ry。 当 rx &gt; ry ：椭圆是横着的 当 rx &lt; ry：椭圆是竖着的 当 rx &#x3D; ry： 看上去就是个圆形 三角形 12345678910111213141516171819202122232425&lt;template&gt; &lt;canvas width=&quot;400&quot; height=&quot;375&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) const triangle = new fabric.Triangle(&#123; top: 100, left: 100, width: 80, // 底边长度 height: 100, // 底边到对角的距离 fill: &#x27;blue&#x27; &#125;) canvas.add(triangle)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 使用 new fabric.Triangle 创建三角形，三角形是需要给定 “底和高” 的。 线段 123456789101112131415161718192021222324252627&lt;template&gt; &lt;canvas width=&quot;400&quot; height=&quot;375&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) const line = new fabric.Line( [ 10, 10, // 起始点坐标 200, 300 // 结束点坐标 ], &#123; stroke: &#x27;red&#x27;, // 笔触颜色 &#125; ) canvas.add(line)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 使用 new fabric.Line 创建线段。 new fabric.Line 需要传入2个参数。 第一个参数是 数组 ，数组需要传4个值，前2个值是起始坐标的x和y，后2个值是结束坐标的x和y。 第二个参数是 线段的样式，要设置线段的颜色，需要使用 stroke 。 折线 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;canvas width=&quot;400&quot; height=&quot;375&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) const polyline = new fabric.Polyline([ &#123;x: 30, y: 30&#125;, &#123;x: 150, y: 140&#125;, &#123;x: 240, y: 150&#125;, &#123;x: 100, y: 30&#125; ], &#123; fill: &#x27;transparent&#x27;, // 如果画折线，需要填充透明 stroke: &#x27;#6639a6&#x27;, // 线段颜色：紫色 strokeWidth: 5 // 线段粗细 5 &#125;) canvas.add(polyline)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 使用 new fabric.Polyline 创建线段 。 new fabric.Polyline 需要传入2个参数。 第一个参数是数组，描述线段的每一个点 第二个参数用来描述线段样式 需要注意的是， fill 设置成透明才会显示成线段，如果不设置，会默认填充黑色，如下图所示： 你也可以填充自己喜欢的颜色，new fabric.Polyline 是不会自动把 起始点 和 结束点 自动闭合起来的。 多边形 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;canvas width=&quot;400&quot; height=&quot;375&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) const polygon = new fabric.Polygon([ &#123;x: 30, y: 30&#125;, &#123;x: 150, y: 140&#125;, &#123;x: 240, y: 150&#125;, &#123;x: 100, y: 30&#125; ], &#123; fill: &#x27;#ffd3b6&#x27;, // 填充色 stroke: &#x27;#6639a6&#x27;, // 线段颜色：紫色 strokeWidth: 5 // 线段粗细 5 &#125;) canvas.add(polygon)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 使用 new fabric.Polygon 绘制多边形，用法和 new fabric.Polyline 差不多，但最大的不同点是 new fabric.Polygon 会自动把 起始点 和 结束点 连接起来。 绘制路径『Fabric.js 路径Path - 文档』 🎁 本节案例在线预览 - 绘制路径 🎁 本节代码仓库 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;canvas width=&quot;400&quot; height=&quot;375&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) // 绘制路径 const path = new fabric.Path(&#x27;M 0 0 L 200 100 L 170 200 z&#x27;) path.set(&#123; top: 50, // 距离容器顶部距离 50px left: 50, // 距离容器左侧距离 50px fill: &#x27;hotpink&#x27;, // 填充 亮粉色 opacity: 0.5, // 不透明度 50% stroke: &#x27;black&#x27;, // 描边颜色 黑色 strokeWidth: 10 // 描边粗细 10px &#125;) canvas.add(path)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 使用 new fabric.Path 创建路径。 M：可以理解为新的起始点x，y坐标 L：每个折点的x，y坐标 z：自动闭合（自动把结束点和起始点连接起来） 文本Fabric.js 有3类跟文本相关的 api。 普通文本 可编辑文本 文本框 普通文本 Text『Fabric.js 文本 - 文档』 🎁 本节案例在线预览 - 普通文本 🎁 本节代码仓库 12345678910111213141516171819&lt;template&gt; &lt;canvas width=&quot;400&quot; height=&quot;400&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) const text = new fabric.Text(&#x27;雷猴啊&#x27;) canvas.add(text)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 使用 new fabric.Text 创建文本，传入第一个参数就是文本内容。 new fabric.Text 还支持第二个参数，可以设置文本样式，这方面内容将在下一章讲到，往下滑动页面就能见到。 可编辑文本 IText『Fabric.js 可编辑的文本 - 文档』 🎁 本节案例在线预览 - 可编辑的文本 🎁 本节代码仓库 12345678910111213141516171819&lt;template&gt; &lt;canvas width=&quot;400&quot; height=&quot;400&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) const itext = new fabric.IText(&#x27;雷猴啊&#x27;) canvas.add(itext)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 使用 new fabric.IText 可以创建可编辑文本，用法和 new fabric.Text 一样。 IText 比 Text 多了个大写 “I” 在首字母上。 文本框 Textbox『Fabric.js 文本框 - 文档』 🎁 本节案例在线预览 - 文本框 🎁 本节代码仓库 123456789101112131415161718192021&lt;template&gt; &lt;canvas width=&quot;400&quot; height=&quot;400&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) const textbox = new fabric.Textbox(&#x27;Lorum ipsum dolor sit amet&#x27;, &#123; width: 250 &#125;) canvas.add(textbox)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 使用 new fabric.Textbox 可以创建文本框。 new fabric.Textbox 第二个参数是对象，使用 width 可以设定了文本框的宽度，文本内容超过设定的宽度会自动换行。 new fabric.Textbox 的内容同样是可编辑的。 基础样式图形常用样式其实样式属性是非常多的，这里只列举常用的属性，其他属性可以自行查阅官方文档。 本例以圆形为例（不要在意配色，我随便输入颜色演示一下） 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;template&gt; &lt;canvas width=&quot;400&quot; height=&quot;400&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) const circle = new fabric.Circle(&#123; top: 100, left: 100, radius: 50, // 半径：50px backgroundColor: &#x27;green&#x27;, // 背景色：绿色 fill: &#x27;orange&#x27;, // 填充色：橙色 stroke: &#x27;#f6416c&#x27;, // 边框颜色：粉色 strokeWidth: 5, // 边框粗细：5px strokeDashArray: [20, 5, 14], // 边框虚线规则：填充20px 空5px 填充14px 空20px 填充5px …… shadow: &#x27;10px 20px 6px rgba(10, 20, 30, 0.4)&#x27;, // 投影：向右偏移10px，向下偏移20px，羽化6px，投影颜色及透明度 transparentCorners: false, // 选中时，角是被填充了。true 空心；false 实心 borderColor: &#x27;#16f1fc&#x27;, // 选中时，边框颜色：天蓝 borderScaleFactor: 5, // 选中时，边的粗细：5px borderDashArray: [20, 5, 10, 7], // 选中时，虚线边的规则 cornerColor: &quot;#a1de93&quot;, // 选中时，角的颜色是 青色 cornerStrokeColor: &#x27;pink&#x27;, // 选中时，角的边框的颜色是 粉色 cornerStyle: &#x27;circle&#x27;, // 选中时，叫的属性。默认rect 矩形；circle 圆形 cornerSize: 20, // 选中时，角的大小为20 cornerDashArray: [10, 2, 6], // 选中时，虚线角的规则 selectionBackgroundColor: &#x27;#7f1300&#x27;, // 选中时，选框的背景色：朱红 padding: 40, // 选中时，选择框离元素的内边距：40px borderOpacityWhenMoving: 0.6, // 当对象活动和移动时，对象控制边界的不透明度 &#125;) canvas.add(circle)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 上面这个例子的样式分为正常状态和被选中状态，详情请看代码注释。 文本常用样式🎁 本节案例在线预览 - 文本样式 🎁 本节代码仓库 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;template&gt; &lt;canvas width=&quot;400&quot; height=&quot;400&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) const text = new fabric.Text(&#x27;雷猴&#x27;, &#123; top: 40, left: 40, fontSize: 120, backgroundColor: &#x27;green&#x27;, // 背景色：绿色 fill: &#x27;orange&#x27;, // 填充色：橙色 stroke: &#x27;#f6416c&#x27;, // 边框颜色：粉色 strokeWidth: 3, // 边框粗细：3px strokeDashArray: [20, 5, 14], // 边框虚线规则：填充20px 空5px 填充14px 空20px 填充5px …… shadow: &#x27;10px 20px 6px rgba(10, 20, 30, 0.4)&#x27;, // 投影：向右偏移10px，向下偏移20px，羽化6px，投影颜色及透明度 transparentCorners: false, // 选中时，角是被填充了。true 空心；false 实心 borderColor: &#x27;#16f1fc&#x27;, // 选中时，边框颜色：天蓝 borderScaleFactor: 5, // 选中时，边的粗细：5px borderDashArray: [20, 5, 10, 7], // 选中时，虚线边的规则 cornerColor: &quot;#a1de93&quot;, // 选中时，角的颜色是 青色 cornerStrokeColor: &#x27;pink&#x27;, // 选中时，角的边框的颜色是 粉色 cornerStyle: &#x27;circle&#x27;, // 选中时，叫的属性。默认rect 矩形；circle 圆形 cornerSize: 20, // 选中时，角的大小为20 cornerDashArray: [10, 2, 6], // 选中时，虚线角的规则 selectionBackgroundColor: &#x27;#7f1300&#x27;, // 选中时，选框的背景色：朱红 padding: 40, // 选中时，选择框离元素的内边距：40px borderOpacityWhenMoving: 0.6, // 当对象活动和移动时，对象控制边界的不透明度 &#125;) canvas.add(text)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 除此之外，还可以配置 上划线 、下划线 、删除线 、左对齐 、 右对齐 、 居中对齐 、 行距 等。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;template&gt; &lt;canvas width=&quot;600&quot; height=&quot;400&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) // 上划线 const overline = new fabric.Text(&#x27;上划线&#x27;, &#123; top: 30, left: 10, fontSize: 20, overline: true, // 上划线 &#125;) // 下划线 const underline = new fabric.Text(&#x27;下划线&#x27;, &#123; top: 30, left: 100, fontSize: 20, underline: true, // 下划线 &#125;) // 删除线 const linethrough = new fabric.Text(&#x27;删除线&#x27;, &#123; top: 30, left: 200, fontSize: 20, linethrough: true, // 删除线 &#125;) // 左对齐 const msg1 = &#x27;左 左左 左对齐&#x27; const left = new fabric.Text(msg1, &#123; top: 100, left: 10, fontSize: 16, textAlign: &#x27;left&#x27;, // 左对齐 &#125;) // 居中对齐 const msg2 = &#x27;中 中中 居中对齐&#x27; const center = new fabric.Text(msg2, &#123; top: 100, left: 100, fontSize: 16, textAlign: &#x27;center&#x27;,// 居中对齐 &#125;) // 右对齐 const msg3 = &#x27;右 右右 右对齐&#x27; const right = new fabric.Text(msg3, &#123; top: 100, left: 200, fontSize: 16, textAlign: &#x27;right&#x27;, // 右对齐 &#125;) // 文本内容 const msg4 = &quot;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labo&quot; const lineHeight1 = new fabric.Text(msg4, &#123; top: 250, left: 10, fontSize: 16, lineHeight: 1, // 行高 &#125;) const lineHeight2 = new fabric.Text(msg4, &#123; top: 250, left: 300, fontSize: 16, lineHeight: 2, // 行高 &#125;) canvas.add( overline, underline, linethrough, left, center, right, lineHeight1, lineHeight2 )&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 上面的上划线、下划线、删除线的配置，可以同时使用。 渐变『Fabric.js 渐变 - 文档』 🎁 本节案例在线预览 - 渐变 🎁 本节代码仓库 线性渐变 12345678910111213141516171819202122232425262728293031323334353637383940&lt;template&gt; &lt;canvas width=&quot;600&quot; height=&quot;600&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; let canvas = new fabric.Canvas(&#x27;canvas&#x27;) // 实例化fabric，并绑定到canvas元素上 // 圆 let circle = new fabric.Circle(&#123; left: 100, top: 100, radius: 50, &#125;) // 线性渐变 let gradient = new fabric.Gradient(&#123; type: &#x27;linear&#x27;, // linear or radial gradientUnits: &#x27;pixels&#x27;, // pixels or pencentage 像素 或者 百分比 coords: &#123; x1: 0, y1: 0, x2: circle.width, y2: 0 &#125;, // 至少2个坐标对（x1，y1和x2，y2）将定义渐变在对象上的扩展方式 colorStops:[ // 定义渐变颜色的数组 &#123; offset: 0, color: &#x27;red&#x27; &#125;, &#123; offset: 0.2, color: &#x27;orange&#x27; &#125;, &#123; offset: 0.4, color: &#x27;yellow&#x27; &#125;, &#123; offset: 0.6, color: &#x27;green&#x27; &#125;, &#123; offset: 0.8, color: &#x27;blue&#x27; &#125;, &#123; offset: 1, color: &#x27;purple&#x27; &#125;, ] &#125;) circle.set(&#x27;fill&#x27;, gradient); canvas.add(circle)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 径向渐变 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;template&gt; &lt;canvas width=&quot;600&quot; height=&quot;600&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; let canvas = new fabric.Canvas(&#x27;canvas&#x27;) // 实例化fabric，并绑定到canvas元素上 // 圆 let circle = new fabric.Circle(&#123; left: 100, top: 100, radius: 50, &#125;) let gradient = new fabric.Gradient(&#123; type: &#x27;radial&#x27;, coords: &#123; r1: 50, // 该属性仅径向渐变可用，外圆半径 r2: 0, // 该属性仅径向渐变可用，外圆半径 x1: 50, // 焦点的x坐标 y1: 50, // 焦点的y坐标 x2: 50, // 中心点的x坐标 y2: 50, // 中心点的y坐标 &#125;, colorStops: [ &#123; offset: 0, color: &#x27;#fee140&#x27; &#125;, &#123; offset: 1, color: &#x27;#fa709a&#x27; &#125; ] &#125;) circle.set(&#x27;fill&#x27;, gradient); canvas.add(circle)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; r1、r2、x1、y1、x2、y2 这几个参数可以自己修改值然后看看效果，自己亲手改一下会理解得更深刻。 使用图片『Fabric.js 图片 - 文档』 🎁 本节案例在线预览 - 使用图片 🎁 本节代码仓库 方法1：使用HTML的图片 12345678910111213141516171819202122232425262728293031323334353637383940&lt;template&gt; &lt;div&gt; &lt;canvas width=&quot;400&quot; height=&quot;400&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt; &lt;img src=&quot;@/assets/logo.png&quot; id=&quot;logo&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) const imgElement = document.getElementById(&#x27;logo&#x27;) imgElement.onload = function() &#123; let imgInstance = new fabric.Image(imgElement, &#123; left: 100, top: 100, width: 200, height: 200, angle: 50, // 旋转 &#125;) canvas.add(imgInstance) &#125;&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt;&lt;style&gt;#logo &#123; display: none;&#125;&lt;/style&gt; 需要使用 onload 方法监听图片是否加载完成。 只有在图片完全加载后再添加到画布上才能展示出来。 使用该方法，如果不想在画布外展示图片，需要使用 display: none; 把图片隐藏起来。 方法2：使用js引入 123456789101112131415161718192021222324&lt;template&gt; &lt;div&gt; &lt;canvas width=&quot;400&quot; height=&quot;400&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;import logo from &#x27;@/assets/logo.png&#x27; // 引入图片function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) fabric.Image.fromURL(logo, oImg =&gt; &#123; oImg.scale(0.5) // 缩放 canvas.add(oImg) // 将图片加入到画布 &#125;)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 使用 fabric.Image.fromURL 加载图片。 第一个参数是图片资源，可以放入本地图片，也可以放网络图片； 第二个参数是回调函数，图片加载完就可以对图片对象进行操作。 图片滤镜『Fabric.js 图片路径 - 文档』 🎁 本节案例在线预览 - 图片滤镜 🎁 本节代码仓库 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;template&gt; &lt;div&gt; &lt;canvas width=&quot;500&quot; height=&quot;500&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;import gwen from &#x27;@/assets/images/gwen-spider-verse-ah.jpg&#x27;function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) fabric.Image.fromURL(gwen, img =&gt; &#123; img.scale(0.5) // 图片缩小50% canvas.add(img) &#125;) // 单个滤镜 fabric.Image.fromURL(gwen, img =&gt; &#123; img.scale(0.5) // 图片缩小50% img.left = 250 // 添加滤镜 img.filters.push(new fabric.Image.filters.Grayscale()) // 图片加载完成之后，应用滤镜效果 img.applyFilters() canvas.add(img) &#125;) // 叠加滤镜 // “filters”属性是一个数组，我们可以用数组方法执行任何所需的操作：移除滤镜（pop，splice，shift），添加滤镜（push，unshift，splice），甚至可以组合多个滤镜。当我们调用 applyFilters 时，“filters”数组中存在的任何滤镜将逐个应用，所以让我们尝试创建一个既色偏又明亮（Brightness）的图像。 fabric.Image.fromURL(gwen, img =&gt; &#123; img.scale(0.5) // 图片缩小50% // 添加滤镜 img.filters.push( new fabric.Image.filters.Grayscale(), new fabric.Image.filters.Sepia(), //色偏 new fabric.Image.filters.Brightness(&#123; brightness: 0.2 &#125;) //亮度 ) // 图片加载完成之后，应用滤镜效果 img.applyFilters() img.set(&#123; left: 250, top: 250, &#125;) canvas.add(img) &#125;)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 给图片添加滤镜，fabric.Image.fromURL 的回调函数里返回一个图片对象，图片对象可以使用 filters 添加滤镜。 fabric 内置滤镜 BaseFilter 基本过滤器 Blur 模糊 Brightness 亮度 ColorMatrix 颜色矩阵 Contrast 对比 Convolute 卷积 Gamma 伽玛 Grayscale 灰度 HueRotation 色调旋转 Invert 倒置 Noise 噪音 Pixelate 像素化 RemoveColor 移除颜色 Resize 调整大小 Saturation 饱和 Sepia 色偏 转换旋转角度 angle 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;div&gt; &lt;canvas width=&quot;500&quot; height=&quot;500&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) let triangle = new fabric.Triangle(&#123; top: 100, left: 100, width: 80, height: 100, fill: &#x27;blue&#x27;, angle: 30 // 旋转30度 &#125;) canvas.add(triangle)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 缩放 scaleX 和 scaleY 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div&gt; &lt;canvas width=&quot;500&quot; height=&quot;500&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) let triangle = new fabric.Triangle(&#123; top: 100, left: 100, width: 80, height: 100, fill: &#x27;blue&#x27;, scaleX: 2, // x轴方向放大2倍 scaleY: 2 // y轴方向放大2倍 &#125;) canvas.add(triangle)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 反转 scaleX 和 scaleY 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;div&gt; &lt;canvas width=&quot;500&quot; height=&quot;500&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) let triangle = new fabric.Triangle(&#123; top: 100, left: 100, width: 80, height: 100, fill: &#x27;blue&#x27;, scaleY: -1 // scale是负数时，图形会反转 &#125;) canvas.add(triangle)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 平移 top 和 left可以直接设置元素的 top 和 left 进行平移。 可参照前面的例子。 分组『Fabric.js 组 - 文档』 建组🎁 本节案例在线预览 - 建组及操作 🎁 本节代码仓库 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;template&gt; &lt;div&gt; &lt;canvas width=&quot;400&quot; height=&quot;400&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) // 椭圆 const ellipse = new fabric.Ellipse(&#123; top: 20, left: 20, rx: 100, ry: 50, fill: &#x27;#ddd&#x27;, originX: &#x27;center&#x27;, // 旋转x轴：left, right, center originY: &#x27;center&#x27; // 旋转y轴：top, bottom, center &#125;) // 文本 const text = new fabric.Text(&#x27;Hello World&#x27;, &#123; top: 40, left: 20, fontSize: 20, originX: &quot;center&quot;, originY: &quot;center&quot; &#125;) // 建组 const group = new fabric.Group([ellipse, text], &#123; top: 50, // 整组距离顶部100 left: 100, // 整组距离左侧100 angle: -10, // 整组旋转-10deg &#125;) canvas.add(group)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; new fabric.Group 可以创建一个组（其实有点像 Photoshop 里面的组，把多个图层放在同一个组内，实现同步的操作，比如拖拽、缩放等）。 操作组🎁 本节案例在线预览 - 建组及操作 🎁 本节代码仓库 Fabric.js 的组提供了很多方法，这里列一些常用的： getObjects() 返回一组中所有对象的数组 size() 所有对象的数量 contains() 检查特定对象是否在 group 中 item() 组中元素 forEachObject() 遍历组中对象 add() 添加元素对象 remove() 删除元素对象 fabric.util.object.clone() 克隆 我拿其中一个举例：item() 在上一个例子的基础上，把椭圆改成红色，把 “Hello World” 改成 “雷猴，世界”。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;template&gt; &lt;div&gt; &lt;canvas width=&quot;400&quot; height=&quot;400&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) // 椭圆 const ellipse = new fabric.Ellipse(&#123; top: 20, left: 20, rx: 100, ry: 50, fill: &#x27;#ddd&#x27;, originX: &#x27;center&#x27;, // 旋转x轴：left, right, center originY: &#x27;center&#x27; // 旋转y轴：top, bottom, center &#125;) // 文本 const text = new fabric.Text(&#x27;Hello World&#x27;, &#123; top: 40, left: 20, fontSize: 20, originX: &quot;center&quot;, originY: &quot;center&quot; &#125;) // 建组 const group = new fabric.Group([ellipse, text], &#123; top: 50, // 整组距离顶部100 left: 100, // 整组距离左侧100 angle: -10, // 整组旋转-10deg &#125;) // 控制第一个元素（椭圆） group.item(0).set(&#x27;fill&#x27;, &#x27;#ea5455&#x27;) // 控制第二个元素（文本） group.item(1).set(&#123; text: &#x27;雷猴，世界&#x27;, fill: &#x27;#fff&#x27; &#125;) canvas.add(group)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 打散分组🎁 本节案例在线预览 - 建组 和 打散组 🎁 本节代码仓库 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;ungroup&quot;&gt;取消组&lt;/button&gt; &lt;canvas width=&quot;400&quot; height=&quot;400&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;let canvas = null// 初始化function init() &#123; canvas = new fabric.Canvas(&#x27;canvas&#x27;) // 椭圆 const ellipse = new fabric.Ellipse(&#123; top: 20, left: 20, rx: 100, ry: 50, fill: &#x27;#ddd&#x27;, originX: &#x27;center&#x27;, // 旋转x轴：left, right, center originY: &#x27;center&#x27; // 旋转y轴：top, bottom, center &#125;) // 文本 const text = new fabric.Text(&#x27;Hello World&#x27;, &#123; top: 40, left: 20, fontSize: 20, originX: &quot;center&quot;, originY: &quot;center&quot; &#125;) // 建组 const group = new fabric.Group([ellipse, text], &#123; top: 50, // 整组距离顶部100 left: 100, // 整组距离左侧100 angle: -10, // 整组旋转-10deg &#125;) canvas.add(group)&#125;// 取消组function ungroup() &#123; // 判断当前有没有选中元素，如果没有就不执行任何操作 if (!canvas.getActiveObject()) &#123; return &#125; // 判断当前是否选中组，如果不是，就不执行任何操作 if (canvas.getActiveObject().type !== &#x27;group&#x27;) &#123; return &#125; // 先获取当前选中的对象，然后打散 canvas.getActiveObject().toActiveSelection()&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 使用 canvas.getActiveObject() 可以获取画布当前选中的对象，然后再通过 toActiveSelection() 将组打散。 动画『Fabric.js animate - 文档』 🎁 本节案例在线预览 - 动画 🎁 本节代码仓库 绝对值动画先别管什么 绝对值动画 和 相对值动画 ，等学完这节再往下看就知道了。 本节是动画的基础用法。 12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;div&gt; &lt;canvas width=&quot;400&quot; height=&quot;400&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;// 初始化function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) const rect = new fabric.Rect(&#123; left: 100, top: 100, width: 100, height: 100, fill: &#x27;red&#x27; &#125;) // 设置矩形动画 rect.animate(&#x27;angle&#x27;, &quot;-50&quot;, &#123; onChange:canvas.renderAll.bind(canvas), // 每次刷新的时候都会执行 &#125;) canvas.add(rect)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 每个 Fabric 对象都有一个 animate 方法，该方法可以动画化该对象。 用法：animate(动画属性, 动画的结束值, [画的详细信息]) 第一个参数是要设置动画的属性。 第二个参数是动画的结束值。 第三个参数是一个对象，包括: 1234567891011&#123; rom：允许指定可设置动画的属性的起始值（如果我们不希望使用当前值）。 duration：默认为500（ms）。可用于更改动画的持续时间。 onComplete：在动画结束时调用的回调。 easing：缓动功能。&#125; 相对值动画 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;div&gt; &lt;canvas width=&quot;400&quot; height=&quot;400&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;// 初始化function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) const rect = new fabric.Rect(&#123; left: 100, top: 100, width: 100, height: 100, fill: &#x27;red&#x27; &#125;) // 请注意第二个参数：+=360 rect.animate(&#x27;angle&#x27;, &#x27;+=360&#x27;, &#123; onChange:canvas.renderAll.bind(canvas), // 每次刷新的时候都会执行 duration: 2000, // 执行时间 easing: fabric.util.ease.easeOutBounce, // 缓冲效果 &#125;) canvas.add(rect)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 这个例子用了 fabric.util.ease.easeOutBounce 缓冲效果。 其实 绝对值动画 和 相对值动画 的用法是差不多的，只是 第二个参数 用法不同。 相对值动画 是把 animate 改成带上运算符的值，这样就会在原基础上做计算。 事件🎁 本节案例在线预览 - 事件 🎁 本节代码仓库 Fabric.js 提供了一套很方便的事件系统，我们可以用 on 方法可以初始化事件监听器，用 off 方法将其删除。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;template&gt; &lt;div&gt; &lt;canvas width=&quot;400&quot; height=&quot;400&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt; &lt;button @click=&quot;addClickEvent&quot;&gt;添加画布点击事件&lt;/button&gt; &lt;button @click=&quot;removeClickEvent&quot;&gt;移除画布点击事件&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;let canvas = null// 初始化画布function init() &#123; canvas = new fabric.Canvas(&#x27;canvas&#x27;) const rect = new fabric.Rect(&#123; top: 20, left: 20, width: 100, height: 50, fill: &#x27;#9896f1&#x27; &#125;) // 给矩形添加一个选中事件 rect.on(&#x27;selected&#x27;, options =&gt; &#123; console.log(&#x27;选中矩形啦&#x27;, options) &#125;) canvas.add(rect) addClickEvent()&#125;// 移除画布点击事件function removeClickEvent() &#123; canvas.off(&#x27;mouse:down&#x27;)&#125;// 添加画布点击事件function addClickEvent() &#123; removeClickEvent() // 在添加事件之前先把该事件清除掉，以免重复添加 canvas.on(&#x27;mouse:down&#x27;, options =&gt; &#123; console.log(`x轴坐标: $&#123;options.e.clientX&#125;; y轴坐标: $&#123;options.e.clientY&#125;`) &#125;)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; Fabric.js 还提供了很多事件，详情可以查看官方案例 自由绘画『Fabric.js 自由绘画 - 文档』 🎁 本节案例在线预览 - 自由绘画 🎁 本节代码仓库 123456789101112131415161718192021222324252627282930313233343536&lt;template&gt; &lt;div&gt; &lt;canvas width=&quot;400&quot; height=&quot;400&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;// 初始化function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;, &#123; isDrawingMode: true, // 开启绘图模式 &#125;) // 设置画笔颜色 canvas.freeDrawingBrush.color = &#x27;#11999e&#x27; // 设置画笔粗细 canvas.freeDrawingBrush.width = 10 // 画笔投影 canvas.freeDrawingBrush.shadow = new fabric.Shadow(&#123; blur: 10, offsetX: 10, offsetY: 10, affectStroke: true, color: &#x27;#30e3ca&#x27;, &#125;)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 在使用 new fabric.Canvas 创建画布时，设置 isDrawingMode: true 就可以开始自由绘画模式。 canvas.freeDrawingBrush 里有一堆属性可以设置画笔样式。 禁止部分操作🎁 本节案例在线预览 - 禁止部分操作 🎁 本节代码仓库 禁止水平移动 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;400&quot; height=&quot;400&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;// 初始化画布function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) const rect = new fabric.Rect(&#123; top: 100, left: 100, width: 100, height: 50, fill: &#x27;#ffde7d&#x27; &#125;) // 不允许水平移动 rect.lockMovementX = true canvas.add(rect)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 使用 lockMovementX 禁止对象水平移动。 禁止垂直移动 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;400&quot; height=&quot;400&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;// 初始化画布function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) const rect = new fabric.Rect(&#123; top: 100, left: 100, width: 100, height: 50, fill: &#x27;#f6416c&#x27; &#125;) // 不允许垂直移动 rect.lockMovementY = true canvas.add(rect)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 使用 lockMovementY 禁止对象垂直移动。 禁止旋转 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;400&quot; height=&quot;400&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;// 初始化画布function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) const rect = new fabric.Rect(&#123; top: 100, left: 100, width: 100, height: 50, fill: &#x27;#3490de&#x27; &#125;) // 禁止旋转 rect.lockRotation = true canvas.add(rect)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 使用 lockRotation 禁止对象旋转。 禁止水平缩放 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;400&quot; height=&quot;400&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;// 初始化画布function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) const rect = new fabric.Rect(&#123; top: 100, left: 100, width: 100, height: 50, fill: &#x27;#ff9a3c&#x27; &#125;) // 禁止水平缩放 rect.lockScalingX = true canvas.add(rect)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 使用 lockScalingX 禁止对象水平缩放。 禁止垂直缩放 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;400&quot; height=&quot;400&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;// 初始化画布function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) const rect = new fabric.Rect(&#123; top: 100, left: 100, width: 100, height: 50, fill: &#x27;#f95959&#x27; &#125;) // 禁止垂直缩放 rect.lockScalingY = true canvas.add(rect)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 使用 lockScalingY 禁止对象垂直缩放。 缩放和平移画布🎁 本节案例在线预览 - 平移和缩放画布 🎁 本节代码仓库 缩放画布以原点为基准缩放画布要缩放画布，其实是在监听鼠标事件。 这里监听的是鼠标的滚轮事件：mouse:wheel。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;template&gt; &lt;div&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;400&quot; height=&quot;400&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; // 初始化画布 const canvas = new fabric.Canvas(&#x27;canvas&#x27;) // 矩形（参照物） const rect = new fabric.Rect(&#123; top: 10, left: 10, width: 40, height: 40, fill: &#x27;orange&#x27; &#125;) // 圆形（参照物） const circle = new fabric.Circle(&#123; top: 30, left: 30, radius: 50, fill: &#x27;green&#x27; &#125;) canvas.add(rect, circle) // 将矩形和圆形添加到画布中 // 监听鼠标滚轮事件 canvas.on(&#x27;mouse:wheel&#x27;, opt =&gt; &#123; let delta = opt.e.deltaY // 滚轮向上滚一下是 -100，向下滚一下是 100 let zoom = canvas.getZoom() // 获取画布当前缩放值 // 控制缩放范围在 0.01~20 的区间内 zoom *= 0.999 ** delta if (zoom &gt; 20) zoom = 20 if (zoom &lt; 0.01) zoom = 0.01 // 设置画布缩放比例 canvas.setZoom(zoom) &#125;)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 以鼠标指针为基准缩放画布 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;template&gt; &lt;div&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;400&quot; height=&quot;400&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; // 初始化画布 const canvas = new fabric.Canvas(&#x27;canvas&#x27;) // 矩形（参照物） const rect = new fabric.Rect(&#123; top: 130, left: 130, width: 40, height: 40, fill: &#x27;orange&#x27; &#125;) // 圆形（参照物） const circle = new fabric.Circle(&#123; top: 150, left: 150, radius: 50, fill: &#x27;green&#x27; &#125;) canvas.add(rect, circle) // 将矩形和圆形添加到画布中 // 监听鼠标滚轮事件 canvas.on(&#x27;mouse:wheel&#x27;, opt =&gt; &#123; let delta = opt.e.deltaY // 滚轮向上滚一下是 -100，向下滚一下是 100 let zoom = canvas.getZoom() // 获取画布当前缩放值 // 控制缩放范围在 0.01~20 的区间内 zoom *= 0.999 ** delta if (zoom &gt; 20) zoom = 20 if (zoom &lt; 0.01) zoom = 0.01 // 设置画布缩放比例 // 关键点！！！ // 参数1：将画布的所放点设置成鼠标当前位置 // 参数2：传入缩放值 canvas.zoomToPoint( &#123; x: opt.e.offsetX, // 鼠标x轴坐标 y: opt.e.offsetY // 鼠标y轴坐标 &#125;, zoom // 最后要缩放的值 ) &#125;)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 平移画布 本例的需求是，按下 alt键 后才能触发移动画布的功能。 根据这个需求，可以把任务拆解成3步： 鼠标点击（刚按下那刻） 鼠标移动 鼠标松开 鼠标点击 mouse:down 该步骤使用 mouse:down 可以监听到。 在回调函数里监听是否按下 alt键。 如果按下 alt键 ，设置一个值记录 开启移动状态。 记录鼠标当前所在的 x 和 y 轴坐标。 鼠标移动 mouse:move 判断是否需要移动（鼠标点击的第三步）。 如需移动，立刻转换画布视图模式 将画布移动到 鼠标x和y轴坐标 。 鼠标松开 mouse:up 把画布定格在鼠标松开的坐标。 关闭移动状态（鼠标点击的第三步） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;template&gt; &lt;div&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;400&quot; height=&quot;400&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; // 初始化画布 const canvas = new fabric.Canvas(&#x27;canvas&#x27;) // 矩形（参照物） const rect = new fabric.Rect(&#123; top: 130, left: 130, width: 40, height: 40, fill: &#x27;orange&#x27; &#125;) // 圆形（参照物） const circle = new fabric.Circle(&#123; top: 150, left: 150, radius: 50, fill: &#x27;green&#x27; &#125;) canvas.add(rect, circle) // 将矩形和圆形添加到画布中 canvas.on(&#x27;mouse:down&#x27;, opt =&gt; &#123; // 鼠标按下时触发 let evt = opt.e if (evt.altKey === true) &#123; // 是否按住alt canvas.isDragging = true // isDragging 是自定义的，开启移动状态 canvas.lastPosX = evt.clientX // lastPosX 是自定义的 canvas.lastPosY = evt.clientY // lastPosY 是自定义的 &#125; &#125;) canvas.on(&#x27;mouse:move&#x27;, opt =&gt; &#123; // 鼠标移动时触发 if (canvas.isDragging) &#123; let evt = opt.e let vpt = canvas.viewportTransform // 聚焦视图的转换 vpt[4] += evt.clientX - canvas.lastPosX vpt[5] += evt.clientY - canvas.lastPosY canvas.requestRenderAll() // 重新渲染 canvas.lastPosX = evt.clientX canvas.lastPosY = evt.clientY &#125; &#125;) canvas.on(&#x27;mouse:up&#x27;, opt =&gt; &#123; // 鼠标松开时触发 canvas.setViewportTransform(canvas.viewportTransform) // 设置此画布实例的视口转换 canvas.isDragging = false // 关闭移动状态 &#125;)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 选中状态『原文地址』 🎁 本节案例在线预览 - 选中状态 🎁 本节代码仓库 Fabric.js 创建出来的元素（图形、图片、组等）默认是可以被选中的。 是否可以选中。 选空白位置可以选中吗？ 选中后的样式。 禁止选中 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;canvas width=&quot;400&quot; height=&quot;400&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) const rect = new fabric.Rect(&#123; top: 100, left: 100, width: 200, height: 100, fill: &#x27;red&#x27; &#125;) // 元素禁止选中 rect.selectable = false canvas.add(rect)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 无法通过空白位置选中元素蓝色三角形要鼠标完全放入才能选中 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;template&gt; &lt;canvas width=&quot;400&quot; height=&quot;400&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) // 三角形 const triangle1 = new fabric.Triangle(&#123; top: 100, left: 50, width: 80, // 底边宽度 height: 100, // 底边到定点的距离 fill: &#x27;blue&#x27;, &#125;) // 选择三角形空白位置的时候无法选中，当perPixelTargetFind设为false后可以选中。默认值是false triangle1.perPixelTargetFind = true // 三角形 const triangle2 = new fabric.Triangle(&#123; top: 100, left: 200, width: 80, // 底边宽度 height: 100, // 底边到定点的距离 fill: &#x27;green&#x27;, &#125;) canvas.add(triangle1, triangle2) canvas.selectionFullyContained = true // 只选择完全包含在拖动选择矩形中的形状&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 画布框选样式 123456789101112131415161718192021222324252627282930313233&lt;template&gt; &lt;canvas width=&quot;200&quot; height=&quot;200&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) // 圆形 const circle = new fabric.Circle(&#123; radius: 30, fill: &#x27;#f55&#x27;, top: 70, left: 70 &#125;) canvas.add(circle) canvas.selection = true // 画布是否可选中。默认true；false 不可选中 canvas.selectionColor = &#x27;rgba(106, 101, 216, 0.3)&#x27; // 画布鼠标框选时的背景色 canvas.selectionBorderColor = &quot;#1d2786&quot; // 画布鼠标框选时的边框颜色 canvas.selectionLineWidth = 6 // 画布鼠标框选时的边框厚度 canvas.selectionDashArray = [30, 4, 10] // 画布鼠标框选时边框虚线规则 canvas.selectionFullyContained = true // 只选择完全包含在拖动选择矩形中的形状&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 自定义边和控制角样式 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;canvas width=&quot;200&quot; height=&quot;200&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) // 圆形 const circle = new fabric.Circle(&#123; radius: 30, fill: &#x27;#f55&#x27;, top: 70, left: 70 &#125;) circle.set(&#123; borderColor: &#x27;red&#x27;, // 边框颜色 cornerColor: &#x27;green&#x27;, // 控制角颜色 cornerSize: 10, // 控制角大小 transparentCorners: false // 控制角填充色不透明 &#125;) canvas.add(circle) canvas.setActiveObject(circle) // 选中圆&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 透明控制角 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;canvas width=&quot;200&quot; height=&quot;200&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) // 圆形 const circle = new fabric.Circle(&#123; radius: 30, fill: &#x27;#f55&#x27;, top: 70, left: 70 &#125;) circle.set(&#123; borderColor: &#x27;gray&#x27;, // 边框颜色 cornerColor: &#x27;black&#x27;, // 控制角颜色 cornerSize: 12, // 控制角大小 transparentCorners: true // 控制角填充色透明 &#125;) canvas.add(circle) canvas.setActiveObject(circle) // 选中第一项&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 自定义选中后的背景色 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;canvas width=&quot;200&quot; height=&quot;200&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) // 圆形 const circle = new fabric.Circle(&#123; radius: 30, fill: &#x27;#f55&#x27;, top: 70, left: 70 &#125;) circle.set(&#123; selectionBackgroundColor: &#x27;orange&#x27; // 选中后，背景色变橙色 &#125;) canvas.add(circle) canvas.setActiveObject(circle) // 选中第一项&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 没有边框 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;canvas width=&quot;200&quot; height=&quot;200&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) // 圆形 const circle = new fabric.Circle(&#123; radius: 30, fill: &#x27;#f55&#x27;, top: 70, left: 70 &#125;) circle.hasBorders = false // 取消边框 canvas.add(circle) canvas.setActiveObject(circle) // 选中第一项&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 没有控制角没有控制角将意味着无法用鼠标直接操作缩放和旋转，只允许移动操作。 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;canvas width=&quot;200&quot; height=&quot;200&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) // 圆形 const circle = new fabric.Circle(&#123; radius: 30, fill: &#x27;#f55&#x27;, top: 70, left: 70 &#125;) circle.hasControls = false // 禁止控制角 canvas.add(circle) canvas.setActiveObject(circle) // 选中第一项&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 自定义光标在对象悬停本例设置了当鼠标在元素上出现 ”等待指针“ 。 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;canvas width=&quot;200&quot; height=&quot;200&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) // 圆形 const circle = new fabric.Circle(&#123; radius: 30, fill: &#x27;#f55&#x27;, top: 70, left: 70 &#125;) canvas.hoverCursor = &#x27;wait&#x27; // 设置等待指针 canvas.add(circle)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 元素移动时的样式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;template&gt; &lt;canvas width=&quot;200&quot; height=&quot;200&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) // 圆形 const circle = new fabric.Circle(&#123; radius: 30, fill: &#x27;#f55&#x27;, top: 70, left: 70 &#125;) circle.hasBorders = circle.hasControls = false canvas.add(circle) function animate(e, dir) &#123; if (e.target) &#123; fabric.util.animate(&#123; startValue: e.target.get(&#x27;angle&#x27;), endValue: e.target.get(&#x27;angle&#x27;) + (dir ? 10 : -10), duration: 100 &#125;) fabric.util.animate(&#123; startValue: e.target.get(&#x27;scaleX&#x27;), endValue: e.target.get(&#x27;scaleX&#x27;) + (dir ? 0.2 : -0.2), duration: 100, onChange: function(value) &#123; e.target.scale(value) canvas.renderAll() &#125;, onComplete: function() &#123; e.target.setCoords() &#125; &#125;) &#125; &#125; canvas.on(&#x27;mouse:down&#x27;, function(e) &#123; animate(e, 1) &#125;) canvas.on(&#x27;mouse:up&#x27;, function(e) &#123; animate(e, 0) &#125;)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 不允许框选不允许从画布框选，但允许选中元素。 123456789101112131415161718192021222324252627&lt;template&gt; &lt;canvas width=&quot;200&quot; height=&quot;200&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) // 圆形 const circle = new fabric.Circle(&#123; radius: 30, fill: &#x27;#f55&#x27;, top: 70, left: 70 &#125;) canvas.add(circle) canvas.selection = false // 不允许直接从画布框选&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 裁剪『Fabric.js 裁剪原文 1』 『Fabric.js 裁剪原文 2』 🎁 本节案例在线预览 - 裁剪 🎁 本节代码仓库 裁剪单一图形 123456789101112131415161718192021222324252627282930313233343536&lt;template&gt; &lt;canvas width=&quot;300&quot; height=&quot;300&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) // 裁剪的图形 // clipPath从对象的中心开始定位，对象originX和originY不起任何作用，而clipPath originX和originY起作用。定位逻辑与fabric.Group相同 const clipPath = new fabric.Circle(&#123; radius: 40, left: -40, top: -40 &#125;) // 矩形 const rect = new fabric.Rect(&#123; width: 200, height: 100, fill: &#x27;red&#x27; &#125;) // 裁剪矩形 rect.clipPath = clipPath canvas.add(rect)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 裁剪一个组 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;template&gt; &lt;canvas width=&quot;300&quot; height=&quot;300&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) // 裁剪的图形 // clipPath从对象的中心开始定位，对象originX和originY不起任何作用，而clipPath originX和originY起作用。定位逻辑与fabric.Group相同 const clipPath = new fabric.Circle(&#123; radius: 40, left: -40, top: -40 &#125;) const group = new fabric.Group([ new fabric.Rect(&#123; width: 100, height: 100, fill: &#x27;red&#x27; &#125;), new fabric.Rect(&#123; width: 100, height: 100, fill: &#x27;yellow&#x27;, left: 100 &#125;), new fabric.Rect(&#123; width: 100, height: 100, fill: &#x27;blue&#x27;, top: 100 &#125;), new fabric.Rect(&#123; width: 100, height: 100, fill: &#x27;green&#x27;, left: 100, top: 100 &#125;) ]) // 裁剪一个组 group.clipPath = clipPath canvas.add(group)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 组合剪辑 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;template&gt; &lt;canvas width=&quot;300&quot; height=&quot;300&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) const clipPath = new fabric.Group( [ new fabric.Circle(&#123; radius: 70, top: -70, left: -70 &#125;), new fabric.Circle(&#123; radius: 40, top: -95, left: -95 &#125;), new fabric.Circle(&#123; radius: 40, top: 15, left: 15 &#125;) ], &#123; left: -95, top: -95 &#125; ) const group = new fabric.Group([ new fabric.Rect(&#123; width: 100, height: 100, fill: &#x27;red&#x27; &#125;), new fabric.Rect(&#123; width: 100, height: 100, fill: &#x27;yellow&#x27;, left: 100 &#125;), new fabric.Rect(&#123; width: 100, height: 100, fill: &#x27;blue&#x27;, top: 100 &#125;), new fabric.Rect(&#123; width: 100, height: 100, fill: &#x27;green&#x27;, left: 100, top: 100 &#125;) ]) group.clipPath = clipPath canvas.add(group)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 剪完再剪（组合剪辑） 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;canvas width=&quot;300&quot; height=&quot;300&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) const clipPath = new fabric.Circle(&#123; radius: 70, top: -50, left: -50 &#125;) const innerClipPath = new fabric.Circle(&#123; radius: 70, top: -90, left: -90 &#125;) clipPath.clipPath = innerClipPath const group = new fabric.Group([ new fabric.Rect(&#123; width: 100, height: 100, fill: &#x27;red&#x27; &#125;), new fabric.Rect(&#123; width: 100, height: 100, fill: &#x27;yellow&#x27;, left: 100 &#125;), new fabric.Rect(&#123; width: 100, height: 100, fill: &#x27;blue&#x27;, top: 100 &#125;), new fabric.Rect(&#123; width: 100, height: 100, fill: &#x27;green&#x27;, left: 100, top: 100 &#125;), ]) group.clipPath = clipPath canvas.add(group)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 组内嵌套剪辑 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;canvas width=&quot;300&quot; height=&quot;300&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) const clipPath = new fabric.Circle(&#123; radius: 100, top: -100, left: -100 &#125;) const small = new fabric.Circle(&#123; radius: 50, top: -50, left: -50 &#125;) const group = new fabric.Group([ new fabric.Rect(&#123; width: 100, height: 100, fill: &quot;red&quot;, clipPath: small &#125;), new fabric.Rect(&#123; width: 100, height: 100, fill: &quot;yellow&quot;, left: 100 &#125;), new fabric.Rect(&#123; width: 100, height: 100, fill: &quot;blue&quot;, top: 100 &#125;), new fabric.Rect(&#123; width: 100, height: 100, fill: &quot;green&quot;, left: 100, top: 100 &#125;), ]) group.clipPath = clipPath canvas.add(group)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 用文字来裁剪 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;canvas width=&quot;300&quot; height=&quot;300&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;) const clipPath = new fabric.Text( &#x27;Hi I\\&#x27;m the new ClipPath! I hope we\\&#x27;ll be friends&#x27;, &#123; top: -100, left: -100 &#125; ) const group = new fabric.Group([ new fabric.Rect(&#123; width: 100, height: 100, fill: &quot;red&quot; &#125;), new fabric.Rect(&#123; width: 100, height: 100, fill: &quot;yellow&quot;, left: 100 &#125;), new fabric.Rect(&#123; width: 100, height: 100, fill: &quot;blue&quot;, top: 100 &#125;), new fabric.Rect(&#123; width: 100, height: 100, fill: &quot;green&quot;, left: 100, top: 100 &#125;), ]) group.clipPath = clipPath canvas.add(group)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 裁剪画布 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;canvas width=&quot;300&quot; height=&quot;300&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;, &#123; backgroundColor: &quot;#ddd&quot; &#125;) const group = new fabric.Group([ new fabric.Rect(&#123; width: 100, height: 100, fill: &quot;red&quot; &#125;), new fabric.Rect(&#123; width: 100, height: 100, fill: &quot;yellow&quot;, left: 100 &#125;), new fabric.Rect(&#123; width: 100, height: 100, fill: &quot;blue&quot;, top: 100 &#125;), new fabric.Rect(&#123; width: 100, height: 100, fill: &quot;green&quot;, left: 100, top: 100 &#125;), ]) const clipPath = new fabric.Circle(&#123; radius: 100, top: 0, left: 50 &#125;) canvas.clipPath = clipPath canvas.add(group)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 裁剪画布，但不裁控件 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;canvas width=&quot;300&quot; height=&quot;300&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;, &#123; backgroundColor: &quot;#ddd&quot; &#125;) const group = new fabric.Group([ new fabric.Rect(&#123; width: 100, height: 100, fill: &quot;red&quot; &#125;), new fabric.Rect(&#123; width: 100, height: 100, fill: &quot;yellow&quot;, left: 100 &#125;), new fabric.Rect(&#123; width: 100, height: 100, fill: &quot;blue&quot;, top: 100 &#125;), new fabric.Rect(&#123; width: 100, height: 100, fill: &quot;green&quot;, left: 100, top: 100 &#125;), ]) // 裁剪区之外控件可见 canvas.controlsAboveOverlay = true const clipPath = new fabric.Circle(&#123; radius: 100, top: 0, left: 50 &#125;) canvas.clipPath = clipPath canvas.add(group)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 动画裁剪 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;template&gt; &lt;canvas width=&quot;300&quot; height=&quot;300&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; const canvas = new fabric.Canvas(&#x27;canvas&#x27;, &#123; backgroundColor: &quot;#ddd&quot; &#125;) const clipPath = new fabric.Rect(&#123; width: 100, height: 100, top: 0, left: 0 &#125;) function animateLeft()&#123; clipPath.animate(&#123; left: 200, &#125;,&#123; duration: 900, onChange: canvas.requestRenderAll.bind(canvas), onComplete: animateRight &#125;) &#125; function animateRight()&#123; clipPath.animate(&#123; left: 0, &#125;,&#123; duration: 1200, onChange: canvas.requestRenderAll.bind(canvas), onComplete: animateLeft &#125;) &#125; function animateDown()&#123; clipPath.animate(&#123; top: 100, &#125;,&#123; duration: 500, onChange: canvas.requestRenderAll.bind(canvas), onComplete: animateUp &#125;) &#125; function animateUp()&#123; clipPath.animate(&#123; top: 0, &#125;,&#123; duration: 400, onChange: canvas.requestRenderAll.bind(canvas), onComplete: animateDown &#125;) &#125; const group = new fabric.Group([ new fabric.Rect(&#123; width: 100, height: 100, fill: &quot;red&quot; &#125;), new fabric.Rect(&#123; width: 100, height: 100, fill: &quot;yellow&quot;, left: 100 &#125;), new fabric.Rect(&#123; width: 100, height: 100, fill: &quot;blue&quot;, top: 100 &#125;), new fabric.Rect(&#123; width: 100, height: 100, fill: &quot;green&quot;, left: 100, top: 100 &#125;), ], &#123; scale: 1.5 &#125;) canvas.controlsAboveOverlay = true animateLeft() animateDown() canvas.clipPath = clipPath canvas.add(group)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 使用绝对定位裁剪 123456789101112131415161718192021222324252627282930313233&lt;template&gt; &lt;canvas width=&quot;300&quot; height=&quot;300&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; const canvas = new fabric.Canvas(&quot;canvas&quot;) const clipPath = new fabric.Rect(&#123; width: 300, height: 300, top: 0, left: 0, absolutePositioned: true &#125;) const clipPath2 = new fabric.Rect(&#123; width: 300, height: 300, top: 0, left: 0, absolutePositioned: true &#125;) fabric.Image.fromURL(&quot;http://fabricjs.com/assets/dragon.jpg&quot;, function(img)&#123; img.clipPath = clipPath img.scaleToWidth(300) canvas.add(img) &#125;) fabric.Image.fromURL(&quot;http://fabricjs.com/assets/dragon2.jpg&quot;, function(img)&#123; img.clipPath =clipPath2 img.scaleToWidth(300) img.top = 150 canvas.add(img) &#125;)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 颠倒的clipPaths 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;canvas width=&quot;300&quot; height=&quot;300&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; const canvas = new fabric.Canvas(&quot;canvas&quot;) const clipPath = new fabric.Circle(&#123; radius: 100, top: -200, left: -220 &#125;) const clipPath2 = new fabric.Circle(&#123; radius: 100, top: 0, left: -20 &#125;) const clipPath3 = new fabric.Circle(&#123; radius: 100, top: 0, left: -220 &#125;) const clipPath4 = new fabric.Circle(&#123; radius: 100, top: -200, left: -20 &#125;) const g = new fabric.Group([ clipPath, clipPath2, clipPath3, clipPath4 ]) g.inverted = true // 颠倒裁剪 fabric.Image.fromURL(&quot;http://fabricjs.com/assets/dragon.jpg&quot;, function(img) &#123; img.clipPath = g img.scaleToWidth(500) canvas.add(img) &#125;)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 序列化🎁 本节案例在线预览 - 序列化 🎁 本节代码仓库 所谓的序列化其实就是将画布的内容转成 JSON，方便保存。 但 Fabric.js 除了能将画布转成字符串，还可以输出 base64 和 svg。 输出JSON 1234567891011121314151617181920212223&lt;template&gt; &lt;div&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;200&quot; height=&quot;200&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; // 初始化画布 const canvas = new fabric.Canvas(&#x27;canvas&#x27;) console.log(&#x27;canvas stringify &#x27;, JSON.stringify(canvas)) console.log(&#x27;canvas toJSON&#x27;, canvas.toJSON()) console.log(&#x27;canvas toObject&#x27;, canvas.toObject())&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 打开控制台可以看到输出。 本例分别使用了 JSON.stringify() 、canvas.toJSON() 和 canvas.toObject() 进行序列化一个空画布。 Fabric.js 提供了 toJSON 和 toObject 两个方法，把画布及内容转换成 JSON 。 因为本例输出的是一个空画布，所以在输出内容里的 objects 字段是一个空数组。 如果有背景、有图形之类的元素存在，objects 对象里就会出现相应的数据。 详情可查看 🎁 本节案例在线预览 - 序列化 输出png（base64版） 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;template&gt; &lt;div&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;200&quot; height=&quot;200&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; // 初始化画布 const canvas = new fabric.Canvas(&#x27;canvas&#x27;, &#123; backgroundColor: &#x27;#a5dee5&#x27; &#125;) const rect = new fabric.Rect(&#123; left: 50, top: 50, height: 20, width: 20, fill: &#x27;green&#x27; &#125;) const circle = new fabric.Circle(&#123; left: 80, top: 80, radius: 40, fill: &quot;red&quot; &#125;) canvas.add(rect, circle) console.log(&#x27;toPng&#x27;, canvas.toDataURL(&#x27;png&#x27;)) // 在控制台输出 png（base64） canvas.requestRenderAll()&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 使用 canvas.toDataURL(&#39;png&#39;) 可以输出 png 图片。但这个操作可能会打断 canvas 的渲染，所以之后要再执行以下 canvas.requestRenderAll() 。 输出以下内容，可以把这段复制到浏览器地址打开看看 1data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAAAXNSR0IArs4c6QAADGdJREFUeF7tnX9sVtUZx5+moFBXE0Q7i5gayKbYQiUKWNmUujIwDJ24jm7DRRAnjgkKjgUypo4FMiZocUycCGbiVtaJU0ago7PqxhDQINCKboFIBkWrQGK1oEC6nIZlBoG+99xz7nvPOZ/3X+55znk+3/MJvT/e++Y8s3tfu/CBAAROSSAHQdgZEDg9AQRhd0DgDAQQhO0BAQRhD0BAjwD/g+hxY1QgBBAkkKBpU48AguhxY1QgBBAkkKBpU48AguhxY1QgBBAkkKBpU48AguhxY1QgBBAkkKBpU48AguhxY1QgBBAkkKBpU48AguhxY1QgBBAkkKBpU48AguhxY1QgBBAkkKBpU48AguhxY1QgBBAkkKBpU48AguhxY1QgBBAkkKBpU48AguhxY1QgBBAkkKBpU48AguhxY1QgBBAkkKBpU48AguhxY1QgBBAkkKBpU48AguhxY1QgBBAkkKBpU48AguhxY1QgBBAkkKBpU48AguhxY1QgBBAkkKBpU48AguhxY1QgBBAkkKBpU48AguhxY1QgBBAkkKBpU48AguhxY1QgBBAkkKBpU48AguhxY1QgBBAkkKBpU48AguhxY1QgBBAkkKBpU48AguhxY1QgBBAkkKBpU48AguhxY1QgBBAkkKBpU48AguhxY1QgBLwR5NltC4xHdkvpdOM1KegWAa8EWbVtoTH6Y0qnCYIYw+lsIQQ5TXQI4uyeNrpwBEEQoxvKt2IIgiC+7Wmj/SAIghjdUL4VQxAE8W1PG+0HQRDE6IbyrRiCIIhve9poPwiCIEY3lG/FEARBfNvTRvtBEAQxuqF8K4YgCOLbnjbaD4IgiNEN5VsxBEEQ3/a00X4QBEGMbijfiiEIgvi2p432gyAIYnRD+VYMQRDEtz1ttB8EQRCjG8q3Yl4JYjocvnJrmqh79bwRxD30rNgFAgjiQkqsMWsEECRr6JnYBQII4kJKrDFrBBAka+iZ2AUCCOJCSqwxawQQJGvomdgFAgjiQkqsMWsEECRr6JnYBQII4kJKGayxa2ur5O95R/Le3S9nH/hAzmptldwjR2TAwvmyfdoMOd6tm3yany+f9Dxf2i4slNaiS+Rofn4GlcM+BEEczb9g86tywZbN0nPbVunxZpOc07wvcidthb3kYHGJHCgdKO9fNUhahpRFruH7AARxJeH2dilas1p6r18nvRpelK4ftRpf+dEv5Etz+fWyd/hI2TNqtEhOjvE5XCuIIClPrEdTo/StrZE+tTXS5fDhxFZ7rHt32V1ZJbsqq+RQcUli86ZtIgRJWyIn1vPFjf+US59aKr3X12V9hXuHj5C3b5so75Vdk/W1JL0ABEmaeCfznde4Q4oXV8vFdWtTtjKR/4y4QZomT5WDJf1TtzZbC0IQW2Qj1s05flyumD9X+j2xJOLI5A/fecckeWPGLGnPzU1+8oRnRJCEgZ9qusKXG+TKOffLubt3pWA1mS3hwz595fXZD8r+68ozG+DoUQiS5eAGPPKQlCx6OMur0J++ccq9sv2e+/QLpHwkgmQpoC5tbVI2fUoqzzWiIlHnJhsXLJJjeXlRh6b+eATJQkTqjvfQuyeJOiH35aNO3Dc8uqTjDr1PHwRJOE11X2PY7bdK95aWhGe2P93hggJ5adkKOXR5sf3JEpoBQRICraZRj4QMmzDOSzn+h7FDkief9ubmIoIkJIj6s6pi7M1ey/FZSepXPufFn1sIkoAg6oS8omqMV+ccnWFT5yT1NaucP3FHkM6SNvDvX71rohdXq6KiUFe3/v7Y0qjDUnU8gliOw/X7HHHxuH6fBEHi7oAzjFd3yMvHj7M4gxulG5avcPaOO4JY2mPq2apRI8qdenzEEgpRj6WsqWtw8tktBLG0KwbOm+PEg4eW2v9cWfWA49aZs5Oaztg8CGIM5f8LqTvkI28caaGy2yXXvbDOuUflEcTCngv1qlVnKF28qoUgnaUa8d/VNwG/9r3KiKPCOfxvz9Q69c1EBDG8N6+9c0IqviZruC1j5dTXd195fJmxerYLIYhBwupBxBtGjzBY0c9Sa1fXOfOsFoIY3INXPfBT+fLvlhus6Gepf31/vLz2wC+caA5BTMXU3i7fLvlSoq/mMbX0pOuoVwr9sfHfTrx3C0EM7Y6iv7wgQ6fcZaia/2U2LHpM9nzjxtQ3iiCGIho69YdStPp5Q9X8L7Nn9E2yofo3qW8UQQxFVDngMiuvAzW0vNSVUa85rd3+VurWdfKCEMRARAWbNkrFd75loFJYJeprnpWWwVenumkEMRBP8eJFUrrglwYqhVVi2/SfSNPkKaluGkEMxHPtD8ZL7/q/GqgUVom9FV+XV36b7sviCGJgT35z6CDJ299soFJYJT7udZE8/4/NqW4aQWLGo37ZqbL0sphVwh1eu+2tVP/SFYLE3Js82h4PYNofgUeQePl2nHuocxA+egTUOYg6F0nrB0FiJtN35e9lyMwfx6wS7vBN834lu8Z+N7UAECRmNP2WPi4D5/48ZpVwh2+d9TPZOfHO1AJAkJjRlPy6uuOnlvnoEVA/Ud34o6l6gxMYhSAxIfevXiD9qxfGrBLu8B1Tp8uOqdNSCwBBYkbD/yDxAPI/SDx+qR/NOUi8iDgHiccv9aO5ihUvIq5ixeOX+tHcB4kXEfdB4vFL/WjupMeLiDvp8filfjTPYsWLiGex4vFzYvRNXxks5zTvc2KtaVpkW2Ev+fOGLWla0ufWwmVeA/HwfRA9iHwfRI+bc6P4RqFeZHyjUI+bc6MKNr8qFVW3OLfubC+4/g9/kpYhZdlexhnn508sQ/HwVpNoIHmrSTRezh/Ne7GiRch7saLxcv5o3qwYLULerBiNl/tH827ejDPk3bwZo/LrQN7unlmevN09M07eHcXvg2QWKb8PkhknL4/iF6bOHCu/MOXlts+8KX6j8Mys+I3CzPeSt0fyK7enjpZfufV2y0drjEfgT80r7Y+2n2rV3EmPtvczPnrgvDnS74klGR/v+4E775gkW2fOdq5NBLEUWc7x4zJqRLmcu3uXpRncKfthn76ypq5B2nNz3Vn0iZUiiMXICl9ukPLx4yzO4EbphuUrZP915W4s9qRVIojl2AY88pCULHrY8izpLd845V7Zfs996V1gJytDkASiC/WqlotXrU7eDgiSgCBd2tqkomqMqKtboXwOlvSX+ppVciwvz+mWESSh+PL3vCMVY2+W7i0tCc2YvWkOFxRI/crnpLXokuwtwtDMCGIIZCZl1LNaw26/1WtJlBwvLVshhy4vzgRJ6o9BkIQj6vFmkwybMM5LSTrkePJpOVRckjBVe9MhiD22p62s/twaevckr85J1DnHhkeXePFn1WeDQ5AsCKKmVCfuZdOnyMV1a7O0AnPTqqtVGxcscv6E/FREEMTcPtGq5Pp9Etfvc3QWGoJ0RiiBf1d33K+cc79Tj6Wox0den/2gs3fIM40VQTIlZfk49ezWFfPnOvGAo3rw8I0Zs5x8tipqjAgSlZjl49XNxOLF1ak8N1HnGk2Tp4o6IQ/lgyApTVp9M/HSp5ZK7/V1WV+h+prs27dNlPfKrsn6WpJeAIIkTTzifOrmYt/aGulTWyNdDh+OOFr/cPVqnt2VVbKrssqr+xpRiSBIVGLZOr69XYrWrJbe69dJr4YXpetHrcZXol4H2lx+vewdPlL2jBotkpNjfA7XCiKIa4mdWG/Bpo1ywWtbpOe2rXJeU6Pk7W+O3MnHvS7qeCTkQOlAeX/QYGkZfHXkGr4PQBBPEla/dKXu0Oe9u1/OPvCBnNXaKrlHjoi6Oqa+yXe8Wzf5ND9fPul5vrRdWNhxx/tofr4n3dtrA0HssaWyBwQQxIMQacEeAQSxx5bKHhBAEA9CpAV7BBDEHlsqe0AAQTwIkRbsEUAQe2yp7AEBBPEgRFqwRwBB7LGlsgcEEMSDEGnBHgEEsceWyh4QQBAPQqQFewQQxB5bKntAAEE8CJEW7BFAEHtsqewBAQTxIERasEcAQeyxpbIHBBDEgxBpwR4BBLHHlsoeEEAQD0KkBXsEEMQeWyp7QABBPAiRFuwRQBB7bKnsAQEE8SBEWrBHAEHssaWyBwQQxIMQacEeAQSxx5bKHhBAEA9CpAV7BBDEHlsqe0AAQTwIkRbsEUAQe2yp7AEBBPEgRFqwRwBB7LGlsgcEEMSDEGnBHgEEsceWyh4QQBAPQqQFewQQxB5bKntAAEE8CJEW7BFAEHtsqewBgf8Coc6ZjF61hZ4AAAAASUVORK5CYII= 输出 SVG 12345678910111213141516171819202122232425262728293031323334353637383940&lt;template&gt; &lt;div&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;200&quot; height=&quot;200&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; // 初始化画布 const canvas = new fabric.Canvas(&#x27;canvas&#x27;, &#123; backgroundColor: &#x27;#a5dee5&#x27; &#125;) const rect = new fabric.Rect(&#123; left: 50, top: 50, height: 20, width: 20, fill: &#x27;green&#x27; &#125;) const circle = new fabric.Circle(&#123; left: 80, top: 80, radius: 40, fill: &quot;red&quot; &#125;) canvas.add(rect, circle) console.log(canvas.toSVG()) // 输出 SVG&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 输出 SVG 很简单，直接调用 canvas.toSVG() 即可。 输出： 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot; ?&gt;&lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; version=&quot;1.1&quot; width=&quot;200&quot; height=&quot;200&quot; viewBox=&quot;0 0 200 200&quot; xml:space=&quot;preserve&quot;&gt;&lt;desc&gt;Created with Fabric.js 4.6.0&lt;/desc&gt;&lt;defs&gt;&lt;/defs&gt;&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;100%&quot; height=&quot;100%&quot; fill=&quot;#a5dee5&quot;&gt;&lt;/rect&gt;&lt;g transform=&quot;matrix(1 0 0 1 60.5 60.5)&quot; &gt;&lt;rect style=&quot;stroke: none; stroke-width: 1; stroke-dasharray: none; stroke-linecap: butt; stroke-dashoffset: 0; stroke-linejoin: miter; stroke-miterlimit: 4; fill: rgb(0,128,0); fill-rule: nonzero; opacity: 1;&quot; x=&quot;-10&quot; y=&quot;-10&quot; rx=&quot;0&quot; ry=&quot;0&quot; width=&quot;20&quot; height=&quot;20&quot; /&gt;&lt;/g&gt;&lt;g transform=&quot;matrix(1 0 0 1 120.5 120.5)&quot; &gt;&lt;circle style=&quot;stroke: none; stroke-width: 1; stroke-dasharray: none; stroke-linecap: butt; stroke-dashoffset: 0; stroke-linejoin: miter; stroke-miterlimit: 4; fill: rgb(255,0,0); fill-rule: nonzero; opacity: 1;&quot; cx=&quot;0&quot; cy=&quot;0&quot; r=&quot;40&quot; /&gt;&lt;/g&gt;&lt;/svg&gt; 反序列化🎁 本节案例在线预览 - 反序列化 🎁 本节代码仓库 反序列化就是把 JSON 数据渲染到画布上。 通常把从后台请求回来的数据渲染到画布上。 123456789101112131415161718192021222324&lt;template&gt; &lt;div&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;200&quot; height=&quot;200&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;import &#123; fabric &#125; from &#x27;fabric&#x27;function init() &#123; const str = &#x27;&#123;&quot;version&quot;:&quot;4.6.0&quot;,&quot;objects&quot;:[&#123;&quot;type&quot;:&quot;rect&quot;,&quot;version&quot;:&quot;4.6.0&quot;,&quot;originX&quot;:&quot;left&quot;,&quot;originY&quot;:&quot;top&quot;,&quot;left&quot;:50,&quot;top&quot;:50,&quot;width&quot;:20,&quot;height&quot;:20,&quot;fill&quot;:&quot;green&quot;,&quot;stroke&quot;:null,&quot;strokeWidth&quot;:1,&quot;strokeDashArray&quot;:null,&quot;strokeLineCap&quot;:&quot;butt&quot;,&quot;strokeDashOffset&quot;:0,&quot;strokeLineJoin&quot;:&quot;miter&quot;,&quot;strokeUniform&quot;:false,&quot;strokeMiterLimit&quot;:4,&quot;scaleX&quot;:1,&quot;scaleY&quot;:1,&quot;angle&quot;:0,&quot;flipX&quot;:false,&quot;flipY&quot;:false,&quot;opacity&quot;:1,&quot;shadow&quot;:null,&quot;visible&quot;:true,&quot;backgroundColor&quot;:&quot;&quot;,&quot;fillRule&quot;:&quot;nonzero&quot;,&quot;paintFirst&quot;:&quot;fill&quot;,&quot;globalCompositeOperation&quot;:&quot;source-over&quot;,&quot;skewX&quot;:0,&quot;skewY&quot;:0,&quot;rx&quot;:0,&quot;ry&quot;:0&#125;,&#123;&quot;type&quot;:&quot;circle&quot;,&quot;version&quot;:&quot;4.6.0&quot;,&quot;originX&quot;:&quot;left&quot;,&quot;originY&quot;:&quot;top&quot;,&quot;left&quot;:80,&quot;top&quot;:80,&quot;width&quot;:80,&quot;height&quot;:80,&quot;fill&quot;:&quot;red&quot;,&quot;stroke&quot;:null,&quot;strokeWidth&quot;:1,&quot;strokeDashArray&quot;:null,&quot;strokeLineCap&quot;:&quot;butt&quot;,&quot;strokeDashOffset&quot;:0,&quot;strokeLineJoin&quot;:&quot;miter&quot;,&quot;strokeUniform&quot;:false,&quot;strokeMiterLimit&quot;:4,&quot;scaleX&quot;:1,&quot;scaleY&quot;:1,&quot;angle&quot;:0,&quot;flipX&quot;:false,&quot;flipY&quot;:false,&quot;opacity&quot;:1,&quot;shadow&quot;:null,&quot;visible&quot;:true,&quot;backgroundColor&quot;:&quot;&quot;,&quot;fillRule&quot;:&quot;nonzero&quot;,&quot;paintFirst&quot;:&quot;fill&quot;,&quot;globalCompositeOperation&quot;:&quot;source-over&quot;,&quot;skewX&quot;:0,&quot;skewY&quot;:0,&quot;radius&quot;:40,&quot;startAngle&quot;:0,&quot;endAngle&quot;:6.283185307179586&#125;],&quot;background&quot;:&quot;#ddd&quot;&#125;&#x27; // 初始化画布 const canvas = new fabric.Canvas(&#x27;canvas&#x27;) // 反序列化 canvas.loadFromJSON(str)&#125;onMounted(() =&gt; &#123; init()&#125;)&lt;/script&gt; 使用 canvas.loadFromJSON() 可以进行反序列化，里面传入一个 JSON格式 的字符串 即可。 本例的 str 保存了一个 Fabric.js 导出的数据。","tags":["canvas","fabric.js"],"categories":["canvas"]},{"title":"一个免费学习生词的轻应用","path":"/2025/03/26/一个免费学习生词的轻应用/","content":"最近我开发了一个帮助学习语文字词的小应用。 如果你家有正在认字学词的学童，那么它可能会对你有所帮助 :) 开发背景开发这个程序的初衷是希望能给学生朋友的语文学习提供一些帮助。 如果你是一位家长并且有检查孩子作业的经历，那么对于时不时冒出来一个错别字，时不时用拼音代替文字，时不时词语滥用让人啼笑皆非，这些情况应该不会感到陌生。面对这样的问题，我常常想：怎么才能让孩子的语文学习更轻松，少犯一些错误呢？如果有一个程序能把经常错的字词保存，然后多看和多练，应该会有所改观吧。 此外，现在学生的书写水平也是两极分化，有的字写得很好看，有的写的很潦草；一种情况是态度的问题，一种情况是学生对汉字的字型和结构没有清晰的认识。对于后者，如果能够有规范书写的大字号的卡片进行对照临摹，那么对于提高书写水平应该会有所帮助；对于前者，只能靠家长的智慧，先端正学习态度了 :( 基于以上的一些想法，所以就做了这么个小应用(http://pzj.freesite.online) 功能介绍生词本管理系统有共享的生词本，用户也可以创建自己的生词本。 共享的生词本，目前只有幼儿园和初中部分，有其他需求可留言。 生词本列表中，可设置自己的生词本为共享或私有。共享的生词本，其他用户也可以查看，但不可编辑。 生词本列表 填入基本信息，创建生词本。 创建生词本 手动输入生词或批量上传生词 创建生词 查看生词本中的所有词语 查看所有词语 标签管理生词本中的生词可以打标签，之后可以根据标签搜索，进行针对的练习。 标签管理 词语认读词语认读页面包括：字体切换、搜索过滤、打标签和词语卡片等功能模块。采用字体5，可以查看词语的拼音、含义和字型。 词语认读 提供多种字体，可切换到合适字体，进行书写练习 字体切换 字体切换 首先应该选择生词本，系统内置如下共享生词本 选择生词本 每个生词本内，又可细分为不同的课文 选择课文 在翻页查看生词的时候，用户可以给词语打标签，之后就能通过标签进行筛选了。 打标签 生词测试生词测试页面和词语认读页面类似，但增加了测试功能，用户可以测试自己认读的效果。点击卡片，可临时去掉蒙层，查看答案。 生词测试 登录注册只需基本信息，即可注册免费使用，邮箱最好填真实的，方便找回密码。 登录注册 总结这是一个用PHP开发的简单应用，业务逻辑不是很复杂，不过它也涉及了前后端开发，数据库设计，登录鉴权和部署等研发环境，也算是一次完整的开发实践吧 :) 通过捣鼓这个小应用，个人体会最深的是：洞察需求时程序员一项很重要的技能，发现需求并且能够用自己掌握的知识去解决问题，才能获得成就感，产生更大的价值。 最后，欢迎有需要的朋友使用，也欢迎提出宝贵意见。(访问地址: http://pzj.freesite.online)","tags":["myapp"]},{"title":"如何用vimdiff解决合并冲突","path":"/2025/03/21/如何用vimdiff解决合并冲突/","content":"转载自: https://juejin.cn/post/7351300787648921619 vimdiff 介绍vimdiff 等同于 vim -d 命令，即 Vim 编辑器的 diff 模式。 该命令后面通常会接两个或多个文件名作为参数，这些文件会同时在 Vim 编辑器的分割窗口中打开，并高亮显示文件之间内容有差异的部分。 同时，该模式下还提供部分快捷按键用于完成文件内容的合并等操作。 启动 vimdiffvimdiff 命令常用于编辑同一文件的不同历史版本，对各文件的内容进行比对与调整。如下面两个文件： 123456789$ cat file1Line oneLine 2Line threeLine 4Line 5Line 6 123456789$ cat file2Line 1Line 2Line 3Line 4Line 5Line 6Line 7Line 8 可以使用 vim -O2 file1 file2 命令，在左右排列的两个窗口中同时打开 file1 和 file2 两个文件，如下图所示： 而 vimdiff file1 file2 命令会以同样的形式打开这两个文件，并且用不同的背景色高亮显示彼此间有差别的内容，如下图： 从上面的两幅截图中可以得出 vimdiff 标记差别内容时的几个规则： 只在某一个文件中存在的行背景色设置为蓝色，而另一文件中的对应位置则被标记为绿色。（或者说，相对于另一个文件，当前文件中“多余”的行标记为蓝色，“缺少”的行则标记为绿色） 两个文件中同时存在但是内容有差异的行，都标记为粉色，而引起差异的文字标记为红色 除了 vimdiff FILE_LEFT FILE_RIGHT 或者 vim -d FILE_LEFT FILE_RIGHT 的形式外，也可以通过在 Vim 中输入命令进入 diff 模式。 比如先进入 Vim 编辑 FILE_LEFT 文件（vim FILE_LEFT），再输入以下命令进入 diff 模式：:vertical diffsplit FILE_RIGHT 光标移动可以使用下列两种快捷键，在文件的各个差异点之间前后移动： ], c：跳转到下个差异点 [, c：跳转到上个差异点 至于光标在两个窗口之前的切换，可以使用如下按键： Ctrl-w, l：光标切换到右侧的窗口 Ctrl-w, h：光标切换到左侧的窗口 Ctrl-w, w：光标在两个窗口间彼此切换 内容合并可以使用 d, p （即 diff put）命令，将当前差异点中的内容覆盖到另一文件中的对应位置。如当光标位于左侧文件（file1）中的第一行时，依次按下 d、p 键，则 file1 中的 Line one 被推送到右侧，并替换掉 file2 中对应位置上的 Line 1 。截图如下： 而 d, o （即 diff obtain）命令可以将另一窗口中差异点处的内容拉取到当前位置并进行替换操作。截图如下： 即在 file1 的第一行执行 d o 命令后，file2 中的第一行内容 Line 1 被拉取到 file1 中并替换掉原来位置上的 Line one。 多文件编辑vimdiff 实际上是 Vim 编辑器的 diff 模式，因此适用于 Vim 编辑器的命令和快捷键也同样可以在该模式下使用。常用的几个命令如下： :qa：退出所有文件 :wa：保存所有文件 :wqa：保存并退出所有文件 qa!：强制退出（不保存）所有文件 z o：查看被折叠的内容 z c：重新折叠 其他常用的命令与快捷键可参考 Vim 速查手册 vimdiff 解冲突使用 vimdiff 作为 Git 的合并工具确实可能会让新手感到困惑，但它是一个功能强大的工具，一旦掌握了它，就可以非常高效地进行代码合并和比较 Git配置在开始之前，需要知道如何将vimdiff设置为Git的合并工具。具体步骤如下： 123git config merge.tool vimdiffgit config merge.conflictstyle diff3git config mergetool.prompt false 这将把Git设置为默认的合并工具，在合并时显示共同祖先，并禁用打开vimdiff的提示。 git config merge.tool vimdiff: 这会将 vimdiff 设置为默认的合并工具。 git config merge.conflictstyle diff3: 这会告诉 Git 在合并冲突时显示共同祖先的版本，这样就可以看到两个分支以及它们的共同起点的内容。 git config mergetool.prompt false: 这会禁用打开合并工具时的提示，Git 将自动打开 vimdiff 而不询问是否想要继续。 完成这些设置后，当运行 `git mergetool` 命令来解决合并冲突时，Git 将自动使用 `vimdiff` 来打开有冲突的文件。 创建冲突下面用一个例子举例： 创建一个名为”zoo”的目录，并进入”zoo”目录，然后初始化Git仓库，最后新建一个animals.txt。 1234mkdir zoo # cd zoogit initvi animals.txt 在文件中添加一些动物信息后并保存： 1234bash 代码解读复制代码catdogoctopusoctocat 之后提交该文件 12git add animals.txtgit commit -m &quot;Initial commit&quot; 添加文件animals.txt到Git，提交文件，并附上消息”Initial commit”。 创建一个名为”octodog”的分支，并切换到”octodog”分支，并打开文件animals.txt，并将”octopus”改为”octodog”。 123git branch octodoggit checkout octodogvi animals.txt # let&#x27;s change octopus to octodog 添加文件animals.txt到Git，提交文件，并附上消息”Replace octopus with an octodog”。 add animals.txt1git commit -m &quot;Replace octopus with an octodog&quot; 切换到”master”分支，打开文件animals.txt，并将”octopus”改为”octoman”。 12git checkout mastervi animals.txt # let&#x27;s change octopus to octoman 添加文件animals.txt到Git，提交文件，并附上消息”Replace octopus with an octoman”。 12git add animals.txtgit commit -m &quot;Replace octopus with an octoman&quot; 合并”octodog”分支到”master”分支。 1git merge octodog # merge octodog into master 此时，会得到一个合并错误： 123Auto-merging animals.txtCONFLICT (content): Merge conflict in animals.txtAutomatic merge failed; fix conflicts and then commit the result. 这表明在animals.txt文件中存在合并冲突。 解决冲突解决这个冲突可以输入以下命令： 1git mergetool 执行上述命令后，Git会尝试使用vimdiff作为合并工具来解决冲突。vimdiff会打开一个窗口，显示两个版本的文件，中间会有冲突标记。需要手动比较这两个版本，并选择一个解决方案来替换冲突的部分。使用 hjkl 键在窗口之间导航，使用 :diffget LOCAL、:diffget REMOTE 或 :diffget BASE 来将对应窗口的内容复制到 MERGED 窗口中。解决冲突后，保存并关闭文件，Git会提示你提交冲突的解决结果。 上述窗口看起来很迷糊，其实很好理解，下面解释一下都有什么。从左到右，从上到下： LOCAL: 这是当前分支（通常是执行 git merge 命令时所在的分支）的文件内容。 在合并过程中，这代表了您的最新更改。 BASE: 这是两个分支的共同祖先的文件内容。 它显示了自从两个分支从共同点分开以来，发生了哪些变化。 REMOTE: 这是试图合并进来的分支的文件内容。 在 git merge 命令中，`` 就是这里的 REMOTE。 MERGED: 这是合并后的文件内容将显示的地方。 目标是将 LOCAL 和 REMOTE 的更改合并到这个窗口中，以解决所有冲突。 假设想要保留“octodog”的更改（来自REMOTE）。为此，将光标移动到MERGED文件（Ctrl + w, j），然后移动到合并冲突区域。接着，可以选择保留LOCAL版本、BASE版本或REMOTE版本中的哪一部分，或者合并这些内容。完成后，保存并关闭文件，Git会提示你提交冲突的解决结果。 1vim 代码解读复制代码:diffget RE 这会将REMOTE中相应的更改添加到MERGED文件中，也可以： 123:diffg RE` - 从REMOTE获取内容:diffg BA` - 从BASE获取内容:diffg LO` - 从LOCAL获取内容 这些命令允许快速地从一个特定的版本中获取内容，并将其应用于MERGED区域。一旦解决了所有的冲突，保存并关闭文件，Git会提示提交冲突的解决结果。 保存文件并退出（快速写入并退出多个文件的方法是：:wqa）。一旦解决了所有冲突并保存了文件后运行git commit，完成这些步骤后，就成功地解决了合并冲突，并将更改提交到了 Git 仓库。 以下是一些其他的命令： 使用:diffthis命令来打开两个版本之间的差异，这样可以更清楚地看到差异。 使用:nextdiffto命令来切换到下一个差异，这样可以逐步解决多个冲突。 使用:diffoff命令来关闭差异显示，这样可以更专注于编辑。 使用:diffmerge命令来合并两个版本，这将覆盖当前的MERGED区域。 使用:diffmergeoff命令来关闭合并显示，这样可以回到正常的编辑模式。","tags":["vim","git"]},{"title":"全面了解DNS和DoH/DoT","path":"/2025/03/06/全面了解DNS和DoH-DoT/","content":"转载自: https://juejin.cn/post/6913507512859754509 DNS (Domain Name System)，直译就是域名系统，它所提供的服务是将域名转换为主机 IP 地址，这一过程我们称为域名解析 标准互联网域名解析流程在介绍之前我们来了解几个名词 注册局：域名注册局是管理顶级域名的组织，它们创建域名后缀，设置域名规则，并与注册商合作向公众出售域名，如 VeriSign 管理 .com 域名，CNNIC 管理 .cn 域名 注册商：域名注册商是经过认证可向公众销售域名的组织，如 GoDaddy，万网等 顶级域名：.com，.cn，.net，.org 等被称为顶级域名 二级域名：这个就是我们常用等域名，比如 baidu.com，taobao.com 等被称为二级域名 权威 NS 记录：域名服务器记录，用来指定该域名由哪个 DNS 服务器来进行解析。若不指定，默认一般由注册商的 DNS 服务器提供免费的域名解析服务 上图就是我们非常熟悉的互联网域名解析流程，客户端会到本地 DNS 服务器递归查询出记录结果，而本地 DNS 服务器的缓存中没有相应的记录，则会依次从根域名服务器，顶级域名服务器，权限域名服务器迭代查询出记录结果。我们可以使用下面的命令来了解下本地 DNS 服务器是如何迭代查询出记录结果的 1dig @8.8.8.8 www.baidu.com +trace 递归查询和迭代查询的区别为，递归查询是 A-&gt;B-&gt;C-&gt;D，而迭代查询是 A-&gt;B, A-&gt;C, A-&gt;D。本地 DNS 服务器一般是网络服务商提供的 DNS，也可以自己修改为常用的公共 DNS 标准 DNS 面临的安全问题我们知道标准 DNS 协议如同大多数早期互联网协议一样，完全没有考虑安全问题，数据是通过明文传输的。常见的针对 DNS 的攻击手段有 DNS 欺骗&#x2F;缓存中毒 (DNS Cache Poisoning)：原理是利用 DNS 协议设计时的安全缺陷，通过伪造 ARP 应答包，当 ARP 欺骗成功后，只有嗅探到目标主机发出 DNS 请求包就解析后立即构造一个伪造的 DNS 返回包欺骗目标主机，解析器则会将返回包的结果保存进 DNS 缓存表中，而后当真实的 DNS 返回包到来时则会被丢弃。简单来说就是冒充 DNS 服务器 DNS 劫持 (DNS Hijacking)：结果和 DNS 缓存一样，都是篡改 DNS 解析结果，只是不单单针对的是解析器中的 DNS 缓存表，而是针对 DNS 解析链路上的每一步。比如 通过木马病毒或恶意软件篡改 DNS 配置 (hosts 文件，DNS 服务器地址，DNS 缓存表等) 利用路由器漏洞篡改路由器的 DNS 配置 防御 DNS 威胁的最知名方式之一是使用 DNSSEC 协议，DNSSEC 通过对数据进行数字签名来防止攻击，以帮助确保其有效性。为确保进行安全查找，此签名必须在 DNS 查找过程的每个级别进行，但不幸的是，它当前尚未得到普遍采用 DoHDoH，DNS over HTTPS，是一种安全解析域名的方案。2018年 DoH 正式成为国际标准 RFC8484，通过加密的 HTTPS 协议进行 DNS 解析请求，代替标准的，基于 UDP 的 DNS 协议，可以有效避免域名被运 DNS 劫持，DNS 欺骗&#x2F;缓存中毒等域名安全问题。现如今 DoH&#x2F;DoT 在 Google，Firefox 等浏览器已经获得了支持，微软也放出消息将在 Windows 10 系统的后续开发中加入 DoH&#x2F;DoT 支持，苹果在 WWDC 大会宣布 iOS 14 与 macOS 11 新增对加密 DNS 的支持 (包括 DoH&#x2F;DoT)，同时 DoH&#x2F;DoT 已经获得部分公共 DNS 支持，如下所示 提供商 网址 Cloudflare DNS cloudflare-dns.com&#x2F;dns-query www.cloudflare.com/zh-cn/learn… Google Public DNS dns.google&#x2F;dns-query developers.google.com&#x2F;speed&#x2F;publi… 阿里云公共 DNS dns.alidns.com&#x2F;dns-query www.alidns.com/ 现在我们借助公共 DNS 来了解下 DoH，可以参考这份文档 123456789101112131415161718192021222324252627282930json 代码解读复制代码$ curl -H &#x27;accept: application/dns-json&#x27; &#x27;https://cloudflare-dns.com/dns-query?name=baidu.com&amp;type=A&#x27;&#123; &quot;Status&quot;: 0, &quot;TC&quot;: false, &quot;RD&quot;: true, &quot;RA&quot;: true, &quot;AD&quot;: false, &quot;CD&quot;: false, &quot;Question&quot;: [ &#123; &quot;name&quot;: &quot;baidu.com&quot;, &quot;type&quot;: 1 &#125; ], &quot;Answer&quot;: [ &#123; &quot;name&quot;: &quot;baidu.com&quot;, &quot;type&quot;: 1, &quot;TTL&quot;: 546, &quot;data&quot;: &quot;220.181.38.148&quot; &#125;, &#123; &quot;name&quot;: &quot;baidu.com&quot;, &quot;type&quot;: 1, &quot;TTL&quot;: 546, &quot;data&quot;: &quot;39.156.69.79&quot; &#125; ]&#125; Status，DNS 查询的响应状态码，可以参考 RFC1035 TC，Truncation，标准的 DNS 协议封包最大长度为 512Bytes，超过就会发生截断，但是由于 DoH 使用的是 HTTPS 协议，不会存在截断问题，所以 TC 位恒为 false RD，Recursion Desired，递归期望，与 RA 对应，由于请求端携带发送，值为 true 则表示递归解析，否则表示迭代解析 RA，Recursion Available，递归可用，DNS 服务器是否支持递归查询，大多数 DNS 服务器都是支持递归查询的，除了少部分根 DNS 服务器 AD，如果为 true 表示每一条记录都是经过 DNSSEC validation CD，Checking Disabled，如果为 true 表示禁用 DNSSEC validation Question name，请求域名 Question type，请求 DNS 解析记录，常见的解析记录有，A，TXT 等，具体可以参考 RFC1035 Answer name Answer type Answer TTL Answer data，解析结果 DoTDoT，DNS over TLS，同样也是一种安全解析域名的方案，国际标准 RFC7858。DoH 和 DoT 都是替代标准 DNS 的方案，那么两者有什么差别呢？ 从网络安全的角度来看，DoT 可以说更好，它使网络管理员能够监视和阻止 DNS 查询，这对于识别和阻止恶意流量非常重要。另一方面，DoH 查询隐藏在常规 HTTPS 流量中，两者使用的都是 443 端口，这就意味着很难区分是常规 HTTPS 流量还是 DoH 流量 从隐私安全的角度来看，DoH 更好，就如前面所说，我们是很难区分是常规 HTTPS 流量还是 DoH 流量的，那么就从间接增强了用户的隐私性 在浏览器上使用 DoH我们前面讲过现如今 DoH&#x2F;DoT 在 Google，Firefox 等浏览器已经获得了支持，这里我将演示 Chrome 87 如何使用 DoH，过程如下 1rust 代码解读复制代码设置 -&gt; 隐私设置和安全性 -&gt; 安全 -&gt; 使用安全 DNS 接下来打开 https://1.1.1.1/help 验证下你的浏览器是否真的是用了 DoH，如果使用了 VPN 或者其他代理工具的话，请暂时关掉，不然会测试不了。其它的浏览器配置可以参考这份文档，Configure your browser to use DNS over HTTPS","tags":["DNS"]},{"title":"开发者都应该了解的DNS知识","path":"/2025/03/04/开发者都应该了解的DNS知识/","content":"转载自: https://juejin.cn/post/7023258157241597983 什么是 DNS​在介绍域名前，我们先来看看为什么需要域名？ 域名易读易记网络中的计算机是通过IP去定位资源的，但是IP难读难记，对人不友好；所以就设计了一套通过域名查找IP的解析系统。 域名可以与IP解耦企业或单位的域名通常是固定的， 但是随着业务逐渐发展, 服务弹性伸缩和负载均衡高可用等因素，使得同一个域名不同用户解析出的 IP 可以是不一样的，所以域名也可以保证与 IP 的解耦。此外，DNS解析作为网络请求过程的第一步，DNS 解析的性能很重要，需要设置合理的 DNS 解析架构。 那什么是 DNS 呢？ DNS (Domain Name System)，直译就是域名系统，它所提供的服务是将域名转换为主机 IP 地址，这一过程我们称为域名解析。 DNS 本质是为了维护域名和 IP 的映射关系的服务 DNS 分为了公网的 DNS 服务 和 私有的 DNS 服务。 DNS相关术语 注册局：域名注册局是管理顶级域名的组织，它们创建域名后缀，设置域名规则，并与注册商合作向公众出售域名，如 VeriSign 管理 .com 域名，CNNIC 管理 .cn 域名 注册商：域名注册商是经过认证可向公众销售域名的组织，如 GoDaddy，万网等 权威 NS 记录：域名服务器记录，用来指定该域名由哪个 DNS 服务器来进行解析。若不指定，默认一般由注册商的 DNS 服务器提供免费的域名解析服务 域名结构比如一个域名 mail.tsinghua.edu.cn. 这个域名分为了几个层次，比如根., 顶级域名 cn，二级域名 edu，三级域名 tsinghua，四级域名 mail，如下图所示： 根域名服务器: 根级 DNS 服务全球一共有 13 集群，其中 10 个在美国，其他分别在英国、瑞典、日本。根服务器主要用来管理互联网的主目录。大部分采用 anycast + BGP 方式管理服务集群，anycast 技术可以是的多台服务对外暴露同一个 IP 地址，由路由层面的 BGP 机房选择一个就近的服务器进行解析任务。根域名服务器存储了顶级的 NS(name server) 服务器列表。​ 顶级域名服务器：顶级域名主要描述该域名的性质，一是国家和地区顶级域名（ccTLDs），目前200多个国家都按照ISO3166国家代码分配了顶级域名，例如中国是cn，日本是jp等；二是通用顶级域名（gTLDs），例如表示工商企业的.com，表示网络提供商的 .net，表示非盈利组织的 .org 等。三是新顶级域名（New gTLD）如通用的 .xyz、代表“高端”的 .top、代表“红色”的 .red、代表“人”的 .men 等一千多种。​ 二级域名服务器：二级域名一般是指域名注册人选择使用的名称，如 yahoo．com；上网的商业组织通常使用自己的商标、商号或其他商业标志作为自己的网上名称，如“microsoft．com”。二级以上的域名都是非注册类型的域名可以每一个服务自己去定义。​ 权威域名服务器：权威域名服务器指提供 IP 解析能力的DNS，或者能够控制最终 IP 地址解析的服务器，一般是 二级域名服务器。​ Local DNS: 用户上网需要通过 ISP(互联网服务提供商, 比如电信、网通等) 的网络接入互联网, ISP 会分配给用户一个 DNS 服务器，该服务器就是 Local DNS。Local DNS 能够不断迭代 根NS、顶级NS、权威 NS，直到能够解析出该域名 IP 后返回给用户。 DNS 解析原理 用户接入 ISP 提供的网络后，会给用户分配一个 ISP 提供的解析 DNS 的 IP 地址，称为 Local DNS 用户在浏览器中输入网址开始访问 www.aaa.com 首先会将 www.aaa.com 进行域名地址的解析工作，解析成 IP 地址。 浏览器会从本地缓存中查看是否有 www.aaa.com 域名 DNS 解析缓存，浏览器DNS缓存一般是 1min 左右(不同的浏览器不一致), 同时对于 chrome 浏览器你可以通过 chrome:&#x2F;&#x2F;net-internals&#x2F;#dns 链接清除浏览器本地缓存的 DNS 解析。如果没有对应域名的缓存，会继续访问设备上本地 host。 本地 host 是一个 域名和 IP 的映射表，在 Linux 里位于 `/etc/hosts` 文件中，在 Windows 里是位于 “`C:\\\\WINDOWS\\\\system32\\\\drivers\\\\etc\\\\hosts`” 文件中。如果没有对应的域名映射，则浏览器的网络模块会读取设备被分配的 Local DNS 地址，给 ISP 分配的 Local DNS 发送域名解析请求，要求 Local DNS 对 [www.aaa.com](http://www.aaa.com \"http://www.aaa.com\") 地址进行解析，最终给浏览器解析的 IP 地址或者解析错误日志信息。 Local DNS 一般在电脑网络适配器属性中可以查看，当然我们也可以修改 Local DNS， 比如改写成 8.8.8.8， 或者公司内部的 DNS 解析服务。Local DNS 收到用户的请求后，会根据域名的结构，从根NS **迭代** 地请求各个 NS 得到最终的 IP 。Local DNS 服务器中保存了 13 处 根域名服务器地址(几乎根域名服务器地址是不会更换的)。Local DNS 会将 www.aaa.com 地址解析请求发送给一个就近的根域名服务器。 根域名服务器发现这个域名是属于 .com 顶级域名下的，则返回 .com 顶级NS列表 和 IP 地址给 Local DNS 。Local DNS 得到顶级 NS 列表后，进一步选择一个就近的顶级 NS 服务器，去请求解析结果。 顶级 NS 接收到来自 Local DNS 请求后，发现这是来自于 .aaa 这个二级域名下的，它把在它这里登记注册的 aaa.com NS列表返回给 local DNS。 此时返回一个 CNAME 地址 www.aaa.lxdns.com。 local DNS 发现返回的 NS 列表中通过 NS 策略选择出一个 CNAME 记录，所以就是用 www.aaa.lxdns.com 地址继续重复 4 5 6 步骤 直到请求到 lxdns.com NS。 在 lxdns.com NS 中成功解析出 www.aaa.lxdns.com A 记录，将 IP 1.1.1.1 返回给 Local DNS，Local DNS 返回给浏览器，浏览器发起到 1.1.1.1 的 http 请求加载内容。 在整个过程中, 涉及到 Local DNS 如何从各个 NS 返回的下一个 NS 列表中选择一个唯一 IP 的问题，一般对于 bind9 等软件都实现了通过多点部署 DNS 就近选择。 DNS 解析示例 上图就是我们非常熟悉的互联网域名解析流程，客户端会到本地 DNS 服务器递归查询出记录结果，而本地 DNS 服务器的缓存中没有相应的记录，则会依次从根域名服务器，顶级域名服务器，权限域名服务器迭代查询出记录结果。我们可以使用下面的命令来了解下本地 DNS 服务器是如何迭代查询出记录结果的 1dig @8.8.8.8 www.baidu.com +trace 递归查询和迭代查询的区别为，递归查询是 A-&gt;B-&gt;C-&gt;D，而迭代查询是 A-&gt;B, A-&gt;C, A-&gt;D。本地 DNS 服务器一般是网络服务商提供的 DNS，也可以自己修改为常用的公共 DNS DNS 自定义区域 DNS 资源记录 DNS 常用命令1. 查看域名对应的 NSdig &#123;domain&#125; dig 命令可以查看域名的解析 NS 列表，同时也可以看出缓存时间 2. 指定 Local DNS 进行域名解析dig @&#123;Local DNS IP&#125; &#123;domain&#125; 可以使用这个方法进行 CDN 的调度测试 3.查看 DNS 的 TTL 4.查看 DNS 完整解析路径dig +trace &#123;domain&#125; +additional 5.测试网络延迟ping &#123;ip&#125; DNS 性能分析CNAME 次数过多设置 TTL 不合理DNS 多点就近部署架构升级企业内网 DNS 内网 web 服务 hostname 应该设置为 FQDN 如何维护主机名和内网 IP 关系 一些中间件需要迁移扩容，所以需要使用域名对外服务 对解析域名有更高的要求（安全-dnssec 效率-ttl） 使用 bind9 工具去实现","tags":["DNS"]},{"title":"值得了解的Python虚拟环境","path":"/2025/02/21/值得了解的Python虚拟环境/","content":"转载自: https://blog.csdn.net/peanutwang/article/details/144555317 1. 安装虚拟环境工具从 Python 3.3 开始，Python 自带了 venv 模块，无需额外安装。你可以直接使用它来创建虚拟环境。 2. 创建虚拟环境2.1 使用 venv 创建虚拟环境使用以下命令创建虚拟环境。这里我使用了 venv 来创建虚拟环境，并且命名为 myvenv，你也可以选择任何其他名称。 python -m venv myvenv python -m venv myvenv：这条命令会在当前目录下创建一个名为 myvenv 的虚拟环境和文件夹。 如果你有多个 Python 版本，你可能需要指定 Python 版本，如 python3.8 或 python3，以确保使用正确的版本。 2.2 查看虚拟环境文件虚拟环境创建后，会在当前目录下生成一个 myvenv 文件夹。里面包含了虚拟环境所需的文件和目录结构： bin：包含虚拟环境的可执行文件（如 python）。 lib：包含虚拟环境的库文件。 include：包含用于编译 C 扩展模块的头文件。 Scripts（Windows）：包含 activate.bat 等脚本。 linux下安装，没有Scripts文件夹，执行 source bin&#x2F;activate 激活虚拟环境 3. 激活虚拟环境 .\\myvenv\\Scripts\\activate 执行后，你会看到命令行前面出现虚拟环境的名称 (myvenv)，表示虚拟环境已经被激活。 激活后，你会看到命令行前面加上 (myvenv)，这表示当前已经进入虚拟环境。 或者进入myvenv目录，运行Scripts\\activate 4. 使用虚拟环境当虚拟环境激活后，你可以在虚拟环境中安装和管理 Python 包。所有通过 pip 安装的包只会影响当前虚拟环境，而不会影响全局的 Python 安装。 4.1 安装依赖包你可以在虚拟环境中使用 pip 来安装你需要的依赖包： 1pip install &lt;package_name&gt; 4.2 查看安装的包你可以使用 pip list 查看虚拟环境中安装的所有包： 1pip list 4.3 卸载包如果你不再需要某个包，可以使用 pip uninstall 卸载它： pip uninstall &lt;package_name&gt; 5. 生成 requirements.txtrequirements.txt 文件是记录项目依赖包的常见方式，通常用于分享和复现环境。 5.1 创建 requirements.txt你可以使用 pip freeze 命令生成当前虚拟环境的依赖包列表，并将其保存到 requirements.txt 文件中： pip freeze &gt; requirements.txt 该命令会将虚拟环境中所有已安装的包及其版本记录到 requirements.txt 文件中。 5.2 用 requirements.txt 安装依赖当其他人获取到你的项目代码时，他们可以使用 requirements.txt 安装项目所需的所有依赖： 1pip install -r requirements.txt 6. 退出虚拟环境当你完成工作后，可以通过以下命令退出虚拟环境： deactivate 退出后，你的命令行会回到系统的默认 Python 环境。 linux下也是执行 deactivate 7. 删除虚拟环境如果你不再需要某个虚拟环境，可以删除它。只需要删除包含虚拟环境的文件夹即可（如上例的 myvenv 文件夹）。 8. 使用虚拟环境的好处 隔离依赖：每个项目都有自己的依赖包，避免版本冲突。 干净的工作环境：不同项目之间的库版本不会互相影响。 便于部署：通过 requirements.txt 文件，你可以轻松地为其他开发者或生产环境部署项目。 9.IDLE 使用虚拟环境Python IDLE Shell 可以使用虚拟环境，但设置起来稍微有点不同，因为 IDLE 默认启动的是系统 Python 环境。要在 IDLE 中使用虚拟环境，你需要手动指定虚拟环境中的 Python 解释器。 1myenv\\\\Scripts\\\\python.exe -m idlelib.idle 这样，IDLE 将会启动，并使用虚拟环境中的 Python 解释器。你可以在 IDLE 中执行代码，并确保它使用的是虚拟环境中安装的依赖，而不是全局 Python 环境中的库。 注意：在IDLE没有关闭之前，不能安装其他包。因为显示IDLE的时候，命令还在执行。 10.检查是否虚拟环境在 IDLE 中，你可以通过运行以下命令来检查当前 Python 环境是否是虚拟环境： 12import sys print(sys.executable)","tags":["Python"],"categories":["Python"]},{"title":"有必要了解python项目的依赖管理文件requirements.txt","path":"/2025/02/21/有必要了解python项目的依赖管理文件requirements-txt/","content":"转载自: https://blog.csdn.net/pearl8899/article/details/113877334 1.作用任何应用程序通常需要安装它的外部依赖库&#x2F;包。requirements.txt包含了项目的外部依赖和具体的版本号，这样在部署的时候，可以自动安装这些依赖，保证环境的一致性。 requirements.txt文件格式： 123requests==1.2.0 Flask==0.10.1requests==1.2.0 Flask==0.10.1 这样我们就可以安装requirements.txt依赖 1pip install -r requirements.txt 2.生成方法方法一：整个环境下的安装包都保存到requirements.txt中 1pip freeze &gt; requirements.txt 作用范围：pip的freeze命令保存了保存当前Python环境下所有类库包，包括那些你没有在当前项目中使用的类库。 （如果你没有的virtualenv) 生成的requirements.txt：速度非常快，不到1s 12345678910111213141516absl-py==0.11.0aiohttp==3.7.3async-timeout==3.0.1attrs==20.3.0boto3==1.16.41botocore==1.19.41cachetools==4.2.0certifi==2020.12.5chardet==3.0.4click==7.1.2dataclasses==0.8docopt==0.6.2filelock==3.0.12Flask==1.1.2fsspec==0.8.5future==0.18.2 方法二：只生成单个项目中的使用到的安装包 12pip install pipreqspipreqs . 作用范围：当前项目使用的类库导出生成为requirements.txt。 使用方法：pipreqs 加上当前路径即可。在导出当前项目使用的类库时，先定位到项目根目录，然后调用 pipreqs .&#x2F; –encoding&#x3D;utf8 命令，该命令避免编码错误，并自动在根目录生成 requirements.txt 文件。 生成的requirements.txt：有点慢，耗时1m多 1234567891011xlwt==1.3.0tqdm==4.54.1prefetch_generator==1.0.1nltk==3.5transformers==3.4.0xlrd==1.2.0torch==1.7.1XlsxWriter==1.3.7numpy==1.19.4requests==2.25.1scikit_learn==0.24.1 3.一键安装各种包最好先用conda建一个新环境，做好环境隔离，不然很有可能会污染你原来的环境，会出现以前跑通的代码，现在跑不通了。 1pip install -r requirements.txt -i https://pypi.douban.com/simple 参考：1.https://blog.csdn.net/Irving\\_zhang/article/details/790875692.https://blog.csdn.net/orangleliu/article/details/60958525","tags":["Python"],"categories":["Python"]},{"title":"全面认识流行的SSR框架Nextjs","path":"/2025/02/17/全面认识流行的SSR框架Nextjs/","content":"现在主流的前端框架大多用于创建SPA应用，SPA的缺点是首屏等待时间长和SEO不友好，对于面向个人消费者的应用来说，这很影响体验。因而前后端同构的SSR方案应运而生，但是自己搭建SSR项目却比较费劲，Next.js是一个基于react的SSR框架，能够帮助我们快速搭建SSR项目. 希望本文能让大家对Next.js有一个全面的了解，看完后有所收获 :) 简介Next.js 是一个基于react的SSR框架, 用于构建全栈web应用. 开发者只需专注于用react构建UI, Next.js 帮助我们做优化（SEO &#x2F; 图片加载 &#x2F; 页面性能等）, 并且提供了很多其他功能. Next.js使用webpack作为构建工具, 并且默认配置好了TS、Eslint和tailwind.css. 特点 基于file-system的路由 客户端和服务端渲染 扩展fetch API, 简化数据请求 支持很多样式方案, 如: css module, tailwind css and css-in-js, sass 优化图片和脚本加载 全面支持TS 安装创建next.js项目 1npx create-next-app@latest my-app 路由支持两种路由方式: app router 和 pages router app router 支持最新的react特性, 如 server component, streaming and server actions 项目结构示例: 在 Next.js version 13, 引入了全新的App Router，它是基于React Server Components实现的.App Router 会把所有的代码都放在名为app文件夹中. app 文件夹可以和 pages 文件夹共同存在，允许我们将旧项目逐步地切换到新的 App Router。 默认地出于性能优化的考虑, app文件夹下的组件都是 Server Components，不过我们也可以在文件开头声明use client把组件变为Client Components. 文件夹和文件的作用 Folders 用于定义路由. 如: app/dashboard Files 用于定义路由对应的UI, 如 app/dashboard/layout.tsx 和 app/dashboard/page.tsx page.js 可以让当前文件夹被识别为路由，即可被公开访问 在这个例子中， /dashboard/analytics URL 不是可以公开访问的，因为它不包含page.js. Route Segments每个文件夹代表一个 route segment. 每个 route segment 又对应 URL Path的一个 segment 嵌套路由 &#123;folder&#125;/&#123;subfolder&#125;/page.tsx 定义页面 (page handler) &#123;folder&#125;/&#123;subfolder&#125;/route.ts 定义接口 (api handler) 动态路由 [folder] 动态路由 [...folder] catch-all 动态路由 [[...folder]] optional catch-all 动态路由 分组路由(folder) 带括号的文件夹用于分组，对路由路径没有影响，在同一个分组下的页面可以共享一个layout, 可用分组路由根据业务模块组织代码文件 私有文件夹_folder 带有下划线的文件夹, 里面的文件会被路由系统忽略，不会被识别为路由（即使包含 page.tsx）, 只能被其他文件引用。 并列路由@folder （文件夹名为slot名) 定义并列路由, 可以在同一个layout下渲染多个页面 拦截路由(.)folder (..)folder (..)(..)folder (...)floder 拦截路由是指在当前页面通过&lt;Link&gt;跳转时, 若目标页面有对应的拦截路由，则会渲染该拦截路由下的page. 特殊文件名约定Next.js 提供了一组特殊文件去创建特殊组件，然后组织嵌套在一起，得到最终的UI layout.tsx\t布局组件，定义它下面pages共享的UI page.tsx\t页面组件，使当前文件路径可作为路由，被公开访问 loading.tsx\t当前路由下的Loading组件 not-found.tsx\t当前路由的Not found组件 error.tsx\t当前路由的Error组件 global-error.tsx\t全局的Error组件 route.ts\tServer-side API endpoint template.tsx\t特殊的每次都重复渲染的Layout UI default.tsx\tFallback UI for Parallel Routes 特殊组件嵌套方式特殊组件都是当前路由所对应页面UI的一部分，它们交织形成完整的页面。 在嵌套路由中, 每个层级的route segment对应的特殊组件树，也会嵌套形成更大更深的组件树 其他文件组织方式我们可以把components, styles, tests等文件夹直接放在app目录下，这样它们就可以被其他文件引用了。因为它们不包含 page.tsx 或 route.ts，所以它们不会被Next.js识别为路由。 同样，识别为路由的文件夹下面，也可以放 components, styles, tests等文件夹，这样它们就可以被当前路由下的页面引用了。 12345- app - product - page.tsx - components - Modal.tsx 这是因为当文件夹被识别为路由时，只有page.tsx或route.ts返回的内容，才是会被用户访问到的。如上例中，Modal.tsx的内容，不会被用户访问到，但是可以被product路由下的页面引用。 Pagespage.tsx 是对应当前route segment的页面组件 1234// `app/page.tsx` is the UI for the `/` URLexport default function Page() &#123; return &lt;h1&gt;Hello, Home page!&lt;/h1&gt;&#125; 为了让文件夹被识别为页面路由，page.js文件是必须的。 Pages 默认是Server Components, 不过也可声明为 Client Component. Pages 可以fetch data. Layoutslayout是跨route共享的UI，在导航时，layout会保持状态，保持交互性，不会重新渲染。layout也可以嵌套。 举个例子，以下的layout会被 /dashboard 和 /dashboard/settings 共享 1234567891011121314export default function DashboardLayout(&#123; children, // will be a page or nested layout&#125;: &#123; children: React.ReactNode&#125;) &#123; return ( &lt;section&gt; &#123;/* Include shared UI here e.g. a header or sidebar */&#125; &lt;nav&gt;&lt;/nav&gt; &#123;children&#125; &lt;/section&gt; )&#125; Root Layoutroot layout 是必须的，它位于app/layout.tsx, 不同于其他层级的layout, route layout必须包含 html 和 body 标签, 允许我们定义初始返回给浏览器的html内容。 1234567891011121314export default function RootLayout(&#123; children,&#125;: &#123; children: React.ReactNode&#125;) &#123; return ( &lt;html lang=&quot;en&quot;&gt; &lt;body&gt; &#123;/* Layout UI */&#125; &lt;main&gt;&#123;children&#125;&lt;/main&gt; &lt;/body&gt; &lt;/html&gt; )&#125; Nesting Layoutslayout是可以嵌套的，parent layout通过 children prop包裹child layout。 当文件夹同时包含 layout.js 和 page.js 文件时，按照前面所说的特殊文件组织方式，layout会包裹page.Layouts 可以 fetch data.parent layout 和 child layout之间传递数据是不可能的，但是可以直接fetch相同的接口获取数据，fetch API会复用缓存数据, 避免性能影响可以利用分组路由Route Groups 把需要相同布局的pages组织在一起，另外还可以利用Route Groups创建多个 root layouts. TemplatesTemplates 类似 layouts, 不同的地方是templates在导航时为每个子路由创建一个新的实例。 123export default function Template(&#123; children &#125;: &#123; children: React.ReactNode &#125;) &#123; return &lt;div&gt;&#123;children&#125;&lt;/div&gt;&#125; Metadata若需要修改 &lt;head&gt; HTML elements，可以使用 Metadata APIs。Metadata APIs 可以在 page.js 或 layout.js 文件中定义。导出 metadata 对象或 generateMetadata 函数来定义 metadata。 12345678910111213import type &#123; Metadata &#125; from &#x27;next&#x27; // either Static metadataexport const metadata: Metadata = &#123; title: &#x27;...&#x27;,&#125; // or Dynamic metadataexport async function generateMetadata(&#123; params &#125;) &#123; return &#123; title: &#x27;...&#x27;, &#125;&#125; generateMetadata中可以发起数据请求，并且可以利用params参数获取当前路由的参数。 1234567891011121314151617181920212223242526272829import type &#123; Metadata, ResolvingMetadata &#125; from &#x27;next&#x27; type Props = &#123; params: &#123; id: string &#125; searchParams: &#123; [key: string]: string | string[] | undefined &#125;&#125; export async function generateMetadata( &#123; params, searchParams &#125;: Props, parent: ResolvingMetadata): Promise&lt;Metadata&gt; &#123; // read route params const id = params.id // fetch data const product = await fetch(`https://.../$&#123;id&#125;`).then((res) =&gt; res.json()) // optionally access and extend (rather than replace) parent metadata const previousImages = (await parent).openGraph?.images || [] return &#123; title: product.title, openGraph: &#123; images: [&#x27;/some-specific-page-image.jpg&#x27;, ...previousImages], &#125;, &#125;&#125; export default function Page(&#123; params, searchParams &#125;: Props) &#123;&#125; 渲染Server componentserver component 应当声明为 async function, 因为通常都需要请求数据，然后通过props传递给client componentserver component 不能包含交互，即不可进行DOM事件监听server component 在后端渲染后，会被缓存，提高再次请求的响应速度。渲染任务会根据 route segment 和&lt;Suspense&gt; boundaries进行分割，并且通过流的方式发送给客户端，以减少等待时间。组件树通常会是server component和client component的互相交织，server component会被优先渲染执行。 服务端组件的内容, 也称为 React Server Component Payload， 它包含: server component的渲染得到的虚拟Dom client component的占位元素和引用 server component传给client component的props 渲染过程: 根据服务端返回的html，渲染一个不可交互的页面 获取路由对应的服务端组件的内容(React Server Component Payload) 用来调和客户端和服务端组件树，更新DOM. 执行hydration, 使页面可以交互 Client componentclient component 不可以声明为 async function, 否则会报错作为入口路由的一部分时，client components也会在服务端执行。 client component 可以使用 useEffect 和 useState 等React hooks，绑定DOM事件，调用浏览器API. 如果一个组件通过use client声明为客户端组件，那么它的子孙组件都会默认为客户端组件，除非显式声明为服务端组件。 默认地，被识别为路由的文件夹下的layout和page会并行渲染。 渲染类型: static (静态渲染) : 在构建时渲染，适用于静态页面，如博客文章，不会频繁更新。 dynamic (动态渲染) : 在请求时渲染，适用于需要频繁更新的页面，如用户个人主页，购物车等。 Nextjs会自动选择使用static rendering还是dynamic rendering, 如果页面使用到dynamic functions那么就会采用动态渲染。 dynamic functions是指: cookies() headers() props.searchParams 常用组件开发模式：server component fetch data, 通过props传递data给 client component Next.js应用本质上就是一个包含服务端组件和客户端组件的组件树，当其中一个组件通过use client声明为客户端组件时，它就形成了一个client subtree client subtrees 也可以包含 server components 或者调用 server actions 123&lt;ClientComponent&gt; &lt;ServerComponent /&gt;&lt;/ClientComponent&gt; 在收到请求时，Next.js会先渲染server components，然后返回一个包含server components渲染结果的RSC payload，这个payload会包含client subtree的引用，在客户端，React会使用RSC payload来协调client subtree。 既然 client component 的渲染是在 server component的渲染之后，那么就不能在 client component 中导入 server component，因为那会导致一个新的请求回传到服务器，应该通过props将 server component 传递给 client component。 1234567891011// app/page.tsximport ClientComp from &#x27;./client-component&#x27;import ServerComp from &#x27;./server-component&#x27;export default function() &#123; return ( &lt;ClientComp&gt; &lt;ServerComp /&gt; &lt;/ClientComp&gt;)&#125; 数据请求Server actionserver action 可以在 client component 中使用, 会发送ajax请求给对应的路由，返回后端数据，可以隐藏真实API，可通过 &lt;form action&gt; 或 element onClick callback触发。 服务端请求在 server component 中，可以使用 fetch 函数来发送请求，获取数据。全页面刷新时，server component 会重新执行，获取最新的数据。 服务端请求的优点有: 减少请求数量 保护敏感数据 离数据源更近，更快获得数据 可缓存，提高性能 可以使用fetch API在服务端请求的地方: server component route handler server actions 由于fetch会缓存数据，所以在服务端组件之间不需要使用单向数据流模式，通过props传递数据。直接在每个服务端组件fetch相同的接口即可，接口只会被请求一次。 server component 不需要通过fetch方法调用 route handler，它可以直接访问数据库 若用&lt;Suspense&gt;包裹组件，则组件会动态渲染，作为入口路由进行全页面渲染时不会包含该动态组件。 1&lt;Suspense fallback=&#123;&lt;Loading /&gt;&#125;&gt; &lt;Cart /&gt; &lt;/Suspense&gt; fetch缓存fetch 设置缓存语法: fetch(api, &#123; cahce: &#39;force-cache&#39; &#125;) fetch缓存有效性验证: time-based fetch(api, &#123;next: &#123; revalidate: 3600 &#125;&#125;) tag-based &amp; path-based 12345678import &#123; revalidatePath, revalidateTag &#125; from &#x27;next/cache&#x27;export async function createPost() &#123; revalidatePath(&#x27;/posts&#x27;)&#125;fetch(api, &#123; next: &#123;tags: [&#x27;haha&#x27;] &#125;&#125;)revalidateTag(&#x27;haha&#x27;) 可以把获取数据的方法定义在page组件外部，然后在page组件中调用，这样就可以在多个组件中复用获取数据的方法。 12345678910111213141516async function getArtist() &#123; const res = await fetch(api) return res.json()&#125;async function getAlbums() &#123; const res = await fetch(api) return res.json()&#125;export default async function page() &#123; const [artist, albums] = await Promise.all([getArtist(), getAlbums()]) return ( &lt;&gt; &lt;h1&gt; &#123;artist.name&#125; &lt;/h1&gt; &lt;Albums list=&#123;albums&#125; /&gt; &lt;/&gt; )&#125; 客户端请求客户端请求数据适用于这些场景: 部分渲染，部分UI仅在客户端渲染，这部分UI所包含的数据只能从客户端发请求获得 实时数据，如：搜索结果 Server actionserver actions and mutations server actions 是运行在服务端的 async function, 它可以在 server component 和 client component 被调用 声明server actions: &#39;user server&#39; 指令，放在函数声明之前 123456789export default function Page() &#123; // server action async function create() &#123; &#x27;user server&#x27; // todo &#125; return (&lt;div&gt;hi&lt;/div&gt;)&#125; &#39;user server&#39; 指令， 放在代码文件顶部 123456// app/actions.ts&#x27;user server&#x27;export async function create() &#123; // todo&#125; 在client component中，使用server action 123456789// client component// app/ui/button.tsx&#x27;use client&#x27;import &#123; create &#125; from &#x27;@/app/actions&#x27;export function MyButton() &#123; return &lt;Button onClick=&#123;create&#125; /&gt;&#125; Nextjs扩展了 &lt;form&gt; 元素，允许它的 action 属性接收server action useActionState hook, 可以获取server action的执行状态 12345678910111213141516171819202122// app/ui/signup.tsx&#x27;use client&#x27;import &#123; useActionState &#125; from &#x27;react&#x27;// old version react it is called &#x27;useFormState&#x27; // import &#123; useFormState &#125; from &#x27;react-dom&#x27;import &#123; createUser &#125; from &#x27;@/app/actions&#x27;const initialState = &#123; message: &#x27;&#x27; &#125;explort function Signup () &#123; const [state, formAction, pending] = useActionState(createUser, initialState) return ( &lt;form action=&#123;formAction&#125;&gt; &lt;p&gt;&#123;state?.message&#125;&lt;/p&gt; &lt;button disabled=&#123;pending&#125; type=submit&gt;submit&lt;/button&gt; &lt;/form&gt; )&#125; server action 应当被看做一个公开的接口，不过这个接口的地址是一些没有语义的随机字符 常见问题如何在layout中访问请求对象?出于在页面间导航时重用layout的目的，layout.tsx 不能访问原始的request对象。但是，你可以使用headers()和cookies()方法来访问相对的请求信息。 如何访问页面的URL?page默认是server component, 所以无法直接访问URL, 可以使用usePathname和useSearchParams来获取URL, 另外page的props中也有params和searchParams属性, 可以直接访问. Server component中怎样重定向到其他页面?在server component中, 可以使用redirect()或permanentRedirect()方法来重定向到其他页面. 怎样设置cookies? 可以在Server Actions, Middleware or Route Handlers使用cookies()方法来设置cookies.You can set cookies in Server Actions or Route Handlers using the cookies function. 注意: 我们不能在page或layout中直接设置cookies, 因为HTTP不允许在流式传输开始后设置cookies。 总结Next.js是一个强大的React框架，它提供了许多功能，如静态网站生成、服务器端渲染和API路由。通过使用Next.js，我们可以轻松地构建高性能的Web应用程序。","tags":["Nextjs","SSR"],"categories":["Nextjs"]},{"title":"PHP基础知识终章","path":"/2025/01/07/PHP基础知识终章/","content":"常言道：温故而知新，本文会接着介绍一些PHP基础知识，对上篇PHP基础进行补充，形成相对完整的知识体系。 尽可能保持内容简单易懂，希望读后能有所收获 :) 本文例子会常用到一些自定义方法，它们定义在 common.php, 内容如下 12345678910111213141516171819202122232425262728293031323334353637&lt;?phpfunction clog($msg, $tag = &#x27;p&#x27;)&#123; // echo $msg, &quot; &quot;; if (PHP_SAPI === &#x27;cli&#x27;) &#123; echo &quot;[$tag]: &quot; . $msg . &quot; &quot;; &#125; else &#123; echo &quot;&lt;$tag&gt;&quot;, $msg, &quot;&lt;/$tag&gt;&quot;; &#125;&#125;function newline()&#123; echo &quot;&lt;br/&gt;&quot;;&#125;function clogList($arr)&#123; echo &quot;&lt;ol&gt;&quot;; foreach ($arr as $val) &#123; clog($val, &#x27;li&#x27;); &#125; echo &quot;&lt;/ol&gt;&quot;;&#125;function title($ttl, $level = 2)&#123; $tag = &quot;h$level&quot;; clog($ttl, $tag);&#125;function comment($con)&#123; clog(&#x27;:: &#x27; . $con, tag: &#x27;blockquote&#x27;);&#125;?&gt; 常用内置方法isset判断变量是否已定义不确定变量是否存在，可以用isset($varName)先判断，代码更健壮。 1234&lt;?phpecho isset($done) ? &#x27;y&#x27; : &#x27;n&#x27; // necho $color; // 报错 因为变量$color未定义?&gt; unset删除变量 123456&lt;?php$like = true;echo $like; // 1unset($like);echo $like; // 报错 变量已不存在?&gt; exit一般用于提前退出程序，如下代码只输出1-9 die($msg)也可以终止程序 1234567891011121314151617&lt;?phpfunction printNum($i) &#123; if ( $i !== 10 ) &#123; echo $i , &quot; &quot;; &#125; else &#123; exit(0); &#125;&#125;$n = 1;while ($n &lt; 20) &#123; printNum($n); $n++;&#125; var_export导出变量以代码形式表示的字符串，如: var_export(false) sleepsleep($seconds)让程序休眠&#x2F;暂停若干秒 usleep($milsec)休眠指定的毫秒值 123456&lt;?phpinclude &#x27;inc/header.php&#x27;;clog(date(&#x27;H:i:s&#x27;));sleep(5);clog(date(&#x27;H:i:s&#x27;)); empty判断是否为空原始数据类型都有自己预定义的空值，分别为: 0, 空串, false, null;复合数据类型(数组、对象)会转换为字符串再判断是否为空，若对象没有提供转换为string的方法，则会报错 12345678910111213&lt;?phpcomment(&#x27;判断变量为空&#x27;);class MyObj&#123;&#125;$myObj = new MyObj;$arr = array(&#x27;&#x27;, 0, false, null, array(), $myObj);foreach ($arr as $val) &#123; clog(&quot;$val is empty? &quot; . (empty($val) ? &#x27;yes&#x27; : &#x27;no&#x27;)); // array() -&gt; string throw warning // $myObj -&gt; string throw error&#125;?&gt; eval执行代码字符串，这个其实不常用 :) 123&lt;?phpeval(&#x27;echo &quot;you are so nice&quot;;&#x27;);?&gt; listlist()把数组中的值赋给一些变量。list()是语言结构，不是函数。 1234&lt;?php /* 可用于交换多个变量的值 */ list($a, $b) = array($b, $a); list($drink, , $power) = array(&#x27;coffee&#x27;, &#x27;brown&#x27;, &#x27;caffeine&#x27;); 预定义常量 PATH_SEPARATOR 路径分隔符(Windows为分号;，类Unix为冒号:) DIRECTORY_SEPARATOR 目录分隔符 PHP_EOL 当前系统的换行符 PHP_VERSION PHP版本号 PHP_OS PHP服务所在的操作系统 PHP_SAPI 用来判断是使用命令行还是浏览器执行的，如果 PHP_SAPI==&#39;cli&#39; 表示是在命令行下执行 大小写敏感只有变量是区分大小写的，类和函数都忽略大小写 1234567891011&lt;?phpclass Animal &#123; function show() &#123; echo &quot;this is an animal&quot;; &#125;&#125;$a = new animal; // ok 类和函数不区分大小写$c = &#x27;blue&#x27;;echo isset($C) ? &#x27;y&#x27; : &#x27;n&#x27;; // n 变量区分大小写?&gt; 可变标识符前文讲到PHP支持十分动态的语法，其实质就是标识符的可变性，类名、函数名和变量名等不要求是直接字面量，可以是变量的值。 可变变量变量名是变量 shell也支持类似的语法，熟悉shell的同学应该会似曾相识 123456789&lt;?php$color = &#x27;pink&#x27;; $name = &#x27;color&#x27;; echo $$name; // pink$varname = &quot;english&quot;;$$varname = 90;echo($english); // 90?&gt; 可变函数函数名是变量 123456&lt;?phpfunction func() &#123; echo &#x27;hello!&#x27;;&#125;$funName = &#x27;func&#x27;; $funName(); // hello 可变类名类名是变量 1234567&lt;?phpclass Person&#123; public $word = &#x27;hello&#x27;;&#125;$className = &#x27;Person&#x27;; $person = new $className; echo $person-&gt;word; 可变属性对象的属性名是变量 12345678&lt;?phpclass Person&#123; public $word = &#x27;hello&#x27;;&#125;$className = &#x27;Person&#x27;; $person = new $className; $prop = &#x27;word&#x27;;echo $person-&gt;$prop; 可变方法方法名是变量 123456789&lt;?phpclass Car&#123; public function run() &#123; echo &quot;car is running...&quot;; &#125;&#125;$car = new Car;$method = &#x27;run&#x27;;$car-&gt;$method(); 传址赋值变量的赋值通常是传值赋值的，如 $a = $b, 其实是把$b保存的值存入变量$a. 如下变量a,b的值都是10，但是两个10不是同一个，它们所在的内存地址不同。 1234&lt;?php$b = 10;$a = $b; 若采用传址赋值，其实是把b的内存地址传给a, 它们指向同一个10 1234&lt;?php$b = 10;$a = &amp;$b; 常量常量定义定义常量有 define() 和 const 两种方式 语法: define(常量名, 常量值, [isIgnoreCase]) 12345&lt;?phpdefine(&#x27;MAX_TIME&#x27;, 5);const MAX_WIDTH = 200;?&gt; 常量访问访问常量不需要加$前缀，直接访问; 还可以用 constant() 动态访问常量 12345&lt;?phpconst HOST = &#x27;pzj.fun&#x27;;echo HOST;$name = &#x27;HOST&#x27;;echo constant($name); 常量方法常量相关的方法: defined($name) 判断常量是否定义 get_defined_constants() 获取常量数组 123456&lt;?phpconst HOST = &#x27;pzj.fun&#x27;;echo defined(&#x27;HOST&#x27;) ? &#x27;yes&#x27; : &#x27;no&#x27;;print_r(get_defined_constants());?&gt; 进制转换十六进制、八进制、二进制和十进制之间的转换 十进制 decimal, hexdec -&gt; hex to decimal hexdec() 十六进制转十进制 dechex() 十进制转十六进制 bindec() 二进制转十进制 decbin() 十进制转二进制 octdec() 八进制转十进制 decoct() 十进制转八进制 heredoc所见即所得地输出大段文本，支持变量解析 123456789&lt;?php$puntuation = &#x27;!!&#x27;;$con = &lt;&lt;&lt;EOF一壶浊酒喜相逢古今多少事都付笑谈中$puntuationEOF;echo $con; nowdoc所见即所得地输出大段文本，不支持变量解析, $puntuation不会被解析 12345678910&lt;?php$puntuation = &#x27;!!&#x27;;$poem = &lt;&lt;&lt;&#x27;EOF&#x27;秦时明月汉时关，万里长征人未还$puntuationEOF;echo $poem; 数据类型获取数据类型gettype($name) 返回类型的名称 12&lt;?phpecho gettype(&#x27;hi&#x27;); 判断数据类型 is_int() is_float() is_string() is_bool() is_null() is_array() is_object() is_resource() 类型转换专用类型转换函数 boolval() floatval() intval() strval() 通用类型转换函数 settype($var, $typename) 12345&lt;?php$n = &#x27;10&#x27;;echo gettype($n);settype($n, &#x27;int&#x27;);echo gettype($n); 强制类型转换 (typeName) (int) (float) (string) (bool) (array) (object) (unset) 转换为null 1234&lt;?php$a = &#x27;12&#x27;;$v = (int)$a;var_dump($v); // int 文件加载 require require_once include include_once require和include都是加载目标脚本，并执行它的代码；require比较严格，遇到失败时，会终止脚本， include查找路径set_include_path($path) 可以设置include命令在哪些地方查找文件(类似PATH环境变量的设置) get_include_path() 获取当前include查找路径的设置 12345678910&lt;?phpset_include_path(&#x27;./inc&#x27;);include &#x27;common.php&#x27;;comment(&#x27;设置include的查找路径&#x27;);clog(&#x27;set_include_path() 可以简化加载路径的书写&#x27;);var_dump(get_include_path()); // &#x27;./inc&#x27; 函数参数传递形参和实参之间可按值传递，也可按引用传递，默认按值传递。 123456789101112131415161718192021222324252627282930&lt;?phpinclude &#x27;inc/header.php&#x27;;comment(&#x27;参数传递&#x27;);$colors = array(&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;);function update($colorArr)&#123; $colorArr[0] = &#x27;pink&#x27;; print_r($colorArr);&#125;comment(&#x27;默认按值传递，不会修改到实参$colors&#x27;);update($colors);newline();print_r($colors);comment(&#x27;按引用传递,会修改到实参$colors&#x27;);function change(&amp;$colorList)&#123; $colorList[0] = &#x27;purple&#x27;; print_r($colorList);&#125;change($colors);newline();print_r($colors);include &#x27;inc/footer.php&#x27;; 不定参函数可接受任意多个参数的函数，用下来方法获取实参的信息： func_get_args() 调用函数传入实参组成的数组 func_num_args() 获取实参个数 func_get_arg($n) 获取第n个实参 12345678910111213141516&lt;?phpfunction mySum()&#123; $count = func_num_args(); $args = func_get_args(); $first = func_get_arg(0); print_r(array($count, $args, $first)); $result = 0; foreach ($args as $arg) &#123; $result += $arg; &#125; return $result;&#125;$result = mySum(1, 10, 7);clog(&quot;mySum result:&quot; . $result); 返回值传递函数的返回值也分按值传递和按引用传递，默认是按值传递 因为返回值默认按值传递，所以 $outFavs 和 $innerFavs 是不同的数组，修改$outFavs并不会影响$innerFav 123456789101112131415&lt;?phpfunction getFavs()&#123; $arr = array(&#x27;coding&#x27;, &#x27;reading&#x27;); $GLOBALS[&#x27;innerFavs&#x27;] = $arr; return $arr;&#125;$outFavs = getFavs();array_push($outFavs, &#x27;sleeping&#x27;);clog(&quot;outFavs::&quot; . implode(&#x27;, &#x27;, $outFavs));newline();clog(&quot;innerFavs::&quot; . implode(&#x27;, &#x27;, $GLOBALS[&#x27;innerFavs&#x27;]));newline(); 返回值按引用传递，所以 $outMyArr 和 $innerMyArr 是同一个数组，修改$outMyArr并会影响$innerMyArr 1234567891011121314151617// 函数名前加 &amp;, 表示函数可以返回引用function &amp;getMyFavs()&#123; $myArr = array(&#x27;coding&#x27;, &#x27;reading&#x27;); // $GLOBALS[&#x27;innerMyArr&#x27;] = $myArr; // 两者并非指向同一数组 $GLOBALS[&#x27;innerMyArr&#x27;] = &amp;$myArr; // 让两者指向同一数组 return $myArr;&#125;$outMyArr = &amp;getMyFavs();array_push($outMyArr, &#x27;sleeping&#x27;);clog(&quot;outMyArr is:&quot; . implode(&#x27;, &#x27;, $outMyArr));newline();clog(&quot;innerMyArr is:&quot; . implode(&#x27;, &#x27;, $GLOBALS[&#x27;innerMyArr&#x27;]));newline(); 匿名函数可以使用函数作为函数的参数和返回值，声明函数时可以使用 use($param) 来向函数中传入函数外的变量，结合变量引用来实现闭包。 定义匿名函数 1234$func = function ($msg) &#123; echo $msg;&#125;;$func(&#x27;nice to meet you&#x27;); 返回闭包，闭包使用外部变量 12345678910function getSumFunc()&#123; $num1 = 10; $sumFunc = function ($num2) use ($num1) &#123; return $num1 + $num2; &#125;; return $sumFunc;&#125;$sum = getSumFunc();clog($sum(20)); //30 模板语法输出htmlphp支持用特定的模板语法输出html，解决了用echo输出大段html内容的麻烦 12345678910111213141516&lt;?phpinclude &#x27;inc/header.php&#x27;;?&gt;&lt;?php if (isset($_GET[&#x27;admin&#x27;])): ?&gt; &lt;h1&gt;admin user&lt;/h1&gt;&lt;?php else: ?&gt; &lt;h2&gt;normal user&lt;/h2&gt;&lt;?php endif ?&gt;&lt;?phpinclude &#x27;inc/footer.php&#x27;;?&gt; 作用域作用域包括全局作用域和局部作用域.作用域只针对变量，常量没有作用域，可以在所有地方被访问到。通过include &#39;./some.php&#39;载入文件, 被载入文件(some.php)中定义的变量作用域取决于include &#39;./some.php&#39;语句所在的位置。 函数外载入就是全局，函数内载入就是局部！ 数据库相关函数 mysql_connect 连接数据库 mysql_query 发送SQL语句，接收执行结果 仅对select, show, explain, describe语句执行成功返回一个资源标识符，其他语句成功返回true;失败均返回false。 mysql_fetch_assoc 从结果集中取得一行作为关联数组 mysql_fetch_row 从结果集中取得一行作为普通数组 mysql_fetch_array 从结果集中取得一行作为关联数组，或普通数组，或二者兼有 array mysql_fetch_array ( resource $result [, int $ result_type ] ) 可选参数 result_type 可选值为：MYSQL_ASSOC，MYSQL_NUM 和 MYSQL_BOTH(默认) mysql_free_result 释放结果内存 mysql_close 关闭连接 面向对象类成员：类常量、类属性&#x2F;静态属性、类方法&#x2F;静态方法对象成员：实例属性、实例方法对象成员访问用-&gt;(如: $this-&gt;name)，类成员访问用::(如: Animal::count， self::count) 类名、方法名、属性名均不区分大小写$this代表本对象，self代表本类，parent代表父类 访问控制 public 公有的（继承链、本类、外部均可访问） protected 保护的（仅继承链、本类可访问） private 私有的（仅本类可访问） 兼容性问题 声明属性时，var关键字声明的默认为public权限 声明方法时，省略访问修饰符，默认为public权限 重写 override继承时，父类的成员方法不满足需求时，子类可重写同名方法覆盖父类的方法。 重写限制 访问权限限制： 子类的成员的访问控制必须相等或弱于父类 (儿子必须比父亲更开放)。 方法参数限制： 参数数量必须相同，参数名可不同。 final方法如果父类中的方法被声明为final，则子类无法覆盖（重写）该方法。 构造方法类通过构造方法创建实例对象。语法: void __construct([ mixed $args [, $... ]] ) 析构方法析构函数会在到某个对象的所有引用都被删除, 或者当对象被显式销毁时执行。语法: void __destruct( void ) 静态成员(static关键字) 用static声明类成员&#x2F;类方法，它们可通过类直接访问。 静态成员（属性或方法）均属于类，故不能通过$this或-&gt;访问。 静态成员是所有对象共享，属于类。 静态成员用类调用，非静态成员用对象调用。 当在类的外部访问静态成员、方法和常量时，必须使用类的名字。 self 和 parent 用于在类内部对类属性或类方法进行访问 类常量 常量的值将始终保持不变。 在定义和使用常量的时候不需要使用$符号。 常量的值必须是一个定值，不能是变量. 定义类常量：const 常量名 = 常量值; 不需要加public等访问修饰限定符 类常量属于类，使用类访问，类名::类常量 或 self::类常量 抽象类关键字：abstract抽象类不能直接被实例化，必须先继承该抽象类，然后再实例化子类。抽象类中至少要包含一个抽象方法。非抽象类不能包含抽象方法。 接口关键字：interface使用接口可以指定某个类必须实现哪些方法，但不需要定义这些方法的具体内容。 定义接口 123interface Runnable &#123; public function show($info);&#125; 实现接口 12345class Dog implements Runnable &#123; public function show($info) &#123; echo &quot;Hi,&quot; . $info; &#125;&#125; 类与抽象类之间是继承关系，类与接口之间是实现关系。类与抽象类是单继承，类与接口是多实现。 类与对象相关函数 class_exists($class [,$autoload]) 检查类是否已定义 interface_exists($interface [,$autoload]) 检查接口是否已被定义 method_exists($obj, $method) 检查类的方法是否存在 property_exists($class, $property) 检查对象或类是否具有该属性 get_declared_classes(void) 返回由已定义类的名字所组成的数组 get_declared_interfaces(void) 返回一个数组包含所有已声明的接口 get_class([$obj]) 返回对象的类名 get_parent_class([$obj]) 返回对象或类的父类名 get_class_methods($class) 返回由类的方法名组成的数组 get_object_vars($obj) 返回由对象属性组成的关联数组 get_class_vars($class) 返回由类的默认属性组成的数组 is_subclass_of($obj, $class) 如果此对象是该类的子类，则返回TRUE 自动加载类在试图使用尚未被定义的类时自动调用 __autoload 函数 1234function __autoload($class_name) &#123; // $_SERVER[&quot;DOCUMENT_ROOT&quot;] 当前运行脚本所在的文档根目录 require_once $_SERVER[&quot;DOCUMENT_ROOT&quot;] . &quot;/class/$class_name.php&quot;;&#125; spl_autoload_register 可以注册多个自动加载函数，先注册的先执行; 一旦注册自动加载函数，__autoload 就失效。语法: bool spl_autoload_register ([ callback $autoload_function ] ) 序列化数据通过网络传输或保存到硬盘前，需要先进行序列化；序列化在存放数据时，也会存放数据类型。语法: string serialize ( mixed $value ) 反序列化unserialize 从已存储的表示中创建PHP的值语法: mixed unserialize ( string $str [, string $callback ] ) 反射机制 Reflection反射的主要作用： 获取结构信息 代理执行 ReflectionClass 报告一个类的有关信息 ReflectionMethod 报告一个方法的有关信息 ReflectionClass::export 输出类结构报告 代理执行实例化 ReflectionFunction 类的对象 12345678&lt;?phpfunction sayHi($msg)&#123; echo &quot;hello &quot;, $msg;&#125;$refFunc = new ReflectionFunction(&#x27;sayHi&#x27;);$refFunc-&gt;invoke(&#x27;alice&#x27;); 文件系统访问文件的读写操作 file_put_contents 将一个字符串写入文件 语法: int file_put_contents($file, $data [,$flags]) file_get_contents 将整个文件读入一个字符串 语法：string file_get_contents($file [, bool $use_include_path [,int $offset [,int $maxlen]]]) HTTP相关方法设置响应头123&lt;?phpheader(&#x27;Location: http://demo.com/login.php&#x27;);header(&#x27;Content-Type: application/json&#x27;); 设置cookie语法: setcookie($name [,$value [,$expire [,$path [,$domain [,$secure [,$httponly]]]]]]) 通过超全局变量 $_COOKIE 读取cookie数据 注意：setcookie()函数前不能有输出, 除非开启ob缓存！ 设置session开启session机制, session_start()通过超全局变量 $_SESSION 读取session数据 session_destroy() 销毁保存session数据的文件 注意：session_start()函数前不能有输出！除非开启ob缓存。 正则 preg_replace($pattern, $replace, $subject [,$limit [,&amp;$count]]) 执行正则替换 preg_grep($pattern, $input [,$flags]) 返回匹配模式的数组条目 preg_match($pattern, $subject [,&amp;$matches [,$flags [,$offset]]]) 执行正则匹配 preg_split($pattern, $subject [,$limit [,$flags]]) 通过正则分隔字符串 数据库抽象层PDO: PHP Data ObjectsPHO抽象层默认被加载，但需加载相应数据库的驱动。 PDO是OOP语法，提供三个类： PDO：PDO自身 PDOStatement：PDO语句类，提供对语句的后续处理 PDOException：PDO异常类，提供对错误的异常处理 预处理式执行SQL, 防止sql注入风险 PDOStatement PDO::prepare(string $statement) bool PDOStatement::bindParam ( mixed $parameter , mixed &amp;$variable ) bool PDOStatement::execute ([ array $input_parameters ] ) 日期时间函数 time() 返回当前的Unix时间戳(秒) date($format [,$timestamp]) 格式化一个本地时间／日期，$timestamp默认为time() microtime([$get_as_float]) 返回当前Unix时间戳和微秒数 strtotime($time [,$now]) 将日期字符串解析为Unix时间戳 mktime() 获取指定日期的时间戳 strftime($format [,$timestamp]) 根据区域设置格式化本地时间／日期 date_default_timezone_get($timezone) 获取默认时区 date_default_timezone_set($timezone) 设置默认时区 数组函数 array_chunk 将一个数组分割成多个 array_filter 用回调函数过滤数组中的元素 array_slice 数组中取一个片段 array_keys 返回数组中所有的键名 array_values 返回数组中所有的值，并建立数字索引 array_merge 合并一个或多个数组 in_array 检查数组中是否存在某个值 array_reverse 返回一个单元顺序相反的数组 array_splice 把数组中的一部分去掉并用其它值取代 array_unique 移除数组中重复的值 implode 将数组元素值用某个字符串连接成字符串 explode 使用一个字符串分割另一个字符串 array_map 将回调函数作用到给定数组的单元上，只能处理元素值，可以处理多个数组 array_walk 对数组中的每个成员应用指定函数，与foreach功能相同 array_push 在末尾添加元素(入栈) array_pop 把末尾元素弹出(出栈) array_unshift 在开头添加元素 array_shift 将数组开头的元素移除 总结PHP确实是一门比较全面的程序语言，支持面向对象、模块化、命名空间和闭包等特性，至于它是否是最好的语言，这个问题就见仁见智了。 通过这两篇PHP基础知识的讲解，相信要看懂PHP代码应该没什么问题；如果有用到 CMS , Wordpress 和免费虚拟机的话，我们要做一些功能修改时会更加得心应手。","tags":["PHP"],"categories":["PHP"]},{"title":"软硬链接小白文","path":"/2024/12/13/软硬链接小白文/","content":"转载自: https://blog.csdn.net/weixin_42301220&#x2F;article&#x2F;details&#x2F;134520854 1. 软链接和硬链接简介 什么是软链接软链接(Symbolic Link),也称为 符号链接 ,是包含了源文件位置信息的特殊文件。它的作用是间接指向一个文件或目录。如果软链接的源文件被删除或移动了,软链接就打不开了。 什么是硬链接硬链接(Hard Link)指通过索引节点(inode)来进行链接。在Linux系统中,每个文件都有一个对应的索引节点,记录文件的日期,大小,所在块等信息。硬链接就是指向源文件索引节点的连接。删除源文件,不影响硬链接的访问。 会有多个硬链接指向源文件索引节点，所有硬链接都被删除时，源文件才会真正被删除ls -l -i 可查看硬链接的个数, 和索引节点序号find -type f -inum &#123;inodeNumber&#125; 可查看指定索引节点的所有硬链接 软链接和硬链接的区别 软链接是一个特殊的独立文件,它内容记录源文件位置;硬链接只是源文件的引用,不占用实际空间。 删除软链接不影响源文件：删除源文件,软链接失效。删除硬链接不影响源文件,需将源文件和全部硬链接删除,源文件才会删除（换句话说，如:rm -f nami.jpg 只是删除了其中一个硬链接，通过其他硬链接访问依旧有效）。 软链接可以跨分区;硬链接不能跨文件系统。 软链接可以针对目录;硬链接不能针对目录。 2. 软链接使用 创建软链接的语法 1ln -s 源文件或目录 软链接的文件或目录 -s 参数表示创建的是软链接。 创建软链接示例 12# 将test.txt软链接到test_linkln -s test.txt test_link 这样就在当前目录下创建了一个test_link的软链接文件,它指向test.txt。如下图，可以看到test_link ，箭头就表示它是一个链接。我们可以直接通过访问&#x2F;修改test_link 来访问&#x2F;修改test.txt的内容。 使用ll命令可以看到软链接的相关信息: 12345ll test_linkvim test_link# 能看到修改后的内容cat test.txt 为目录创建软链接软链接可以为目录创建快捷方式，方式与为文件创建软链接类似： 12# 将/usr/local/dir1目录软链接到dir1_linkln -s /usr/local/dir1 dir1_link 这样访问dir1_link就相当于访问dir1目录中的内容。 修改和删除软链接删除或修改软链接不会影响源文件&#x2F;目录,它只是一个普通文件。 删除软链接 123rm test_link#或者unlink test_link 修改软链接，修改软链接的指向后， test_link 指向 test2.xt 1ln -sf test2.txt test_link 3. 硬链接使用方法 创建硬链接语法 1ln 源文件 硬链接名 不使用-s参数默认创建硬链接。 创建硬链接示例 1ln test.txt test_hardlink 这样就在当前目录下创建了一个test_hardlink的硬链接文件,指向test.txt 查看硬链接信息使用ll命令可以看到硬链接信息: 1ll test_hardlink 可以看到test_hardlink是一个硬链接文件,指向test.txt, 索引节点相同。 修改和删除硬链接删除或修改硬链接不影响源文件,它只是一个目录项引用源文件的索引节点。 删除硬链接 123rm test_hardlink # 或者unlink test_hardlink 修改硬链接内容, 源文件内容将跟着一起变化。 1vim test_hardlink 为目录创建硬链接硬链接无法针对目录进行创建。 12ln dir1 dir1_hardlinkln: failed to create hard link ‘dir1_hardlink’ =&gt; ‘dir1’: Invalid argument 4. 总结 软链接通过指向源文件的路径建立链接,硬链接通过索引节点建立链接。 软链接可以跨文件系统,硬链接不能。软链接可以对目录创建链接,硬链接不可以。 删除软链接和硬链接都不影响源文件。 解除软链接和硬链接,直接删除链接文件即可。"},{"title":"HTTP的三次握手","path":"/2024/12/11/HTTP的三次握手/","content":"转载自: https://segmentfault.com/a/1190000045536632 HTTP和HTTPS的握手与挥手过程详解在网络通信中，HTTP 和 HTTPS 是常见的协议，它们分别用于无加密和加密的请求与响应过程。尽管它们的基本工作原理相似，但由于安全性要求，HTTPS需要比HTTP更复杂的步骤来确保数据传输的加密性和完整性。下面将详细解释HTTP与HTTPS的握手和挥手过程，并对两者进行对比。 一、HTTP的三次握手过程三次握手是客户端与服务端之间建立TCP连接的过程，确保连接的可靠性。 客户端发送SYN包客户端向服务器发送一个 SYN（同步）包，告诉服务器它希望建立连接。此时客户端处于 SYN_SEND 状态，等待服务器的响应。 服务端回应SYN-ACK包服务端接收到SYN包后，表示同意建立连接，于是发送一个 SYN-ACK（同步-确认）包给客户端。服务端处于 SYN_RCVD 状态。 客户端回应ACK包客户端收到SYN-ACK包后，向服务端发送 ACK（确认）包。此时，客户端和服务端都处于 ESTABLISHED（已建立连接）状态，三次握手完成，数据传输可以开始。 HTTP的三次握手示意图： 1234客户端 服务端 |--------------------SYN------------------&gt;| |&lt;------------------SYN-ACK-----------------| |-------------------ACK-------------------&gt;| 二、HTTPS的三次握手过程HTTPS除了包含HTTP的三次握手外，还涉及到SSL&#x2F;TLS协议的握手，这一过程更为复杂，主要用于确保通信的安全性。 客户端发送ClientHello客户端向服务端发送一个 ClientHello 消息，包含其支持的加密算法（如RSA、ECDSA等）、支持的协议版本、压缩方法以及生成的随机数等信息。 服务端发送ServerHello并发证书服务端收到ClientHello后，选择一种加密算法并返回 ServerHello 消息，发送其数字证书以便客户端验证其身份。 客户端验证证书并生成PreMasterSecret客户端验证服务端的证书是否有效，如果有效，则生成一个 PreMasterSecret，通过服务端的公钥加密后发送给服务端。 双方生成会话密钥并确认服务端使用私钥解密PreMasterSecret，并与客户端各自生成会话密钥。最后，双方通过 Finished 消息确认握手过程已完成，进入加密通信阶段。 HTTPS的握手示意图： 12345客户端 服务端 |------------------ClientHello----------------&gt;| |&lt;---------------ServerHello + Cert------------| |----------------PreMasterSecret -------------&gt;| |&lt;------------------Finished-------------------| 三、HTTP的四次挥手过程TCP连接的关闭需要四次挥手，以确保双方都能正确地关闭连接，避免数据丢失。 客户端发送FIN包客户端没有数据发送时，发送一个 FIN（结束）包，告知服务端关闭连接。 服务端回应ACK包服务端接收到FIN包后，发送一个 ACK（确认）包，表示已收到关闭请求。 服务端发送FIN包服务端在完成数据发送后，发送一个 FIN 包给客户端，表示它也希望关闭连接。 客户端回应ACK包客户端收到服务端的FIN包后，发送一个 ACK 包确认。此时，连接正式关闭。 HTTP的四次挥手示意图： 12345客户端 服务端 |-------------------FIN---------------------&gt;| |&lt;------------------ACK-----------------------| |&lt;------------------FIN-----------------------| |-------------------ACK---------------------&gt;| 四、HTTPS的四次挥手过程HTTPS在四次挥手的基础上还涉及到SSL&#x2F;TLS协议层的关闭。过程与HTTP相似，但由于加密数据的处理，握手和挥手过程相对复杂。 客户端发送关闭连接请求客户端发送一个关闭连接的消息，要求关闭SSL&#x2F;TLS会话。 服务端回应关闭连接消息服务端回应关闭连接的消息，表示同意断开SSL&#x2F;TLS会话。 服务端发送关闭连接请求服务端发送关闭连接的消息，告知客户端服务端即将断开连接。 客户端回应关闭连接消息客户端回应关闭连接消息，最终完成SSL&#x2F;TLS连接的断开。 五、HTTP与HTTPS的区别与联系 项目 HTTP HTTPS 加密 不加密，数据传输明文 使用SSL&#x2F;TLS协议加密，确保数据安全性 安全性 无数据保护，容易受到中间人攻击（MITM） 使用证书进行身份验证，防止伪装与篡改数据 握手过程 三次握手，简单的TCP连接建立过程 三次握手与SSL&#x2F;TLS握手结合，安全性更高 挥手过程 四次挥手，TCP连接正常关闭 四次挥手，确保加密连接断开 端口 80端口 443端口 六、总结 HTTP与HTTPS都依赖于TCP连接的三次握手和四次挥手过程，但HTTPS在这基础上增加了SSL&#x2F;TLS协议层的加密与身份验证，确保数据传输的机密性和完整性。 HTTPS的握手和挥手过程更为复杂，需要进行数字证书验证、密钥交换等步骤，因此它比HTTP更加安全。 在设计网络通信系统时，选择使用HTTP还是HTTPS取决于是否需要保障数据的安全性。如果数据传输涉及敏感信息，强烈建议使用HTTPS。"},{"title":"SQL基础入门","path":"/2024/12/10/SQL基础入门/","content":"转载自: https://segmentfault.com/a/1190000045376785 MySQL是什么Mysql是一个数据管理系统，管理的是数据库，mysql下可以管理多个数据库。 关系数据库中用表存储信息。 支持连接数100个用户 MySQL基本指令DDL查看数据库：1show databases; 进入数据库：1use 数据库名; 查看数据库的表：1show tables; 新建数据库：1create database 数据库名; 删除数据表：1dorp table 表名 sql插入数据：12345insert into 表名（字段，字段）value（数据，数据）;# 如果要插入所有列的数据，可以不标明列名，但是插入的值，必须按照列的顺序。insert into 表名 value（数据，数据，数据）；# 可以一行sql，使用values插入多条数据。insert into 表名 value（数据，数据，数据），（数据，数据，数据）; 删除数据：1delete from student where name=&#x27;王刚&#x27;; 修改数据：1update student set age=20 where name=’李白‘; DQL（查询）查询语句：12select * from student； 查询student表中的所有数据。select student_id,student_name from student; 查询指定的列名。 注意事项：在工作环境中不要（尽量避免）使用 * 查询 数据安全 IO 网络三方面。 可以使用as对列名起别名。对结果集的列命名 as name name是蓝色的 关键字 有些关键字会改变语法语义可以使用着重号`` 条件查询：根据指定的条件，检索数据，返回执行结果。 12select student_id,student_name,birthday,gender from student where student_name=&#x27;李四&#x27;; 多条件查询：1234select student_id,student_name,birthday,gender from student where student_name=&#x27;李四&#x27; and student_id = 9;select student_id,student_name,birthday,gender from student where student_name=&#x27;李四&#x27; or gender = &#x27;女&#x27;; 使用in 关键字匹配多个值1SELECT * FROM student WHERE student_id IN (1,3,8,10,12); 也可以使用not in 排除匹配项 1SELECT * FROM student WHERE student_id NOT IN (1,3,8,10,12); 模糊查询：查询学生表中姓名姓张的学生： 1SELECT * FROM student WHERE student_name LIKE &#x27;张%&#x27; 查询学生表中姓名三个字的学生： 1SELECT * FROM student where student_name LIKE &#x27;___&#x27;; 查询学生表中姓名姓张两个字的学生： 1SELECT * FROM student WHERE student_name LIKE &#x27;张_&#x27;; 查询学生表中姓名带张的学生： 1SELECT * FROM student WHERE student_name LIKE &#x27;%张%&#x27;; 排序：排序方式 order by 正序（升序） ASC （默认） 倒序 （倒叙）DESC 1SELECT * FROM student ORDER BY student_id DESC; 也可以使用多列进行排序 当第一列的值相同时再通过第二列的内容进行排序 1SELECT * FROM student ORDER BY student_name,student_id DESC; 以上的sql语句order by 之后按照student_name 正序排列，student_id倒序排序 每一列都有自己的排序方式，不写就是默认 ASC 部分查询：(LIMIT)从零开始部分查询 比如查询前三名 查询前三个数据 LIMIT 1select * FROM student LIMIT 3; 查询4-7 1select * from student limit 3,4; 前三名就是 1select * from student limit 0,3; 合并查询：union 和union all 都有合并多个sql语句的作用 union 会将结果一样的数据合并一个（去重）（整体去重） union 前后关联的结果集的列数必须一样和类型无关 1select student_id from student union select * from student; 结果去重：（DISTINCT） 1SELECT DISTINCT name FROM student; 注意：以上SQL语句DISTINCT是对结果集去重，并不是对name去重 嵌套查询和关联查询嵌套查询一个查询语言中嵌套这另一个查询 实例 有不及格成绩的学生的信息 -- 成绩表中不及格的信息 1SELECT * FROM score WHERE score &lt; 60; -- 有不及格成绩的学生的信息 方式一 12SELECT DISTINCT * FROM student,score WHERE score.score &lt; 60 and student.student_id = score.student_id; 方式二 12SELECT student_name FROM student WHERE student_id in (SELECT DISTINCT student_id FROM score WHERE score &lt; 60); 将子查询当做一个表进行二次查询 -- 总成绩最高的学生id 12SELECT * FROM( SELECT student_id,SUM(score) as sumscore FROM score GROUP BY student_id )as a ORDER BY sumscore DESC LIMIT 1; -- 当将子查询当做表进行二次查询 需要给子查询起别名 关联查询-- 当我们所需要的查询结果在两张表或者多张表中，这是就需要关联查询。 -- 查询 学生的名字和成绩 学生名字在student 成绩 score -- 将多个表的数据按照一定的条件 关联在一器 -- 左连接 右连接 -- left join 以左表为主表 结果集中包含主表的所有数据,结果集中显示副表中和主表有关联的数据 1SELECT a.*,b.* FROM student a left JOIN score b on a.student_id = b.student_id; -- 内链接 只显示两个有关联的数据 1SELECT a.*,b.* FROM student a INNER JOIN score b ON a.student_id = b.student_id; -- mysql不支持全外链接 full join Oracle 支持 -- mysql 借助union实现全外链接 123SELECT a.*,b.* FROM student a left JOIN score b on a.student_id = b.student_id; UNION SELECT a.*,b.* FROM student a RIGHT JOIN score b on a.student_id = b.student_id; 注意事项：NULL值 sql中对空值的判断 不能用&#x3D; 使用is,非空验证用 not null 数据库的常用类型整数类型 tinyint（0-255）1字节 int 4字节 文本 char（定长） varchar（变长） text 浮点型 double（7，2） decimal（10，2） 时间 double是双精度的，而decimal是精确的我们建议使用decimal保存金融、汇率、税率、价格等 数据库是需要优化的,其中之一是选择合适的数据类型 start transaction 开始一个事务 savepoint 保存点名–设置保存点 rollback to 保存点名–回退事务 rollback 回退全部事务 commit 提交事务，所以的操作生效， 不能回退 12345678910111213141516171819202122232425create table TEXT( id int, name VARCHAR(32));-- 开启事务start TRANSACTION--设置保存点SAVEPOINT a-- 执行dml操作INSERT INTO TEXT values(100,&#x27;tom&#x27;);--设置保存点bSAVEPOINT b-- 执行dml操作INSERT INTO TEXT values(200,&#x27;jack&#x27;);select * from TEXT;-- 回退到brollback to b-- 回退到arollback to a 事务管理回退事务在介绍回退事务前，先介绍一下保存点（savepoint）保存点是事务中的点，用于取消部分事务，当结束事务时（commit），会自动的删除该事务所定义的所有保存点，当执行回退事务时，通过指定保存点可以回退到指定的点。 提交事务使用comit语句可以提交事务，当执行了commit语句后，会确认事务的变化、结束事务、删除保存点、释放锁，数据生效。当使用commit语句结束事务之后，其他会话将可以查看到事务变化后的新数据。 tips：如果不开始事务，默认情况下，DML操作是自动提交的，不能回滚。mysql 的事务需要存储引擎为innodb ，而myisam 不支持。 savepoint（保存点）SAVEPOINT 通过自定义的名称设置一个存储点，如果当前事务已经有了一个同名的 SAVEPOINT ，那么旧的将会被替代。 ROLLBACK TO SAVEPOINT 子句可以将当前事务回退到自定义的存储点位置，而不会结束事务，InnoDB 不会释放内存中的行锁（对于新插入的行，锁信息是由存储在行中的事务ID携带，而不会单独存储在内存中，那么对于这类锁，是会被释放的），存储点之后语句都会撤销执行，包括新设置的存储点，也同样会被删除。 RELEASE SAVEPOINT 子句，会从当前的事务 SAVEPOINT 集合中，移除指定名称的 SAVEPOINT 。 隔离级别事务隔离级别介绍多个连接开启各自事务操作数据库中数据时，数据库系统要负责隔离操作，以保证各个连接在获取数据时的准确性。 脏读（dirty tead）当一个事务读取另一个事务尚未提交的修改时，产生脏读。 不可重复读（nonrepeatable read）同一查询在同一事务中多次进行，由于其他提交事务所做的修改或删除，每次返回不同的结果集，此时发生不可重复读。 幻读（phantom read）同一查询在同一事务中多次进行，由于其他提交事务所做的插入操作，每次返回不同的结果集，此时发生幻读。 查看当前会话隔离级别 select @@transaction_isolation;查看系统当前级别 select @@global.tranction_isolation;设置隔离级别 set session transaction isolation level read uncommitted设置系统隔离级别 set global transaction isolation level read uncommittedACID事务acid特性 原子性： 原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 一致性： 事务必须使数据库从一个一致性状态变换到另外一个一致性状态。 隔离性： 事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。 持久性： 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。 数据库面试问题mb3和mb4有什么区别1首先m表示max，b表示byte，mb3表示一个字符最多占用三个byte同理mb4占用4个，最大的不同在于mb4比mb3多出来的一字节可以表示表情文字。英文占用一个字节、中东地区的阿拉伯语占2字节，东亚地区语言占3字节。 数据库连接命令是什么1234567mysql -u root -p；-u：代表用户root是超级用户-p： 是密码 varchar和char的区别1varchar是可变的文本类型更加灵活，节省空间，但是char类型的性能更好特别是查询数据时。","tags":["SQL"],"categories":["SQL"]},{"title":"web开发的趁手兵器Fiddler","path":"/2024/11/28/web开发的趁手兵器Fiddler/","content":"Fiddler 是什么Fiddler 是一个 http 调试代理工具，可以用来查看、修改、重发、保存客户端和服务器之间的 http 通讯，也可以用来测试网站性能，诊断网络问题。Fiddler 充当客户端和服务器之间的中间人，客户端和服务器之间的Http通信都经过 Fiddler，从而可以查看和修改通信内容。 中间人攻击也是采用相同的原理，即使是Https的请求，也可以被抓取和解密 Fiddler只能抓取应用层的Http通信，如果要查看更底层的通信细节，可以用 white sharps，wireshark 等工具。 Fiddler 可以抓取localhost域名下的网络请求 捕获 http 通讯 打开 fiddler，点击 file/capture traffic，或者直接按 F12，开始捕获 http 通讯。 在 session list 中可以看到捕获到的 http 通讯。 查看请求和响应 在 session list 中，双击一个 session，可以看到该 session 的请求和响应。 在 Inspectors 中，可以看到请求和响应的详细信息，包括请求头、响应头、响应体等。 抓取手机上的 http 通讯 设置允许远程设备连接 允许远程设备连接 tools/fiddler options/connection/allow remote computers to connect 手机安装 fiddler 证书 手机浏览器打开 yourIP:8888 选择会话 任意多选 ctrl + click 多选连续的会话 shift + click 向上&#x2F;向下单选 ctrl + up/down 向上&#x2F;向下连续多选 ctrl + shfit + up/down 反选会话 ctrl + i 焦点先定位到 session list 选择当前会话的父会话 P 很实用的功能，比如选择一个 js, 按P，就会定位到触发该js请求的html请求 选择当前会话的子会话 C 同样实用：选择 html 请求，按C, 定位所有由该 html 请求触发的静态资源请求 查找会话ctrl + f 打开查找对话框，可以设置只查找请求或只查找响应，查找内容可以指定header或body, 基本上可以满足大部分需求。 会话对比选择两个会话，右键 选择 compare 命令(需安装对比工具 winMerge), 对比成功和失败的两次请求，方便找出差异。 删除会话 删除选中会话 delete 删除未选中会话 shift + delete 同先反选ctrl+i, 再删除 删除所有会话 ctrl + x 配置hosts可以通过Fiddler配置DNS映射，这样就不必在C盘的hosts文件中修改了。 Hosts配置位于菜单 Tools/Hosts quickboxquickbox 是 fiddler 的一个工具栏，可以快速执行一些操作, 如: 查找会话，设置断点等。 alt + q 光标定位到 quickExec。 查找会话 在url根据关键字查找 ? keyword 根据content-type查找 select image, select json 根据hostname查找 @target Hostname 根据响应的status查找 =304 根据请求方法查找 =post 根据content-length查找 &gt;1000 根据域名查找 @google 根据请求头查找select @Request.Accept html 根据响应头查找 select @Response.set-cookie domain 高亮会话 设置高亮url包含关键字的会话 bold /app.js 实用功能: 后续捕获的匹配会话也会被高亮 取消高亮 bold 过滤会话 根据content-type过滤，allbut image 删除所有会话，image会话除外 根据content-type过滤 keeponly image 只保留image会话, 作用同上 断点 设置断点，断点类型为 before request, url包含baidu的请求都会被中断 bpu baidu 清除断点 bpu bpu 不带参数，则表示清除断点 设置断点，断点类型为 after response, url包含baidu的响应都会被中断 bpafter baidu 清除断点 bpafter bpafter 不带参数，则表示清除断点 执行断点 go 在 inspector 面板修改请求&#x2F;响应内容后继续执行 根据请求方法设置断点 bpm POST 清除 bpm 断点 bpm 根据响应状态码设置断点 bps 404 清除 bps 断点 bps 修改请求url可以把请求url的域名修改为本地ip，方便调试 设置url替换 urlreplace www.dev.com localhost 清除url替换 urlreplace 删除所有会话 清除所有会话 cls 清除所有会话 clear 构造请求可以全新创建请求，或基于现有session创建请求 compose 面板中，手动创建所有的请求参数 拖一个 session 到 compose 面板中，修改并发送改请求 按住shift, 点击 execute 按钮 , 会在请求发出前断点，允许再次修改 autoResponder 自动响应从左侧拖一个 session 到 autoresponder 中，默认会自动创建匹配规则和响应内容 基于session创建的autoresponse, 默认规则精确匹配(EXACT:the-url)，默认响应为该 session 的 response(*200-SESSION-6) 用户可修改匹配规则，亦可修改响应内容，在 rule list 中选择该 rule, 按enter编辑响应内容。 自动响应的匹配规则 普通字符串，匹配URL包含该字符串的请求 hello.com NOT:普通字符串，匹配URL不包含该字符串的请求 NOT: hello.com 通配符匹配所有请求 * 精确匹配，URL完全相同的请求 EXACT: http://localhost/test.php?foo=BAR 正则匹配 regex:(?inxs)http://localhost/\\w+\\.php , regex:.+(gif|png|jpg)$正则修饰符: i ignore case 忽略大小写 n requires explicit capture groups 要求明确的捕获组 s enables single-line syntax 单行 x enables comments after the #character 支持# 后加注释 自动响应的内容 本地文件 http://targetUrl 重定向到目标url *redir:http://targetUrl *bpu 请求前断点 *bpafter 响应前断点 *delay: Xms 延迟发出请求 *header: hi=hello 修改&#x2F;新增请求头 *CORSPreflightAllow 返回允许跨域的 header *reset Reset the client connection *drop close the client connection *exit 该规则什么都不做,让后续规则处理 自动响应示例将正则规则捕获到的参数，应用到目标 url 12rule: regex:youdao\\.com(.\\*)action: http://localhost/test.php$1 FiddlerScriptFiddler Script 是用 JScript.NET 语言写的，可以自动修改 Request 和 Response. 这样我们就无需手动设置”断点”。 Fiddler Script实际上它是一个脚本文件 CustomRules.js ，保存在 C:\\Users\\sea\\Documents\\Fiddler2\\Scripts\\CustomRules.js 打开 Fiddler Script， 点击菜单 Rules-&gt;Customize Rules 或者 ctrl + r 主要方法12345678// 在这个方法中修改Request的内容， 我们用得最多,static function OnBeforeRequest(oSession: Session)// 在这个方法中修改Response的内容，static function OnBeforeResponse(oSession: Session) 常用对象和方法fiddlerScript Editor 有智能提示 对象 oSession oSession.url, oSession.fullUrl, oSession.host, oSession.hostname, oSession.oRequest, oSession.oResponse, oSession.HostNameIs(), oSession.uriContains() FiddlerObject FiddlerObject.log() 方法 字符串处理方法 replace(), indexOf(), substring() 例子高亮请求 和 打印日志 12345678function onBeforeRequest(oSession) &#123; if(oSession.HostNameIs(&#x27;www.cnblogs.com&#x27;)) &#123; oSession[&#x27;ui-color&#x27;] = &#x27;red&#x27; FiddlerObject.log(oSession.url) // 不带 http:// FiddlerObject.log(oSession.fullUrl) // 带 http:// &#125;&#125; 添加&#x2F;删除 请求头 12345678function OnBeforeRequest(oSession) &#123; oSession.oRequest[&#x27;x-hi&#x27;] = &#x27;hello&#x27;; oSession.RequestHeaders.Add(&#x27;foo&#x27;, &#x27;foolish&#x27;); oSession.RequestHeaders.Remove(&#x27;Cache-Control&#x27;); // 删除请求头 // or use oRequest oSession.oRequest.headers.Add(&#x27;foo&#x27;, &#x27;foolish&#x27;); oSession.oRequest.headers.Remove(&#x27;Cache-Control&#x27;);&#125; 添加响应头部 支持 CORS 12345function onBeforeResponse(oSession) &#123; if(oSession.HostNameIs(&#x27;www.test.com&#x27;)) &#123; oSession.ResponseHeaders.Add(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;http://10.66.51.87:9091&#x27;) &#125;&#125; 将请求重定向到其他主机 1234567891011121314function OnBeforeRequest(oSession) &#123; if(oSession.HostnameIs(&#x27;test.com&#x27;)) &#123; // test.com:90/foo/bar -&gt; localhost:90/foo/bar oSession.hostname = &#x27;localhost&#x27;; &#125; if(oSession.host == &#x27;foo.com:90&#x27;) &#123; oSession.host = &#x27;bar.com:9012&#x27;; // host == hostname:port &#125; if(oSession.fullUrl.indexOf(&#x27;http://www.foo.com&#x27;) == 0) &#123; oSession.fullUrl = oSession.fullUrl.replace(&#x27;http://www.foo.com&#x27;, &#x27;https://www.bar.com&#x27;) &#125;&#125; 将一个 url 重定向到另外的 url 123456function OnBeforeRequest(oSession) &#123; if(oSession.url == &#x27;example.com/test.js&#x27;) &#123; // oSession.url 不包括protocol oSession.url = &#x27;localhost.com/mock-test.js&#x27;; &#125;&#125; 取消发送 cookie 123function OnBeforeRequest(oSession) &#123; oSession.oRequest.headers.Remove(&#x27;Cookie&#x27;);&#125; 替换 html 文件的内容 1234567function OnBeforeResponse(oSession) &#123; if(oSession.HostnameIs(&#x27;www.test.com&#x27;) &amp;&amp; oSession.oResponse.headers.ExistsAndContains(&#x27;Content-type&#x27;, &#x27;text/html&#x27;)) &#123; var body = oSession.GetResponseBodyAsString(); body = body.replace(&#x27;foo&#x27;, &#x27;bar&#x27;); oSession.utilSetResponseBody(body); &#125;&#125; 替换 json 文件的内容 12345678function OnBeforeResponse(oSession) &#123; if(oSession.HostnameIs(&#x27;www.test.com&#x27;) &amp;&amp; oSession.oResponse.headers.ExistsAndContains(&#x27;Content-type&#x27;, &#x27;application/json&#x27;)) &#123; var body = oSession.GetResponseBodyAsString(); var json = JSON.parse(body); json.name = &#x27;bar&#x27;; oSession.utilSetResponseBody(JSON.stringify(json)); &#125;&#125;"},{"title":"二维码登录详解","path":"/2024/11/04/二维码登录详解/","content":"转载自: https://juejin.cn/post/7389952503041884170 前言二维码其实是一个包含参数的链接，二维码登录就是通过用包含登录态的手机扫描二维码，将参数和token传递给后端，请求授权登录到展示二维码系统，从而实现登录。 二维码登录让用户省去了输入账号密码的麻烦。 登录简单点来说可以概括为俩点 告诉系统我是谁 向系统证明我是谁 下面我们就会围绕着这俩点来展开详细说明 原理解析其实大部分的二维码就是一个url地址 我们以掘金扫码登录为例来进行剖析 我们进行一个解析 juejin.cn&#x2F;app?next_ur… 我们可以发现它实际就是这样的一个url 整个三端交互的过程大概是这样子的： 流程概述简单来说氛围下面的步骤： PC端：进入二维码登录页面，请求服务端获取二维码的ID。 服务端：生成二维码ID，并将其与请求的设备绑定后，返回有效的二维码ID。 PC端：根据二维码ID生成二维码图片，并展示出来。 移动端：扫描二维码，解析出二维码ID。 移动端：使用移动端的token和二维码ID请求服务端进行登录。 服务端：解析验证请求，绑定用户信息，并返回给移动端一个用于二次确认的临时token。 PC端：展示二维码为“待确认”状态。 移动端：使用二维码ID、临时token和移动端的token进行确认登录。 服务端：验证通过后，修改二维码状态，并返回给PC端一个登录的token。 下面我们来用一个python的代码来描述一下这个过程。 首先是服务端： 123456789101112131415161718192021222324252627282930313233343536373839404142from flask import Flask, request, jsonifyimport uuidimport time​app = Flask(__name__)​# 存储二维码ID和对应的设备信息以及临时tokenqr_code_store = &#123;&#125;temporary_tokens = &#123;&#125;​@app.route(&#x27;/generate_qr&#x27;, methods=[&#x27;POST&#x27;])def generate_qr(): device_id = request.json[&#x27;device_id&#x27;] qr_id = str(uuid.uuid4()) qr_code_store[qr_id] = &#123;&#x27;device_id&#x27;: device_id, &#x27;timestamp&#x27;: time.time(), &#x27;status&#x27;: &#x27;waiting&#x27;&#125; return jsonify(&#123;&#x27;qr_id&#x27;: qr_id&#125;)​@app.route(&#x27;/scan_qr&#x27;, methods=[&#x27;POST&#x27;])def scan_qr(): qr_id = request.json[&#x27;qr_id&#x27;] token = request.json[&#x27;token&#x27;] if qr_id in qr_code_store: qr_code_store[qr_id][&#x27;status&#x27;] = &#x27;scanned&#x27; temp_token = str(uuid.uuid4()) temporary_tokens[temp_token] = &#123;&#x27;qr_id&#x27;: qr_id, &#x27;timestamp&#x27;: time.time()&#125; return jsonify(&#123;&#x27;temp_token&#x27;: temp_token&#125;) return jsonify(&#123;&#x27;error&#x27;: &#x27;Invalid QR code&#x27;&#125;), 400​@app.route(&#x27;/confirm_login&#x27;, methods=[&#x27;POST&#x27;])def confirm_login(): qr_id = request.json[&#x27;qr_id&#x27;] temp_token = request.json[&#x27;temp_token&#x27;] mobile_token = request.json[&#x27;mobile_token&#x27;] if temp_token in temporary_tokens and temporary_tokens[temp_token][&#x27;qr_id&#x27;] == qr_id: login_token = str(uuid.uuid4()) qr_code_store[qr_id][&#x27;status&#x27;] = &#x27;confirmed&#x27; return jsonify(&#123;&#x27;login_token&#x27;: login_token&#125;) return jsonify(&#123;&#x27;error&#x27;: &#x27;Invalid confirmation&#x27;&#125;), 400​if __name__ == &#x27;__main__&#x27;: app.run(debug=True)​ 之后来看PC端(这里应该用H5页面比较合适)： 12345678910111213import requestsimport json​# 1. 请求生成二维码IDresponse = requests.post(&#x27;http://localhost:5000/generate_qr&#x27;, json=&#123;&#x27;device_id&#x27;: &#x27;PC_device&#x27;&#125;)qr_id = response.json()[&#x27;qr_id&#x27;]​# 2. 根据二维码ID生成二维码图片 (此处省略，可以使用第三方库生成二维码图片)print(f&quot;QR Code ID: &#123;qr_id&#125;&quot;)​# 7. 显示二维码进入“待确认”状态print(&quot;QR Code Status: Waiting for confirmation&quot;)​ 之后再来看移动端的代码 (这里也用python模拟发起请求)： 12345678910111213141516171819import requests​# 4. 扫描二维码，解析出二维码IDqr_id = &#x27;解析出的二维码ID&#x27;token = &#x27;移动端token&#x27;​# 5. 请求服务端进行登录response = requests.post(&#x27;http://localhost:5000/scan_qr&#x27;, json=&#123;&#x27;qr_id&#x27;: qr_id, &#x27;token&#x27;: token&#125;)temp_token = response.json()[&#x27;temp_token&#x27;]​# 8. 使用二维码ID、临时token和移动端的token进行确认登录response = requests.post(&#x27;http://localhost:5000/confirm_login&#x27;, json=&#123;&#x27;qr_id&#x27;: qr_id, &#x27;temp_token&#x27;: temp_token, &#x27;mobile_token&#x27;: token&#125;)login_token = response.json().get(&#x27;login_token&#x27;)​if login_token: print(&quot;登录成功！&quot;)else: print(&quot;登录失败！&quot;)​ 这样一个简单的二维码登录的流程就出来了 案例解析了解了流程之后我们来看看其他大型网站是如何实施的 这里拿哔哩哔哩来举例。 我们可以看到它的那个json实例 123456789101112&#123; &quot;code&quot;: 0, &quot;message&quot;: &quot;0&quot;, &quot;ttl&quot;: 1, &quot;data&quot;: &#123; &quot;url&quot;: &quot;&quot;, &quot;refresh_token&quot;: &quot;&quot;, &quot;timestamp&quot;: 0, &quot;code&quot;: 86101, &quot;message&quot;: &quot;未扫码&quot; &#125;&#125; 我们可以发现b站是不断的去发送这个请求，去轮询得到最新的扫码状态，请求间隔大约1s 之后当我们扫描后发现已经变成等待确认 当我们确认后，会返回 和我们说的流程大概的相同。 PS: 移动端和服务端确认登录后，服务端怎么通知到PC端，并发送token过去，这个实现细节其实一直比较好奇，原来是由前端一直轮询实现的。 :)"},{"title":"一文吃透 React SSR 服务端渲染和同构原理","path":"/2024/07/31/一文吃透-React-SSR-服务端渲染和同构原理/","content":"原文地址javascript - 一文吃透 React SSR 服务端渲染和同构原理 - 前端张大胖-技术实践和探索 - SegmentFault 思否 全网最完整的 React SSR 同构技术原理解析与实践，从零开始手把手带你打造自己的同构应用开发骨架，帮助大家彻底深入理解服务端渲染及底层实现原理，学完本课程，你也可以打造自己的同构框架。 写在前面前段时间一直在研究react ssr技术，然后写了一个完整的ssr开发骨架。今天写文，主要是把我的研究成果的精华内容整理落地，另外通过再次梳理希望发现更多优化的地方，也希望可以让更多的人少踩一些坑，让跟多的人理解和掌握这个技术。 相信看过本文（前提是能对你的胃口，也能较好的消化吸收）你一定会对 react ssr 服务端渲染技术有一个深入的理解，可以打造自己的脚手架，更可以用来改造自己的实际项目，当然这不仅限于 react ，其他框架都一样，毕竟原理都是相似的。 为什么要服务端渲染(ssr)至于为什么要服务端渲染，我相信大家都有所闻，而且每个人都能说出几点来。 首屏等待在 SPA 模式下，所有的数据请求和 Dom 渲染都在浏览器端完成，所以当我们第一次访问页面的时候很可能会存在“白屏”等待，而服务端渲染所有数据请求和 html内容已在服务端处理完成，浏览器收到的是完整的 html 内容，可以更快的看到渲染内容，在服务端完成数据请求肯定是要比在浏览器端效率要高的多。 没考虑SEO的感受有些网站的流量来源主要还是靠搜索引擎，所以网站的 SEO 还是很重要的，而 SPA 模式对搜索引擎不够友好，要想彻底解决这个问题只能采用服务端直出。改变不了别人（搜索yinqing），只能改变自己。 SSR + SPA 体验升级只实现 SSR 其实没啥意义，技术上没有任何发展和进步，否则 SPA 技术就不会出现。 但是单纯的 SPA又不够完美，所以最好的方案就是这两种体验和技术的结合，第一次访问页面是服务端渲染，基于第一次访问后续的交互就是 SPA 的效果和体验，还不影响SEO 效果，这就有点完美了。 单纯实现 ssr 很简单，毕竟这是传统技术，也不分语言，随便用 php 、jsp、asp、node 等都可以实现。 但是要实现两种技术的结合，同时可以最大限度的重用代码（同构），减少开发维护成本，那就需要采用 react 或者 vue 等前端框架相结合 node (ssr) 来实现。 本文主要说 React SSR 技术 ,当然 vue 也一样，只是技术栈不同而已。 核心原理整体来说 react 服务端渲染原理不复杂，其中最核心的内容就是同构。 node server 接收客户端请求，得到当前的req url path,然后在已有的路由表内查找到对应的组件，拿到需要请求的数据，将数据作为 props、context或者store 形式传入组件，然后基于 react 内置的服务端渲染api renderToString() or renderToNodeStream() 把组件渲染为 html字符串或者 stream 流, 在把最终的 html 进行输出前需要将数据注入到浏览器端(注水)，server 输出(response)后浏览器端可以得到数据(脱水)，浏览器开始进行渲染和节点对比，然后执行组件的componentDidMount 完成组件内事件绑定和一些交互，浏览器重用了服务端输出的 html 节点，整个流程结束。 技术点确实不少，但更多的是架构和工程层面的，需要把各个知识点进行链接和整合。 这里放一个架构图 react ssr从 ejs 开始实现 ssr 很简单，先看一个 node ejs的栗子。 12345678910111213// index.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;react ssr &lt;%= title %&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;%= data %&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122 //node ssr const ejs = require(&#x27;ejs&#x27;); const http = require(&#x27;http&#x27;);http.createServer((req, res) =&gt; &#123; if (req.url === &#x27;/&#x27;) &#123; res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html&#x27; &#125;); // 渲染文件 index.ejs ejs.renderFile(&#x27;./views/index.ejs&#x27;, &#123; title: &#x27;react ssr&#x27;, data: &#x27;首页&#x27;&#125;, (err, data) =&gt; &#123; if (err ) &#123; console.log(err); &#125; else &#123; res.end(data); &#125; &#125;) &#125;&#125;).listen(8080); jsx 到字符串上面我们结合 ejs模板引擎 ，实现了一个服务端渲染的输出，html 和 数据直接输出到客户端。 参考以上，我们结合 react组件 来实现服务端渲染直出，使用 jsx 来代替 ejs，之前是在 html 里使用 ejs 来绑定数据，现在改写成使用jsx 来绑定数据,使用 react 内置 api 来把组件渲染为 html 字符串，其他没有差别。 为什么react 组件可以被转换为 html字符串呢？ 简单的说我们写的 jsx 看上去就像在写 html（其实写的是对象） 标签，其实经过编译后都会转换成React.createElement方法，最终会被转换成一个对象(虚拟DOM)，而且和平台无关，有了这个对象，想转换成什么那就看心情了。 1234567891011121314151617181920212223242526272829303132333435363738const React = require(&#x27;react&#x27;);const &#123; renderToString&#125; = require( &#x27;react-dom/server&#x27;);const http = require(&#x27;http&#x27;);//组件class Index extends React.Component&#123; constructor(props)&#123; super(props); &#125; render()&#123; return &lt;h1&gt;&#123;this.props.data.title&#125;&lt;/h1&gt; &#125;&#125; //模拟数据的获取const fetch = function () &#123; return &#123; title:&#x27;react ssr&#x27;, data:[] &#125;&#125;//服务http.createServer((req, res) =&gt; &#123; if (req.url === &#x27;/&#x27;) &#123; res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html&#x27; &#125;); const data = fetch(); const html = renderToString(&lt;Index data=&#123;data&#125;/&gt;); res.end(html); &#125;&#125;).listen(8080); ps:以上代码不能直接运行，需要结合babel 使用 @babel&#x2F;preset-react 进行转换 123npx babel script.js --out-file script-compiled.js --presets=@babel/preset-react 引出问题在上面非常简单的就是实现了 react ssr ,把jsx作为模板引擎，不要小看上面的一小段代码，他可以帮我们引出一系列的问题，这也是完整实现 react ssr 的基石。 双端路由如何维护？ 首先我们会发现我在 server 端定义了路由 ‘&#x2F;‘，但是在 react SPA 模式下我们需要使用react-router来定义路由。那是不是就需要维护两套路由呢？ 获取数据的方法和逻辑写在哪里？ 发现数据获取的fetch 写的独立的方法，和组件没有任何关联，我们更希望的是每个路由都有自己的 fetch 方法。 服务端 html 节点无法重用 虽然组件在服务端得到了数据，也能渲染到浏览器内，但是当浏览器端进行组件渲染的时候直出的内容会一闪而过消失。 好了，问题有了，接下来我们就一步一步的来解决这些问题。 同构才是核心react ssr 的核心就是同构，没有同构的 ssr 是没有意义的。 所谓同构就是采用一套代码，构建双端（server 和 client）逻辑，最大限度的重用代码，不用维护两套代码。而传统的服务端渲染是无法做到的，react 的出现打破了这个瓶颈，并且现在已经得到了比较广泛的应用。 路由同构双端使用同一套路由规则，node server 通过req url path 进行组件的查找，得到需要渲染的组件。 &#x2F;&#x2F;组件和路由配置 ，供双端使用 routes-config.js 12345678910111213141516171819202122232425262728293031323334353637class Detail extends React.Component&#123; render()&#123; return &lt;div&gt;detail&lt;/div&gt; &#125;&#125;class Index extends React.Component &#123; render() &#123; return &lt;div&gt;index&lt;/div&gt; &#125;&#125;const routes = [ &#123; path: &quot;/&quot;, exact: true, component: Home &#125;, &#123; path: &#x27;/detail&#x27;, exact: true, component:Detail, &#125;, &#123; path: &#x27;/detail/:a/:b&#x27;, exact: true, component: Detail &#125; ];//导出路由表export default routes; &#x2F;&#x2F;客户端 路由组件 123456789101112131415161718import routes from &#x27;./routes-config.js&#x27;;function App()&#123; return ( &lt;Layout&gt; &lt;Switch&gt; &#123; routes.map((item,index)=&gt;&#123; return &lt;Route path=&#123;item.path&#125; key=&#123;index&#125; exact=&#123;item.exact&#125; render=&#123;item.component&#125;&gt;&lt;/Route&gt; &#125;) &#125; &lt;/Switch&gt; &lt;/Layout&gt; );&#125;export default App; node server 进行组件查找 路由匹配其实就是对 组件path 规则的匹配，如果规则不复杂可以自己写，如果情况很多种还是使用官方提供的库来完成。 matchRoutes(routes, pathname) 123456789101112131415161718192021222324252627282930313233343536//引入官方库import &#123; matchRoutes &#125; from &quot;react-router-config&quot;;import routes from &#x27;./routes-config.js&#x27;;const path = req.path;const branch = matchRoutes(routes, path);//得到要渲染的组件const Component = branch[0].route.component; //node server http.createServer((req, res) =&gt; &#123; const url = req.url; //简单容错，排除图片等资源文件的请求 if(url.indexOf(&#x27;.&#x27;)&gt;-1) &#123; res.end(&#x27;&#x27;); return false;&#125; res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html&#x27; &#125;); const data = fetch(); //查找组件 const branch = matchRoutes(routes,url); //得到组件 const Component = branch[0].route.component; //将组件渲染为 html 字符串 const html = renderToString(&lt;Component data=&#123;data&#125;/&gt;); res.end(html); &#125;).listen(8080); 可以看下matchRoutes方法的返回值,其中route.component 就是 要渲染的组件 1234567891011[ &#123; route: &#123; path: &#x27;/detail&#x27;, exact: true, component: [Function: Detail] &#125;, match: &#123; path: &#x27;/detail&#x27;, url: &#x27;/detail&#x27;, isExact: true, params: &#123;&#125; &#125; &#125; ] react-router-config 这个库由react 官方维护，功能是实现嵌套路由的查找，代码没有多少，有兴趣可以看看。 文章走到这里，相信你已经知道了路由同构，所以上面的第一个问题 ： 【双端路由如何维护？】 解决了。 数据同构（预取同构）这里开始解决我们最开始发现的第二个问题 - 【获取数据的方法和逻辑写在哪里？】 数据预取同构，解决双端如何使用同一套数据请求方法来进行数据请求。 先说下流程，在查找到要渲染的组件后，需要预先得到此组件所需要的数据，然后将数据传递给组件后，再进行组件的渲染。 我们可以通过给组件定义静态方法来处理，组件内定义异步数据请求的方法也合情合理，同时声明为静态（static），在 server 端和组件内都也可以直接通过组件（function） 来进行访问。 比如 Index.getInitialProps 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//组件class Index extends React.Component&#123; constructor(props)&#123; super(props); &#125; //数据预取方法 静态 异步 方法 static async getInitialProps(opt) &#123; const fetch1 =await fetch(&#x27;/xxx.com/a&#x27;); const fetch2 = await fetch(&#x27;/xxx.com/b&#x27;); return &#123; res:[fetch1,fetch2] &#125; &#125; render()&#123; return &lt;h1&gt;&#123;this.props.data.title&#125;&lt;/h1&gt; &#125;&#125;//node server http.createServer((req, res) =&gt; &#123; const url = req.url; if(url.indexOf(&#x27;.&#x27;)&gt;-1) &#123; res.end(&#x27;&#x27;); return false;&#125; res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html&#x27; &#125;); //组件查找 const branch = matchRoutes(routes,url); //得到组件 const Component = branch[0].route.component; //数据预取 const data = Component.getInitialProps(branch[0].match.params); //传入数据，渲染组件为 html 字符串 const html = renderToString(&lt;Component data=&#123;data&#125;/&gt;); res.end(html); &#125;).listen(8080); 另外还有在声明路由的时候把数据请求方法关联到路由中，比如定一个 loadData 方法，然后在查找到路由后就可以判断是否存在loadData这个方法。 看下参考代码 123456789101112const loadBranchData = (location) =&gt; &#123; const branch = matchRoutes(routes, location.pathname) const promises = branch.map((&#123; route, match &#125;) =&gt; &#123; return route.loadData ? route.loadData(match) : Promise.resolve(null) &#125;) return Promise.all(promises)&#125; 上面这种方式实现上没什么问题，但从职责划分的角度来说有些不够清晰，我还是比较喜欢直接通过组件来得到异步方法。 好了，到这里我们的第二个问题 - 【获取数据的方法和逻辑写在哪里？】 解决了。 渲染同构假设我们现在基于上面已经实现的代码，同时我们也使用 webpack 进行了配置，对代码进行了转换和打包，整个服务可以跑起来。 路由能够正确匹配，数据预取正常，服务端可以直出组件的 html ，浏览器加载 js 代码正常，查看网页源代码能看到 html 内容，好像我们的整个流程已经走完。 但是当浏览器端的 js 执行完成后，发现数据重新请求了，组件的重新渲染导致页面看上去有些闪烁。 这是因为在浏览器端，双端节点对比失败，导致组件重新渲染，也就是只有当服务端和浏览器端渲染的组件具有相同的props 和 DOM 结构的时候，组件才能只渲染一次。 刚刚我们实现了双端的数据预取同构，但是数据也仅仅是服务端有，浏览器端是没有这个数据，当客户端进行首次组件渲染的时候没有初始化的数据，渲染出的节点肯定和服务端直出的节点不同，导致组件重新渲染。 数据注水在服务端将预取的数据注入到浏览器，使浏览器端可以访问到，客户端进行渲染前将数据传入对应的组件即可，这样就保证了props的一致。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 //node server 参考代码http.createServer((req, res) =&gt; &#123; const url = req.url; if(url.indexOf(&#x27;.&#x27;)&gt;-1) &#123; res.end(&#x27;&#x27;); return false;&#125; res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html&#x27; &#125;); console.log(url); //查找组件 const branch = matchRoutes(routes,url); //得到组件 const Component = branch[0].route.component; //数据预取 const data = Component.getInitialProps(branch[0].match.params); //组件渲染为 html const html = renderToString(&lt;Component data=&#123;data&#125;/&gt;); //数据注水 const propsData = `&lt;textarea style=&quot;display:none&quot; id=&quot;krs-server-render-data-BOX&quot;&gt;$&#123;JSON.stringify(data)&#125;&lt;/textarea&gt;`; // 通过 ejs 模板引擎将数据注入到页面 ejs.renderFile(&#x27;./index.html&#x27;, &#123; htmlContent: html, propsData &#125;, // 渲染的数据key: 对应到了ejs中的index (err, data) =&gt; &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log(data); res.end(data); &#125; &#125;) &#125;).listen(8080); //node ejs html &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;rootEle&quot;&gt; &lt;%- htmlContent %&gt; //组件 html内容 &lt;/div&gt; &lt;%- propsData %&gt; //组件 init state ，现在是个字符串&lt;/body&gt;&lt;/html&gt;&lt;/body&gt; 需要借助 ejs 模板，将数据绑定到页面上，为了防止 XSS攻击，这里我把数据写到了 textarea 标签里。 下图中，我看着明文数据难受，对数据做了base64编码 ，用之前需要转码，看个人需要。 数据脱水上一步数据已经注入到了浏览器端，这一步要在客户端组件渲染前先拿到数据，并且传入组件就可以了。 客户端可以直接使用id=krs-server-render-data-BOX 进行数据获取。 第一个方法简单粗暴，可直接在组件内的constructor 构造函数 内进行获取，如果怕代码重复，可以写一个高阶组件。 第二个方法可以通过 context 传递，只需要在入口处传入，在组件中声明 static contextType 即可。 我是采用context 传递，为了后面方便集成 redux 状态管理 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 定义 context 生产者 组件import React,&#123;createContext&#125; from &#x27;react&#x27;;import RootContext from &#x27;./route-context&#x27;;export default class Index extends React.Component &#123; constructor(props,context) &#123; super(props); &#125; render() &#123; return &lt;RootContext.Provider value=&#123;this.props.initialData||&#123;&#125;&#125;&gt; &#123;this.props.children&#125; &lt;/RootContext.Provider&gt; &#125;&#125;//入口 app.jsimport React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import &#123; BrowserRouter &#125; from &#x27;react-router-dom&#x27;;import Routes from &#x27;../&#x27;;import Provider from &#x27;./provider&#x27;;//渲染入口 接收脱水数据function renderUI(initialData) &#123; ReactDOM.hydrate(&lt;BrowserRouter&gt;&lt;Provider initialData=&#123;initialData&#125;&gt; &lt;Routes /&gt; &lt;/Provider&gt; &lt;/BrowserRouter&gt;, document.getElementById(&#x27;rootEle&#x27;), (e) =&gt; &#123; &#125;);&#125;//函数执行入口function entryIndex() &#123; let APP_INIT_DATA = &#123;&#125;; let state = true; //取得数据 let stateText = document.getElementById(&#x27;krs-server-render-data-BOX&#x27;); if (stateText) &#123; APP_INIT_DATA = JSON.parse(stateText.value || &#x27;&#123;&#125;&#x27;); &#125; if (APP_INIT_DATA) &#123;//客户端渲染 renderUI(APP_INIT_DATA); &#125;&#125;//入口执行entryIndex(); 行文至此，核心的内容已经基本说完，剩下的就是组件内如何使用脱水的数据。 下面通过 context 拿到数据 , 代码仅供参考，可根据自己的需求来进行封装和调整。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import React from &#x27;react&#x27;;import &#x27;./css/index.scss&#x27;;export default class Index extends React.Component &#123; constructor(props, context) &#123; super(props, context); //将context 存储到 state this.state = &#123; ... context &#125; &#125; //设置此参数 才能拿到 context 数据 static contextType = RootContext; //数据预取方法 static async getInitialProps(krsOpt) &#123; if (__SERVER__) &#123; //如果是服务端渲染的话 可以做的处理,node 端设置的全局变量 &#125; const fetch1 = fetch.postForm(&#x27;/fe_api/filed-manager/get-detail-of-type&#x27;, &#123; data: &#123; ofTypeId: 4000 &#125; &#125;); const fecth2 = fetch.postForm(&#x27;/fe_api/filed-manager/get-detail-of-type&#x27;, &#123; data: &#123; ofTypeId: 2000 &#125; &#125;); const resArr = await fetch.multipleFetch(fetch1, fecth2); //返回所有数据 return &#123; page: &#123;&#125;, fetchData: resArr &#125; &#125; componentDidMount() &#123; if (!this.isSSR) &#123; //非服务端渲染需要自身进行数据获取 Index.getInitialProps(this.props.krsOpt).then(data =&gt; &#123; this.setState(&#123; ...data &#125;, () =&gt; &#123; //可有的一些操作 &#125;); &#125;); &#125; &#125; render() &#123; //得到 state 内的数据，进行逻辑判断和容错，然后渲染 const &#123; page, fetchData &#125; = this.state; const [res] = fetchData || []; return &lt;div className=&quot;detailBox&quot;&gt; &#123; res &amp;&amp; res.data.map(item =&gt; &#123; return &lt;div key=&#123;item.id&#125;&gt;&#123;item.keyId&#125;:&#123;item.keyName&#125;---&#123;item.setContent&#125;&lt;/div&gt; &#125;) &#125; &lt;/div&gt; &#125;&#125; 到此我们的第三个问题：【服务端 html 节点无法重用 】已经解决,但人不够完美，请继续看。 css 过滤我们在写组件的时候大部分都会导入相关的 css 文件。 1234567891011121314151617181920212223import &#x27;./css/index.scss&#x27;;//导入css//组件class Index extends React.Component&#123; constructor(props)&#123; super(props); &#125; static async getInitialProps() &#123; const fetch1 =await fetch(&#x27;/xxx.com/a&#x27;); const fetch2 = await fetch(&#x27;/xxx.com/b&#x27;); return &#123; res:[fetch1,fetch2] &#125; &#125; render()&#123; return &lt;h1&gt;&#123;this.props.data.title&#125;&lt;/h1&gt; &#125;&#125; 但是这个 css 文件在服务端无法执行，其实想想在服务端本来就不需要渲染 css 。为什么不直接干掉？ 所以为了方便，我这里写了一个babel 插件，在编译的时候干掉 css 的导入代码。 12345678910111213141516171819202122232425/** * 删除 css 的引入 * 可能社区已经有现成的插件但是不想费劲儿找了，还是自己写一个吧。 */module.exports = function (&#123; types: babelTypes &#125;) &#123; return &#123; name: &quot;no-require-css&quot;, visitor: &#123; ImportDeclaration(path, state) &#123; let importFile = path.node.source.value; if(importFile.indexOf(&#x27;.scss&#x27;)&gt;-1)&#123; // 干掉css 导入 path.remove(); &#125; &#125; &#125; &#125;;&#125;;//.babelrc 中使用 &quot;plugins&quot;: [ &quot;./webpack/babel/plugin/no-require-css&quot; //引入 ] 动态路由的 SSR现在要说一个更加核心的内容，也是本文的一个压轴亮点，可以说是全网唯一,我之前也看过很多文章和资料都没有细说这一块儿的实现。 不知道你有没有发现，上面我们已经一步一步的实现了 React SSR 同构 的完整流程，但是总感觉少点什么东西。 SPA模式下大部分都会实现组件分包和按需加载，防止所有代码打包在一个文件过大影响页面的加载和渲染，影响用户体验。 那么基于 SSR 的组件按需加载如何实现呢？ 当然我们所限定按需的粒度是路由级别的，请求不同的路由动态加载对应的组件。 如何实现组件的按需加载？在 webpack2 时期主要使用require.ensure方法来实现按需加载，他会单独打包指定的文件，在当下 webpack4，有了更加规范的的方式实现按需加载，那就是动态导入 import(&#39;./xx.js&#39;),当然实现的效果和 require.ensure是相同的。 咱们这里只说如何借助这个规范实现按需加载的路由，关于动态导入的实现原理先按下不表。 我们都知道 import 方法传入一个js文件地址，返回值是一个 promise 对象，然后在 then 方法内回调得到按需的组件。他的原理其实就是通过 jsonp 的方式，动态请求脚本，然后在回调内得到组件。 123import(&#x27;../index&#x27;).then(res=&gt;&#123; //xxxx&#125;); 那现在我们已经得到了几个比较有用的信息。 如何加载脚本 - import 结合 webpack 自动完成 脚本是否加载完成 - 通过在 then 方法回调进行处理 获取异步按组件 - 通过在 then 方法回调内获取 我们可以试着把上面的逻辑抽象成为一个组件，然后在路由配置的地方进行导入后，那么是不是就完成了组件的按需加载呢？ 先看下按需加载组件, 目的是在 import 完成的时候得到按需的组件，然后更改容器组件的 state，将这个异步组件进行渲染。 1234567891011121314151617181920212223242526272829303132333435363738/** * 按需加载的容器组件 * @class Bundle * @extends &#123;Component&#125; */export default class Async extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; COMPT: null &#125;; &#125; UNSAFE_componentWillMount() &#123; //执行组件加载 if (!this.state.COMPT) &#123; this.load(this.props); &#125; &#125; load(props) &#123; this.setState(&#123; COMPT: null &#125;); //注意这里，返回Promise对象; C.default 指向按需组件 props.load().then((C) =&gt; &#123; this.setState(&#123; COMPT: C.default ? C.default : COMPT &#125;); &#125;); &#125; render() &#123; return this.state.COMPT ? this.props.children(this.state.COMPT) : &lt;span&gt;正在加载......&lt;/span&gt;; &#125;&#125; Async 容器组件接收一个 props 传过来的 load 方法，返回值是 Promise类型，用来动态导入组件。 在生命周期 UNSAFE_componentWillMount 得到按需的组件，并将组件存储到 state.COMPT内,同时在 render 方法中判断这个状态的可用性，然后调用this.props.children 方法进行渲染。 123456//调用const LazyPageCom = (props) =&gt; ( &lt;Async load=&#123;() =&gt; import(&#x27;../index&#x27;)&#125;&gt; &#123;(C) =&gt; &lt;C &#123;...props&#125; /&gt;&#125;//返回函数组件 &lt;/Async&gt;); 当然这只是其中一种方法，也有很多是通过 react-loadable 库来进行实现，但是实现思路基本相同,有兴趣的可以看下源码。 12345678910111213141516//参考代码import React from &#x27;react&#x27;;import Loadable from &#x27;react-loadable&#x27;;//loading 组件const Loading =()=&gt;&#123; return ( &lt;div&gt;loading&lt;/div&gt; ) &#125;//导出组件export default Loadable(&#123; loader:import(&#x27;../index&#x27;), loading:Loading&#125;); 到这里我们已经实现了组件的按需加载，剩下就是配置到路由。 看下伪代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//index.jsclass Index extends React.Component &#123; render() &#123; return &lt;div&gt;detail&lt;/div&gt; &#125;&#125;//detail.jsclass Detail extends React.Component &#123; render() &#123; return &lt;div&gt;detail&lt;/div&gt; &#125;&#125;//routes.js//按需加载 index 组件const AyncIndex = (props) =&gt; ( &lt;Async load=&#123;() =&gt; import(&#x27;../index&#x27;)&#125;&gt; &#123;(C) =&gt; &lt;C &#123;...props&#125; /&gt;&#125; &lt;/Async&gt;);//按需加载 detai 组件const AyncDetail = (props) =&gt; ( &lt;Async load=&#123;() =&gt; import(&#x27;../index&#x27;)&#125;&gt; &#123;(C) =&gt; &lt;C &#123;...props&#125; /&gt;&#125; &lt;/Async&gt;);const routes = [ &#123; path: &quot;/&quot;, exact: true, component: AyncIndex &#125;, &#123; path: &#x27;/detail&#x27;, exact: true, component: AyncDetail, &#125;]; 结合路由的按需加载已经配置完成，先不管 server端 是否需要进行调整，此时的代码是可以运行的，按需也是 ok 的。 但是ssr无效了，查看网页源代码无内容。 动态路由 SSR 双端配置ssr无效了,这是什么原因呢？ 上面我们在做路由同构的时候，双端使用的是同一个 route配置文件routes-config.js,现在组件改成了按需加载，所以在路由查找后得到的组件发生改变了 - AyncDetail,AyncIndex，根本无法转换出组件内容。 ssr 模式下 server 端如何处理路由按需加载其实很简单，也是参考客户端的处理方式，对路由配置进行二次处理。server 端在进行组件查找前，强制执行 import 方法，得到一个全新的静态路由表，再去进行组件的查找。 1234567891011121314151617181920212223//获得静态路由import routes from &#x27;routes-config.js&#x27;;//得到动态路由的配置export async function getStaticRoutes() &#123; const staticRoutes = [];//存放新路由 for (; i &lt; len; i++) &#123; let item = routes[i]; //存放静态路由 staticRoutes.push(&#123; ...item, ...&#123; component: (await item.component().props.load()).default &#125; &#125;); &#125; return staticRoutes; //返回静态路由&#125; 如今我们离目标更近了一步，server端已兼容了按需路由的查找。但是还没完！ 我们这个时候访问页面的话，ssr 生效了，查看网页源代码可以看到对应的 html 内容。 但是页面上会显示直出的内容，然后显示&lt;span&gt;正在加载......&lt;/span&gt; ,瞬间又变成直出的内容。 ### ssr 模式下 client 端如何处理路由按需加载 这个是为什么呢？ 是不是看的有点累了，再坚持一下就成功了。 其实有问题才是最好的学习方式，问题解决了，路就通了。 首先我们知道浏览器端会对已有的节点进行双端对比，如果对比失败就会重新渲染，这很明显就是个问题。 咱分析一下，首先服务端直出了 html 内容，而此时浏览器端js执行完后需要做按需加载，在按需加载前的组件默认的内容就是&lt;span&gt;正在加载......&lt;/span&gt; 这个缺省内容和服务端直出的 html 内容完全不同，所以对比失败，页面会渲染成 &lt;span&gt;正在加载......&lt;/span&gt;,然后按需加载完成后组件再次渲染，此时渲染的就是真正的组件了。 如何解决呢？ 其实也并不复杂，只是不确定是否可行，试过就知道。 既然客户端需要处理按需，那么我们等这个按需组件加载完后再进行渲染是不是就可以了呢？ 答案是：可以的！ 如何按需呢？ 向“服务端同学”学习，找到对应的组件并强制 执行import按需，只是这里不是转换为静态路由，只找到按需的组件完成动态加载即可。 既然有了思路，那就撸起代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import React,&#123;createContext&#125; from &#x27;react&#x27;;import RootContext from &#x27;./route-context&#x27;;export default class Index extends React.Component &#123; constructor(props,context) &#123; super(props); &#125; render() &#123; return &lt;RootContext.Provider value=&#123;this.props.initialData||&#123;&#125;&#125;&gt; &#123;this.props.children&#125; &lt;/RootContext.Provider&gt; &#125;&#125;//入口 app.jsimport React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import &#123; BrowserRouter &#125; from &#x27;react-router-dom&#x27;;import Routes from &#x27;../&#x27;;import Provider from &#x27;./provider&#x27;;//渲染入口function renderUI(initialData) &#123; ReactDOM.hydrate(&lt;BrowserRouter&gt;&lt;Provider initialData=&#123;initialData&#125;&gt; &lt;Routes /&gt; &lt;/Provider&gt; &lt;/BrowserRouter&gt;, document.getElementById(&#x27;rootEle&#x27;), (e) =&gt; &#123; &#125;);&#125;function entryIndex() &#123; let APP_INIT_DATA = &#123;&#125;; let state = true; //取得数据 let stateText = document.getElementById(&#x27;krs-server-render-data-BOX&#x27;); //数据脱水 if (stateText) &#123; APP_INIT_DATA = JSON.parse(stateText.value || &#x27;&#123;&#125;&#x27;); &#125; if (APP_INIT_DATA) &#123;//客户端渲染 - renderUI(true, APP_INIT_DATA); //查找组件 + matchComponent(document.location.pathname, routesConfig()).then(res =&gt; &#123; renderUI(true, APP_INIT_DATA); &#125;); &#125;&#125;//执行入口entryIndex(); matchComponent 是我封装的一个组件查找的方法，在文章开始已经介绍过类似的实现，代码就不贴了。 核心亮点说完，整个流程基本结束，剩下的都是些有的没的了，我打算要收工了。 其他SEO 支持页面的 SEO 效果取决于页面的主体内容和页面的 TDK（标题 title,描述 description,关键词 keyword）以及关键词的分布和密度，现在我们实现了 ssr所以页面的主体内容有了，那如何设置页面的标题并且让每个页面（路由）的标题都不同呢？ 只要我们每请求一个路由的时候返回不同的 tdk 就可以了。 这里我在所对应组件数据预取的方法内加了约定，返回的数据为固定格式，必须包含 page 对象，page 对象内包含 tdk 的信息。 看代码瞬间就明白。 1234567891011121314151617181920212223242526272829import &#x27;./css/index.scss&#x27;;//组件class Index extends React.Component&#123; constructor(props)&#123; super(props); &#125; static async getInitialProps() &#123; const fetch1 =await fetch(&#x27;/xxx.com/a&#x27;); const fetch2 = await fetch(&#x27;/xxx.com/b&#x27;); return &#123; page:&#123; tdk:&#123; title:&#x27;标题&#x27;, keyword:&#x27;关键词&#x27;, description:&#x27;描述&#x27; &#125; &#125; res:[fetch1,fetch2] &#125; &#125; render()&#123; return &lt;h1&gt;&#123;this.props.data.title&#125;&lt;/h1&gt; &#125;&#125; 这样你的 tdk 可以根据你的需要设置成静态还是从接口拿到的。然后可以在 esj 模板里进行绑定，也可以在 componentDidMount通过 jsdocument.title=this.state.page.tdk.title设置页面的标题。 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;meta name=&quot;keywords&quot; content=&quot;&lt;%=page.tdk.keyword%&gt;&quot; /&gt; &lt;meta name=&quot;description&quot; content=&quot;content=&quot;&lt;%=page.tdk.description%&gt;&quot; /&gt; &lt;title&gt;&lt;%=page.tdk.title%&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;rootEle&quot;&gt; &lt;%- htmlContent %&gt; &lt;/div&gt; &lt;%- propsData %&gt;&lt;/body&gt;&lt;/html&gt;&lt;/body&gt;&lt;%page.staticSource.js.forEach(function(item)&#123;%&gt; fetch 同构可以使用isomorphic-fetch、axios或者whatwg-fetch + node-fetch 等库来实现支持双端的 fetch 数据请求，这里推荐使用axios 主要是比较方便。 TODO 和 思考没有介绍结合 redux 状态管理的 ssr 实现，其实也不复杂，关键还是看业务中是否需要使用redux，因为文中已经实现了使用 context 传递数据，直接改成按store 传递也很容易,但是更多的还是对 react-redux 的应用。 123456789//渲染入口 代码仅供参考 function renderUI(initialData) &#123; ReactDOM.hydrate(&lt;BrowserRouter&gt;&lt;Provider store=&#123;initialData&#125;&gt; &lt;Routes /&gt; &lt;/Provider&gt; &lt;/BrowserRouter&gt;, document.getElementById(&#x27;rootEle&#x27;), (e) =&gt; &#123; &#125;);&#125; 服务端同构渲染虽然可以提升首屏的出现时间，利于 SEO，对低端用户友好，但是开发复杂度有所提高，代码需要兼容双端运行（runtime）,还有一些库只能在浏览器端运行，在服务端加载会直接报错，这种情况就需要进行做一些特殊处理。 同时也会大大的增加服务端负载，当然这都容易解决，可以改用renderToNodeStream() 方法通过流式输出来提升服务端渲染性能，可以进行监控和扩容，所以是否需要 ssr 模式，还要看具体的产品线和用户定位。 最后本文最初从 react ssr 的整体实现原理上进行说明，然后逐步的抛出问题，循序渐进的逐步解决，最终完成了整个React SSR 所需要处理的技术点，同时对每个技术点和问题做了详细的说明。 但实现方式并不唯一，还有很多其他的方式， 比如 next.js, umi.js,但是原理相似，具体差异我会接下来进行对比后输出。 源码参考由于上面文中的代码较为零散，恐怕不能直接运行。为了方便大家的参考和学习，我把涉及到代码进行整理、完善和修改，增加了一些基础配置和工程化处理，目前已形成一个完整的开发骨架，可以直接运行看效果，所有的代码都在这个骨架里，欢迎star 欢迎 下载，交流学习。 项目代码地址: https://github.com/Bigerfe/koa-react-ssr 说点感想很多东西都可以基于你现有的知识创造出来。 只要明白了其中的原理，然后梳理出实现的思路，剩下的就是撸代码了，期间会大量的自动或被动的从你现有的知识库里进行调取，一步一步的，只要不怕麻烦，都能搞得定。 这也是我为什么上来先要说下reac ssr 原理 的原因，因为它指导了我的实践。 全文都是自己亲手一个一个码出，也全部都是出自本人的理解，但个人文采有限，所以导致很多表达说的都是大白话，表达不够清楚的地方还请指出和斧正，但是真正的核心已全部涵盖。 希望本文的内容对你有所帮助，也可以对得住我这个自信的标题。 参考资料https://github.com/ReactTrain…https://reacttraining.com/rea…https://blog.seosiwei.com/det…https://www.jianshu.com/p/47c… 更多精彩好玩有用的前端内容，请关注公众号《前端张大胖》","tags":["React","SSR"]},{"title":"Canvas入门知识图解","path":"/2024/04/12/Canvas入门知识图解/","content":"原文地址Canvas 从入门到劝朋友放弃（图解版） - 掘金 本文就用光的速度将 canvas 给入门了。 要入门一个技术，前期最重要是快！所以本文只讲入门内容，能应付简单项目。深入的知识点会在其他文章讲解。 Canvas 是什么？ Canvas 中文名叫 “画布”，是 HTML5 新增的一个标签。 Canvas 允许开发者通过 JS在这个标签上绘制各种图案。 Canvas 拥有多种绘制路径、矩形、圆形、字符以及图片的方法。 Canvas 在某些情况下可以 “代替” 图片。 Canvas 可用于动画、游戏、数据可视化、图片编辑器、实时视频处理等领域。 Canvas 和 SVG 的区别 Canvas SVG 用JS动态生成元素（一个HTML元素） 用XML描述元素（类似HTML元素那样，可用多个元素来描述一个图形） 位图（受屏幕分辨率影响） 矢量图（不受屏幕分辨率影响） 不支持事件 支持事件 数据发生变化需要重绘 不需要重绘 就上面的描述而言可能有点难懂，你可以打开 AntV 旗下的图形编辑引擎做对比。G6 是使用 canvas 开发的，X6 是使用 svg 开发的。 我的建议是：如果要展示的数据量比较大，比如一条数据就是一个元素节点，那使用 canvas 会比较合适；如果用户操作的交互比较多，而且对清晰度有要求（矢量图），那么使用 svg 会比较合适。 起步学习前端一定要动手敲代码，然后看效果展示。 起步阶段会用几句代码说明 canvas 如何使用，本例会画一条直线。 画条直线 在 HTML 中创建 canvas 元素 通过 js 获取 canvas 标签 从 canvas 标签中获取到绘图工具 通过绘图工具，在 canvas 标签上绘制图形 1234567891011121314151617181920&lt;!-- 1、创建 canvas 元素 --&gt;&lt;canvas id=&quot;c&quot; width=&quot;300&quot; height=&quot;200&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; // 2、获取 canvas 对象 const cnv = document.getElementById(&#x27;c&#x27;) // 3、获取 canvas 上下文环境对象 const cxt = cnv.getContext(&#x27;2d&#x27;) // 4、绘制图形 cxt.moveTo(100, 100) // 起点坐标 (x, y) cxt.lineTo(200, 100) // 终点坐标 (x, y) cxt.stroke() // 将起点和终点连接起来&lt;/script&gt; moveTo 、 lineTo 和 stroke 方法暂时可以不用管，它们的作用是绘制图形，这些方法在后面会讲到~ 注意点1、默认宽高canvas 有 默认的 宽度(300px) 和 高度(150px) 如果不在 canvas 上设置宽高，那 canvas 元素的默认宽度是300px，默认高度是150px。 2、设置 canvas 宽高canvas 元素提供了 width 和 height 两个属性，可设置它的宽高。 需要注意的是，这两个属性只需传入数值，不需要传入单位（比如 px 等）。 1&lt;canvas width=&quot;600&quot; height=&quot;400&quot;&gt;&lt;/canvas&gt; 3、不能通过 CSS 设置画布的宽高使用 css 设置 canvas 的宽高，会出现 内容被拉伸 的后果！！！ 12345678910111213141516171819202122232425&lt;style&gt; #c &#123; width: 400px; height: 400px; border: 1px solid #ccc; &#125;&lt;/style&gt;&lt;canvas id=&quot;c&quot;&gt;&lt;/canvas&gt;&lt;script&gt; // 1、获取canvas对象 const cnv = document.getElementById(&#x27;c&#x27;) // 2、获取canvas上下文环境对象 const cxt = cnv.getContext(&#x27;2d&#x27;) // 3、绘制图形 cxt.moveTo(100, 100) // 起点 cxt.lineTo(200, 100) // 终点 cxt.stroke() // 将起点和终点连接起来 console.log(cnv.width) // 获取 canvas 的宽度，输出：300 console.log(cnv.height) // 获取 canvas 的高度，输出：150&lt;/script&gt; canvas 的默认宽度是300px，默认高度是150px。 如果使用 css 修改 canvas 的宽高（比如本例变成 400px * 400px），那宽度就由 300px 拉伸到 400px，高度由 150px 拉伸到 400px。 使用 js 获取 canvas 的宽高，此时返回的是 canvas 的默认值。 最后出现的效果如上图所示。 4、线条默认宽度和颜色线条的默认宽度是 1px ，默认颜色是黑色。 但由于默认情况下 canvas 会将线条的中心点和像素的底部对齐，所以会导致显示效果是 2px 和非纯黑色问题。 5、IE兼容性高暂时只有 IE 9 以上才支持 canvas 。但好消息是 IE 已经有自己的墓碑了。 如需兼容 IE 7 和 8 ，可以使用 ExplorerCanvas 。但即使是使用了 ExplorerCanvas 仍然会有所限制，比如无法使用 fillText() 方法等。 基础图形坐标系在绘制基础图形之前，需要先搞清除 Canvas 使用的坐标系。 Canvas 使用的是 W3C 坐标系 ，也就是遵循我们屏幕、报纸的阅读习惯，从上往下，从左往右。 W3C 坐标系 和 数学直角坐标系 的 X轴 是一样的，只是 Y轴 的反向相反。 W3C 坐标系 的 Y轴 正方向向下。 直线一条直线最简单的起步方式是画一条直线。这里所说的 “直线” 是几何学里的 “线段” 的意思。 需要用到这3个方法： moveTo(x1, y1)：起点坐标 (x, y) lineTo(x2, y2)：下一个点的坐标 (x, y) stroke()：将所有坐标用一条线连起来 起步阶段可以先这样理解。 1234567891011&lt;canvas id=&quot;c&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const cnv = document.getElementById(&#x27;c&#x27;) const cxt = cnv.getContext(&#x27;2d&#x27;) // 绘制直线 cxt.moveTo(50, 100) // 起点坐标 cxt.lineTo(200, 50) // 下一个点的坐标 cxt.stroke() // 将上面的坐标用一条线连接起来&lt;/script&gt; 上面的代码所呈现的效果，可以看下图解释（手不太聪明，画得不是很标准，希望能看懂） 多条直线如需画多条直线，可以用会上面那几个方法。 1234567891011121314&lt;canvas id=&quot;c&quot; width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const cnv = document.getElementById(&#x27;c&#x27;) const cxt = cnv.getContext(&#x27;2d&#x27;) cxt.moveTo(20, 100) cxt.lineTo(200, 100) cxt.stroke() cxt.moveTo(20, 120.5) cxt.lineTo(200, 120.5) cxt.stroke()&lt;/script&gt; 仔细观察一下，为什么两条线的粗细不一样的？ 明明使用的方法都是一样的，只是第二条直线的 Y轴 的值是有小数点。 答：默认情况下 canvas 会将线条的中心点和像素的底部对齐，所以会导致显示效果是 2px 和非纯黑色问题。 上图每个格子代表 1px。 线的中心点会和画布像素点的底部对齐，所以会线中间是黑色的，但由于一个像素就不能再切割了，所以会有半个像素被染色，就变成了浅灰色。 所以如果你设置的 Y轴 值是一个整数，就会出现上面那种情况。 设置样式 lineWidth：线的粗细 strokeStyle：线的颜色 lineCap：线帽：默认: butt; 圆形: round; 方形: square 123456789101112131415161718192021&lt;canvas id=&quot;c&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const cnv = document.getElementById(&#x27;c&#x27;) const cxt = cnv.getContext(&#x27;2d&#x27;) // 绘制直线 cxt.moveTo(50, 50) cxt.lineTo(200, 50) // 修改直线的宽度 cxt.lineWidth = 20 // 修改直线的颜色 cxt.strokeStyle = &#x27;pink&#x27; // 修改直线两端样式 cxt.lineCap = &#x27;round&#x27; // 默认: butt; 圆形: round; 方形: square cxt.stroke()&lt;/script&gt; 新开路径开辟新路径的方法： beginPath() 在绘制多条线段的同时，还要设置线段样式，通常需要开辟新路径。 要不然样式之间会相互污染。 比如这样 123456789101112131415161718&lt;canvas id=&quot;c&quot; width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const cnv = document.getElementById(&#x27;c&#x27;) const cxt = cnv.getContext(&#x27;2d&#x27;) // 第一条线 cxt.moveTo(20, 100) cxt.lineTo(200, 100) cxt.lineWidth = 10 cxt.strokeStyle = &#x27;pink&#x27; cxt.stroke() // 第二条线 cxt.moveTo(20, 120.5) cxt.lineTo(200, 120.5) cxt.stroke()&lt;/script&gt; 如果不想相互污染，需要做2件事： 使用 beginPath() 方法，重新开一个路径 设置新线段的样式（必须项） 如果上面2步却了其中1步都会有影响。 只使用 beginPath() 12345678910111213141516171819&lt;canvas id=&quot;c&quot; width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const cnv = document.getElementById(&#x27;c&#x27;) const cxt = cnv.getContext(&#x27;2d&#x27;) // 第一条线 cxt.moveTo(20, 100) cxt.lineTo(200, 100) cxt.lineWidth = 10 cxt.strokeStyle = &#x27;pink&#x27; cxt.stroke() // 第二条线 cxt.beginPath() // 重新开启一个路径 cxt.moveTo(20, 120.5) cxt.lineTo(200, 120.5) cxt.stroke()&lt;/script&gt; 第一条线的样式会影响之后的线。 但如果使用了 beginPath() ，后面的线段不会影响前面的线段。 12345678910111213141516171819&lt;canvas id=&quot;c&quot; width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const cnv = document.getElementById(&#x27;c&#x27;) const cxt = cnv.getContext(&#x27;2d&#x27;) // 第一条线 cxt.moveTo(20, 100) cxt.lineTo(200, 100) cxt.stroke() // 第二条线 cxt.beginPath() // 重新开启一个路径 cxt.moveTo(20, 120.5) cxt.lineTo(200, 120.5) cxt.lineWidth = 4 cxt.strokeStyle = &#x27;red&#x27; cxt.stroke()&lt;/script&gt; 设置新线段的样式，没使用 beginPath() 的情况这个情况会反过来，后面的线能影响前面的线。 1234567891011121314151617181920&lt;canvas id=&quot;c&quot; width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const cnv = document.getElementById(&#x27;c&#x27;) const cxt = cnv.getContext(&#x27;2d&#x27;) // 第一条线 cxt.moveTo(20, 100) cxt.lineTo(200, 100) cxt.lineWidth = 10 cxt.strokeStyle = &#x27;pink&#x27; cxt.stroke() // 第二条线 cxt.moveTo(20, 120.5) cxt.lineTo(200, 120.5) cxt.lineWidth = 4 cxt.strokeStyle = &#x27;red&#x27; cxt.stroke()&lt;/script&gt; 正确的做法在设置 beginPath() 的同时，也各自设置样式。这样就能做到相互不影响了。 12345678910111213141516171819&lt;canvas id=&quot;c&quot; width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const cnv = document.getElementById(&#x27;c&#x27;) const cxt = cnv.getContext(&#x27;2d&#x27;) cxt.moveTo(20, 100) cxt.lineTo(200, 100) cxt.lineWidth = 10 cxt.strokeStyle = &#x27;pink&#x27; cxt.stroke() cxt.beginPath() // 重新开启一个路径 cxt.moveTo(20, 120.5) cxt.lineTo(200, 120.5) cxt.lineWidth = 4 cxt.strokeStyle = &#x27;red&#x27; cxt.stroke()&lt;/script&gt; 折线和 直线 差不多，都是使用 moveTo() 、lineTo() 和 stroke() 方法可以绘制折线。 12345678910111213&lt;canvas id=&quot;c&quot; width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const cnv = document.getElementById(&#x27;c&#x27;) const cxt = cnv.getContext(&#x27;2d&#x27;) cxt.moveTo(50, 200) cxt.lineTo(100, 50) cxt.lineTo(200, 200) cxt.lineTo(250, 50) cxt.stroke()&lt;/script&gt; 画这种折线，最好在草稿纸上画一个坐标系，自己计算并描绘一下每个点大概在什么什么位置，最后在 canvas 中看看效果。 矩形根据前面的基础，我们可以 使用线段来描绘矩形，但 canvas 也提供了 rect() 等方法可以直接生成矩形。 使用线段描绘矩形可以使用前面画线段的方法来绘制矩形 123456789101112131415canvas id=&quot;c&quot; width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const cnv = document.getElementById(&#x27;c&#x27;) const cxt = cnv.getContext(&#x27;2d&#x27;) // 绘制矩形 cxt.moveTo(50, 50) cxt.lineTo(200, 50) cxt.lineTo(200, 120) cxt.lineTo(50, 120) cxt.lineTo(50, 50) // 需要闭合，又或者使用 closePath() 方法进行闭合，推荐使用 closePath() cxt.stroke()&lt;/script&gt; 上面的代码几个点分别对应下图。 使用 strokeRect() 描边矩形 strokeStyle：设置描边的属性（颜色、渐变、图案） strokeRect(x, y, width, height)：描边矩形（x和y是矩形左上角起点；width 和 height 是矩形的宽高） strokeStyle 必须写在 strokeRect() 前面，不然样式不生效。 1234567891011&lt;canvas id=&quot;c&quot; width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const cnv = document.getElementById(&#x27;c&#x27;) const cxt = cnv.getContext(&#x27;2d&#x27;) // strokeStyle 属性 // strokeRect(x, y, width, height) 方法 cxt.strokeStyle = &#x27;pink&#x27; cxt.strokeRect(50, 50, 200, 100)&lt;/script&gt; 上面的代码可以这样理解 使用 fillRect() 填充矩形fillRect() 和 strokeRect() 方法差不多，但 fillRect() 的作用是填充。 需要注意的是，fillStyle 必须写在 fillRect() 之前，不然样式不生效。 1234567891011&lt;canvas id=&quot;c&quot; width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const cnv = document.getElementById(&#x27;c&#x27;) const cxt = cnv.getContext(&#x27;2d&#x27;) // fillStyle 属性 // fillRect(x, y, width, height) 方法 cxt.fillStyle = &#x27;pink&#x27; cxt.fillRect(50, 50, 200, 100) // fillRect(x, y, width, height)&lt;/script&gt; 同时使用 strokeRect() 和 fillRect()同时使用 strokeRect() 和 fillRect() 会产生描边和填充的效果 1234567891011&lt;canvas id=&quot;c&quot; width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const cnv = document.getElementById(&#x27;c&#x27;) const cxt = cnv.getContext(&#x27;2d&#x27;) cxt.strokeStyle = &#x27;red&#x27; cxt.strokeRect(50, 50, 200, 100) // strokeRect(x, y, width, height) cxt.fillStyle = &#x27;yellow&#x27; cxt.fillRect(50, 50, 200, 100) // fillRect(x, y, width, height)&lt;/script&gt; 使用 rect() 生成矩形rect() 和 fillRect() 、strokeRect() 的用法差不多，唯一的区别是： strokeRect() 和 fillRect() 这两个方法调用后会立即绘制；rect() 方法被调用后，不会立刻绘制矩形，而是需要调用 stroke() 或 fill() 辅助渲染。 1234567891011121314&lt;canvas id=&quot;c&quot; width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const cnv = document.getElementById(&#x27;c&#x27;) const cxt = cnv.getContext(&#x27;2d&#x27;) cxt.strokeStyle = &#x27;red&#x27; cxt.fillStyle = &#x27;pink&#x27; cxt.rect(50, 50, 200, 100) // rect(x, y, width, height) cxt.stroke() cxt.fill()&lt;/script&gt; 等价公式： 12345678910111213141516171819cxt.strokeStyle = &#x27;red&#x27;,cxt.rect(50, 50, 200, 100)cxt.stroke()// 等价于cxt.strokeStyle = &#x27;red&#x27;cxt.strokerect(50, 50, 200, 100)// -----------------------------cxt.fillStyle = &#x27;hotpink&#x27;cxt.rect(50, 50, 200, 100)cxt.fill()// 等价于cxt.fillStyle = &#x27;yellowgreen&#x27;cxt.fillRect(50, 50, 200, 100) 使用 clearRect() 清空矩形使用 clearRect() 方法可以清空指定区域。 1clearRect(x, y, width, height) 其语法和创建 cxt.rect() 差不多。 1234567891011&lt;canvas id=&quot;c&quot; width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const cnv = document.getElementById(&#x27;c&#x27;) const cxt = cnv.getContext(&#x27;2d&#x27;) cxt.fillStyle = &#x27;pink&#x27; // 设置填充颜色 cxt.fillRect(50, 50, 200, 200) // 填充矩形 cxt.clearRect(60, 60, 180, 90) // 清空矩形&lt;/script&gt; 清空画布canvas 画布元素是矩形，所以可以通过下面的代码把整个画布清空掉。 123// 省略部分代码cxt.clearRect(0, 0, cnv.width, cnv.height) 要清空的区域：从画布左上角开始，直到画布的宽和画布的高为止。 多边形Canvas 要画多边形，需要使用 moveTo() 、 lineTo() 和 closePath() 。 三角形虽然三角形是常见图形，但 canvas 并没有提供类似 rect() 的方法来绘制三角形。 需要确定三角形3个点的坐标位置，然后使用 stroke() 或者 fill() 方法生成三角形。 1234567891011121314151617&lt;canvas id=&quot;c&quot; width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const cnv = document.getElementById(&#x27;c&#x27;) const cxt = cnv.getContext(&#x27;2d&#x27;) cxt.moveTo(50, 50) cxt.lineTo(200, 50) cxt.lineTo(200, 200) // 注意点：如果使用 lineTo 闭合图形，是不能很好闭合拐角位的。 cxt.lineTo(50, 50) // 闭合 cxt.stroke()&lt;/script&gt; 注意，默认情况下不会自动从最后一个点连接到起点。最后一步需要设置一下 cxt.lineTo(50, 50) ，让它与 cxt.moveTo(50, 50) 一样。这样可以让路径回到起点，形成一个闭合效果。 但这样做其实是有点问题的，而且也比较麻烦，要记住起始点坐标。 上面的闭合操作，如果遇到设置了 lineWidth 或者 lineJoin 就会有问题，比如： 12// 省略部分代码cxt.lineWidth = 20 当线段变粗后，起始点和结束点的链接处，拐角就出现“不正常”现象。 如果需要真正闭合，可以使用 closePath() 方法。 12345678910111213141516&lt;canvas id=&quot;c&quot; width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const cnv = document.getElementById(&#x27;c&#x27;) const cxt = cnv.getContext(&#x27;2d&#x27;) cxt.moveTo(50, 50) cxt.lineTo(200, 50) cxt.lineTo(200, 200) // 手动闭合 cxt.closePath() cxt.lineJoin = &#x27;miter&#x27; // 线条连接的样式。miter: 默认; bevel: 斜面; round: 圆角 cxt.lineWidth = 20 cxt.stroke()&lt;/script&gt; 使用 cxt.closePath() 可以自动将终点和起始点连接起来，此时看上去就正常多了。 菱形有一组邻边相等的平行四边形是菱形 12345678910111213&lt;canvas id=&quot;c&quot; width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const cnv = document.getElementById(&#x27;c&#x27;) const cxt = cnv.getContext(&#x27;2d&#x27;) cxt.moveTo(150, 50) cxt.lineTo(250, 100) cxt.lineTo(150, 150) cxt.lineTo(50, 100) cxt.closePath() cxt.stroke()&lt;/script&gt; 要绘制直线类型的图形，在草稿纸上标记出起始点和每个拐角的点，然后再连线即可。相对曲线图形来说，直线图形是比较容易的。 圆形绘制圆形的方法是 arc()。 语法： 1arc(x, y, r, sAngle, eAngle，counterclockwise) x 和 y: 圆心坐标 r: 半径 sAngle: 开始角度 eAngle: 结束角度 counterclockwise: 绘制方向（true: 逆时针; false: 顺时针），默认 false 开始角度和结束角度，都是以弧度为单位。例如 180°就写成 Math.PI ，360°写成 Math.PI * 2 ，以此类推。 在实际开发中，为了让自己或者别的开发者更容易看懂弧度的数值，1°应该写成 Math.PI / 180。 100°: 100 * Math.PI / 180 110°: 110 * Math.PI / 180 241°: 241 * Math.PI / 180 注意：绘制圆形之前，必须先调用 beginPath() 方法！！！ 在绘制完成之后，还需要调用 closePath() 方法！！！ 123456789101112&lt;canvas id=&quot;c&quot; width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const cnv = document.getElementById(&#x27;c&#x27;) const cxt = cnv.getContext(&#x27;2d&#x27;) cxt.beginPath() cxt.arc(150, 150, 80, 0, 360 * Math.PI / 180) cxt.closePath() cxt.stroke()&lt;/script&gt; 半圆如果使用 arc() 方法画圆时，没做到刚好绕完一周（360°）就直接闭合路径，就会出现半圆的状态。 123456789101112&lt;canvas id=&quot;c&quot; width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const cnv = document.getElementById(&#x27;c&#x27;) const cxt = cnv.getContext(&#x27;2d&#x27;) cxt.beginPath() cxt.arc(150, 150, 100, 0, 180 * Math.PI / 180) // 顺时针 cxt.closePath() cxt.stroke()&lt;/script&gt; 上面的代码中，cxt.arc 最后一个参数没传，默认是 false ，所以是顺时针绘制。 如果希望半圆的弧面在上方，可以将 cxt.arc 最后一个参数设置成 true 123456789101112&lt;canvas id=&quot;c&quot; width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const cnv = document.getElementById(&#x27;c&#x27;) const cxt = cnv.getContext(&#x27;2d&#x27;) cxt.beginPath() cxt.arc(150, 150, 100, 0, 180 * Math.PI / 180, true) cxt.closePath() cxt.stroke()&lt;/script&gt; 弧线使用 arc() 方法画半圆时，如果最后不调用 closePath() 方法，就不会出现闭合路径。也就是说，那是一条弧线。 在 canvas 中，画弧线有2中方法：arc() 和 arcTo() 。 arc() 画弧线如果想画一条 0° ~ 30° 的弧线，可以这样写 1234567891011&lt;canvas id=&quot;c&quot; width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const cnv = document.getElementById(&#x27;c&#x27;) const cxt = cnv.getContext(&#x27;2d&#x27;) cxt.beginPath() cxt.arc(150, 150, 100, 0, 30 * Math.PI / 180) cxt.stroke()&lt;/script&gt; 原理如下图所示，红线代表画出来的那条弧线。 arcTo() 画弧线arcTo() 的使用方法会更加复杂，如果初学看不太懂的话可以先跳过，看完后面的再回来补补。 语法： 1arcTo(cx, cy, x2, y2, radius) cx: 两切线交点的横坐标 cy: 两切线交点的纵坐标 x2: 结束点的横坐标 y2: 结束点的纵坐标 radius: 半径 其中，(cx, cy) 也叫控制点，(x2, y2) 也叫结束点。 是不是有点奇怪，为什么没有 x1 和 y1 ？ (x1, y1) 是开始点，通常是由 moveTo() 或者 lineTo() 提供。 arcTo() 方法利用 开始点、控制点和结束点形成的夹角，绘制一段与夹角的两边相切并且半径为 radius 的圆弧。 举个例子 1234567891011&lt;canvas id=&quot;c&quot; width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const cnv = document.getElementById(&#x27;c&#x27;) const cxt = cnv.getContext(&#x27;2d&#x27;) cxt.moveTo(40, 40) cxt.arcTo(120, 40, 120, 120, 80) cxt.stroke()&lt;/script&gt; 基础样式前面学完基础图形，接下来可以开始了解一下如何设置元素的基础样式。 描边 stroke()前面的案例中，其实已经知道使用 stroke() 方法进行描边了。这里就不再多讲这个方法。 线条宽度 lineWidthlineWidth 默认值是 1 ，默认单位是 px。 语法： 1lineWidth = 线宽 123456789101112131415161718192021222324252627&lt;canvas id=&quot;c&quot; width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const cnv = document.getElementById(&#x27;c&#x27;) const cxt = cnv.getContext(&#x27;2d&#x27;) // 线宽 10 cxt.beginPath() cxt.moveTo(50, 50) cxt.lineTo(250, 50) cxt.lineWidth = 10 // 设置线宽 cxt.stroke() // 线宽 20 cxt.beginPath() cxt.moveTo(50, 150) cxt.lineTo(250, 150) cxt.lineWidth = 20 // 设置线宽 cxt.stroke() // 线宽 30 cxt.beginPath() cxt.moveTo(50, 250) cxt.lineTo(250, 250) cxt.lineWidth = 30 // 设置线宽 cxt.stroke()&lt;/script&gt; 线条颜色 strokeStyle使用 strokeStyle 可以设置线条颜色 语法: 1strokeStyle = 颜色值 123456789101112&lt;canvas id=&quot;c&quot; width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const cnv = document.getElementById(&#x27;c&#x27;) const cxt = cnv.getContext(&#x27;2d&#x27;) cxt.moveTo(50, 50) cxt.lineTo(250, 50) cxt.lineWidth = 20 cxt.strokeStyle = &#x27;pink&#x27; // 设置颜色 cxt.stroke()&lt;/script&gt; 为了展示方便，我将 lineWidth 设为 20。 线帽 lineCap线帽指的是线段的开始和结尾处的样式，使用 lineCap 可以设置 语法： 1lineCap = &#x27;属性值&#x27; 属性值包括： butt: 默认值，无线帽 square: 方形线帽 round: 圆形线帽 12345678910111213141516171819202122232425262728293031&lt;canvas id=&quot;c&quot; width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const cnv = document.getElementById(&#x27;c&#x27;) const cxt = cnv.getContext(&#x27;2d&#x27;) // 设置线宽，方便演示 cxt.lineWidth = 16 // 默认线帽 butt cxt.beginPath() cxt.moveTo(50, 60) cxt.lineTo(250, 60) cxt.stroke() // 方形线帽 square cxt.beginPath() cxt.lineCap = &#x27;square&#x27; cxt.moveTo(50, 150) cxt.lineTo(250, 150) cxt.stroke() // 圆形线帽 round cxt.beginPath() cxt.lineCap = &#x27;round&#x27; cxt.moveTo(50, 250) cxt.lineTo(250, 250) cxt.stroke()&lt;/script&gt; 使用 square 和 round 的话，会使线条变得稍微长一点点，这是给线条增加线帽的部分，这个长度在日常开发中需要注意。 线帽只对线条的开始和结尾处产生作用，对拐角不会产生任何作用。 拐角样式 lineJoin如果需要设置拐角样式，可以使用 lineJoin 。 语法： 1lineJoin = &#x27;属性值&#x27; 属性值包括： miter: 默认值，尖角 round: 圆角 bevel: 斜角 123456789101112131415161718192021222324252627282930&lt;canvas id=&quot;c&quot; width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const cnv = document.getElementById(&#x27;c&#x27;) const cxt = cnv.getContext(&#x27;2d&#x27;) cxt.lineWidth = 20 // 默认，尖角 cxt.moveTo(50, 40) cxt.lineTo(200, 40) cxt.lineTo(200, 90) cxt.stroke() // 斜角 bevel cxt.beginPath() cxt.moveTo(50, 140) cxt.lineTo(200, 140) cxt.lineTo(200, 190) cxt.lineJoin = &#x27;bevel&#x27; cxt.stroke() // 圆角 round cxt.beginPath() cxt.moveTo(50, 240) cxt.lineTo(200, 240) cxt.lineTo(200, 290) cxt.lineJoin = &#x27;round&#x27; cxt.stroke()&lt;/script&gt; 虚线 setLineDash()使用 setLineDash() 方法可以将描边设置成虚线。 语法： 1setLineDash([]) 需要传入一个数组，且元素是数值型。 虚线分3种情况 只传1个值 有2个值 有3个以上的值 1234567891011121314151617181920212223242526272829&lt;canvas id=&quot;c&quot; width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const cnv = document.getElementById(&#x27;c&#x27;) const cxt = cnv.getContext(&#x27;2d&#x27;) cxt.lineWidth = 20 cxt.strokeStyle = &#x27;pink&#x27; cxt.moveTo(50, 50) cxt.lineTo(200, 50) cxt.setLineDash([10]) // 只传1个参数，实线与空白都是 10px cxt.stroke() cxt.beginPath() cxt.moveTo(50, 100) cxt.lineTo(200, 100) cxt.setLineDash([10, 20]) // 2个参数，此时，实线是 10px, 空白 20px cxt.stroke() cxt.beginPath() cxt.moveTo(50, 150) cxt.lineTo(200, 150) cxt.setLineDash([10, 20, 5]) // 传3个以上的参数，此例：10px实线，20px空白，5px实线，10px空白，20px实线，5px空白 …… cxt.stroke()&lt;/script&gt; 此外，还可以始终 cxt.getLineDash() 获取虚线不重复的距离； 用 cxt.lineDashOffset 设置虚线的偏移位。 填充使用 fill() 可以填充图形，根据前面的例子应该掌握了如何使用 fill() 123456789101112&lt;canvas id=&quot;c&quot; width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const cnv = document.getElementById(&#x27;c&#x27;) const cxt = cnv.getContext(&#x27;2d&#x27;) cxt.fillStyle = &#x27;pink&#x27; cxt.rect(50, 50, 200, 100) cxt.fill()&lt;/script&gt; 可以使用 fillStyle 设置填充颜色，默认是黑色。 非零环绕填充在使用 fill() 方法填充时，需要注意一个规则：非零环绕填充。 在使用 moveTo 和 lineTo 描述图形时，如果是按顺时针绘制，计数器会加1；如果是逆时针，计数器会减1。 当图形所处的位置，计数器的结果为0时，它就不会被填充。 这样说有点复杂，先看看例子 123456789101112131415161718192021&lt;canvas id=&quot;c&quot; width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const cnv = document.getElementById(&#x27;c&#x27;) const cxt = cnv.getContext(&#x27;2d&#x27;) // 外层矩形 cxt.moveTo(50, 50) cxt.lineTo(250, 50) cxt.lineTo(250, 250) cxt.lineTo(50, 250) cxt.closePath() // 内层矩形 cxt.moveTo(200, 100) cxt.lineTo(100, 100) cxt.lineTo(100, 200) cxt.lineTo(200, 200) cxt.closePath() cxt.fill()&lt;/script&gt; 请看看上面的代码，我画了2个矩形，它们都没有用 beginPath() 方法开辟新路径。 内层矩形是逆时针绘制的，所以内层的值是 -1 ，它又经过外层矩形，而外层矩形是顺时针绘制，所以经过外层时值 +1，最终内层的值为 0 ，所以不会被填充。 文本Canvas 提供了一些操作文本的方法。 为了方便演示，我们先了解一下在 Canvas 中如何给本文设置样式。 样式 font和 CSS 设置 font 差不多，Canvas 也可以通过 font 设置样式。 语法： 1cxt.font = &#x27;font-style font-variant font-weight font-size/line-height font-family&#x27; 如果需要设置字号 font-size，需要同事设置 font-family。 1cxt.font = &#x27;30px 宋体&#x27; 描边 strokeText()使用 strokeText() 方法进行文本描边 语法： 1strokeText(text, x, y, maxWidth) text: 字符串，要绘制的内容 x: 横坐标，文本左边要对齐的坐标（默认左对齐） y: 纵坐标，文本底边要对齐的坐标 maxWidth: 可选参数，表示文本渲染的最大宽度（px），如果文本超出 maxWidth 设置的值，文本会被压缩。 123456789&lt;canvas id=&quot;c&quot; width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const cnv = document.getElementById(&#x27;c&#x27;) const cxt = cnv.getContext(&#x27;2d&#x27;) cxt.font = &#x27;60px Arial&#x27; // 将字号设置成 60px，方便观察 cxt.strokeText(&#x27;雷猴&#x27;, 30, 90)&lt;/script&gt; 设置描边颜色 strokeStyle使用 strokeStyle 设置描边颜色。 12345678910&lt;canvas id=&quot;c&quot; width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const cnv = document.getElementById(&#x27;c&#x27;) const cxt = cnv.getContext(&#x27;2d&#x27;) cxt.font = &#x27;60px Arial&#x27; // 将字号设置成 60px，方便观察 cxt.strokeStyle = &#x27;pink&#x27; // 设置文本描边颜色 cxt.strokeText(&#x27;雷猴&#x27;, 30, 90)&lt;/script&gt; 填充 fillText使用 fillText() 可填充文本。 语法和 strokeText() 一样。 1fillText(text, x, y, maxWidth) 123456789&lt;canvas id=&quot;c&quot; width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const cnv = document.getElementById(&#x27;c&#x27;) const cxt = cnv.getContext(&#x27;2d&#x27;) cxt.font = &#x27;60px Arial&#x27; cxt.fillText(&#x27;雷猴&#x27;, 30, 90)&lt;/script&gt; 设置填充颜色 fillStyle使用 fillStyle 可以设置文本填充颜色。 12345678910&lt;canvas id=&quot;c&quot; width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const cnv = document.getElementById(&#x27;c&#x27;) const cxt = cnv.getContext(&#x27;2d&#x27;) cxt.font = &#x27;60px Arial&#x27; cxt.fillStyle = &#x27;pink&#x27; cxt.fillText(&#x27;雷猴&#x27;, 30, 90)&lt;/script&gt; 获取文本长度 measureText()measureText().width 方法可以获取文本的长度，单位是 px 。 123456789101112&lt;canvas id=&quot;c&quot; width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const cnv = document.getElementById(&#x27;c&#x27;) const cxt = cnv.getContext(&#x27;2d&#x27;) let text = &#x27;雷猴&#x27; cxt.font = &#x27;bold 40px Arial&#x27; cxt.fillText(text, 40, 80) console.log(cxt.measureText(text).width) // 80&lt;/script&gt; 水平对齐方式 textAlign使用 textAlign 属性可以设置文字的水平对齐方式，一共有5个值可选 start: 默认。在指定位置的横坐标开始。 end: 在指定坐标的横坐标结束。 left: 左对齐。 right: 右对齐。 center: 居中对齐。 红线是辅助参考线。 12345678910111213141516171819202122232425262728293031323334&lt;canvas id=&quot;c&quot; width=&quot;400&quot; height=&quot;400&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const cnv = document.getElementById(&#x27;c&#x27;) const cxt = cnv.getContext(&#x27;2d&#x27;) // 竖向的辅助线（参考线，在画布中间） cxt.moveTo(200, 0) cxt.lineTo(200, 400) cxt.strokeStyle = &#x27;red&#x27; cxt.stroke() cxt.font = &#x27;30px Arial&#x27; // 横坐标开始位对齐 cxt.textAlign = &#x27;start&#x27; // 默认值, cxt.fillText(&#x27;雷猴 start&#x27;, 200, 40) // 横坐标结束位对齐 cxt.textAlign = &#x27;end&#x27; // 结束对齐 cxt.fillText(&#x27;雷猴 end&#x27;, 200, 100) // 左对齐 cxt.textAlign = &#x27;left&#x27; // 左对齐 cxt.fillText(&#x27;雷猴 left&#x27;, 200, 160) // 右对齐 cxt.textAlign = &#x27;right&#x27; // 右对齐 cxt.fillText(&#x27;雷猴 right&#x27;, 200, 220) // 居中对齐 cxt.textAlign = &#x27;center&#x27; // 右对齐 cxt.fillText(&#x27;雷猴 center&#x27;, 200, 280)&lt;/script&gt; 从上面的例子看，start 和 left 的效果好像是一样的，end 和 right 也好像是一样的。 在大多数情况下，它们的确一样。但在某些国家或者某些场合，阅读文字的习惯是 从右往左 时，start 就和 right 一样了，end 和 left 也一样。这是需要注意的地方。 垂直对齐方式 textBaseline使用 textBaseline 属性可以设置文字的垂直对齐方式。 在使用 textBaseline 前，需要自行了解 css 的文本基线。 用一张网图解释一下基线 textBaseline 可选属性： alphabetic: 默认。文本基线是普通的字母基线。 top: 文本基线是 em 方框的顶端。 bottom: 文本基线是 em 方框的底端。 middle: 文本基线是 em 方框的正中。 hanging: 文本基线是悬挂基线。 红线是辅助参考线。 12345678910111213141516171819202122232425262728293031323334&lt;canvas id=&quot;c&quot; width=&quot;800&quot; height=&quot;300&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const cnv = document.getElementById(&#x27;c&#x27;) const cxt = cnv.getContext(&#x27;2d&#x27;) // 横向的辅助线（参考线，在画布中间） cxt.moveTo(0, 150) cxt.lineTo(800, 150) cxt.strokeStyle = &#x27;red&#x27; cxt.stroke() cxt.font = &#x27;20px Arial&#x27; // 默认 alphabetic cxt.textBaseline = &#x27;alphabetic&#x27; cxt.fillText(&#x27;雷猴 alphabetic&#x27;, 10, 150) // 默认 top cxt.textBaseline = &#x27;top&#x27; cxt.fillText(&#x27;雷猴 top&#x27;, 200, 150) // 默认 bottom cxt.textBaseline = &#x27;bottom&#x27; cxt.fillText(&#x27;雷猴 bottom&#x27;, 320, 150) // 默认 middle cxt.textBaseline = &#x27;middle&#x27; cxt.fillText(&#x27;雷猴 middle&#x27;, 480, 150) // 默认 hanging cxt.textBaseline = &#x27;hanging&#x27; cxt.fillText(&#x27;雷猴 hanging&#x27;, 640, 150)&lt;/script&gt; 注意：在绘制文字的时候，默认是以文字的左下角作为参考点进行绘制 图片在 Canvas 中可以使用 drawImage() 方法绘制图片。 渲染图片渲染图片的方式有2中，一种是在JS里加载图片再渲染，另一种是把DOM里的图片拿到 canvas 里渲染。 渲染的语法： 1drawImage(image, dx, dy) image: 要渲染的图片对象。 dx: 图片左上角的横坐标位置。 dy: 图片左上角的纵坐标位置。 JS版在 JS 里加载图片并渲染，有以下几个步骤： 创建 Image 对象 引入图片 等待图片加载完成 使用 drawImage() 方法渲染图片 123456789101112131415161718&lt;canvas id=&quot;c&quot; width=&quot;500&quot; height=&quot;500&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const cnv = document.getElementById(&#x27;c&#x27;) const cxt = cnv.getContext(&#x27;2d&#x27;) // 1 创建 Image 对象 const image = new Image() // 2 引入图片 image.src = &#x27;./images/dog.jpg&#x27; // 3 等待图片加载完成 image.onload = () =&gt; &#123; // 4 使用 drawImage() 方法渲染图片 cxt.drawImage(image, 30, 30) &#125;&lt;/script&gt; DOM版 1234567891011121314151617&lt;style&gt; #dogImg &#123; display: none; &#125;&lt;/style&gt;&lt;img src=&quot;./images/dog.jpg&quot; id=&quot;dogImg&quot;/&gt;&lt;canvas id=&quot;c&quot; width=&quot;500&quot; height=&quot;500&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const cnv = document.getElementById(&#x27;c&#x27;) const cxt = cnv.getContext(&#x27;2d&#x27;) const image = document.getElementById(&#x27;dogImg&#x27;) cxt.drawImage(image, 70, 70)&lt;/script&gt; 因为图片是从 DOM 里获取到的，所以一般来说，只要在 window.onload 这个生命周期内使用 drawImage 都可以正常渲染图片。 本例使用了 css 的方式，把图片的 display 设置成 none 。因为我不想被 &lt;img&gt; 影响到本例讲解。 实际开发过程中按照实际情况设置即可。 设置图片宽高前面的例子都是直接加载图片，图片默认的宽高是多少就加载多少。 如果需要指定图片宽高，可以在前面的基础上再添加两个参数： 1drawImage(image, dx, dy, dw, dh) image、 dx、 dy 的用法和前面一样。 dw 用来定义图片的宽度，dh 定义图片的高度。 12345678910111213&lt;canvas id=&quot;c&quot; width=&quot;500&quot; height=&quot;500&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const cnv = document.getElementById(&#x27;c&#x27;) const cxt = cnv.getContext(&#x27;2d&#x27;) const image = new Image() image.src = &#x27;./images/dog.jpg&#x27; image.onload = () =&gt; &#123; cxt.drawImage(image, 30, 30, 100, 100) &#125;&lt;/script&gt; 我把图片的尺寸设为 100px * 100px，图片看上去比之前就小了很多。 截取图片截图图片同样使用drawImage() 方法，只不过传入的参数数量比之前都多，而且顺序也有点不一样了。 1drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh) 以上参数缺一不可 image: 图片对象 sx: 开始截取的横坐标 sy: 开始截取的纵坐标 sw: 截取的宽度 sh: 截取的高度 dx: 图片左上角的横坐标位置 dy: 图片左上角的纵坐标位置 dw: 图片宽度 dh: 图片高度 12345678910111213&lt;canvas id=&quot;c&quot; width=&quot;500&quot; height=&quot;500&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt;&lt;script&gt; const cnv = document.getElementById(&#x27;c&#x27;) const cxt = cnv.getContext(&#x27;2d&#x27;) const image = new Image() image.src = &#x27;./images/dog.jpg&#x27; image.onload = () =&gt; &#123; cxt.drawImage(image, 0, 0, 100, 100, 30, 30, 200, 200) &#125;&lt;/script&gt; 总结本文主要讲解了在 Canvas 中绘制一些基础图形，还有一些基础样式设置。 还有更多高级的玩法会在之后的文章中讲到，比如渐变、投影、滤镜等等。 代码仓库⭐雷猴 Canvas 推荐阅读👍《Fabric.js 从入门到膨胀》 👍《『Three.js』起飞！》 👍《console.log也能插图！！！》 👍《纯css实现117个Loading效果》 👍《视差特效的原理和实现方法》 👍《这18个网站能让你的页面背景炫酷起来》 点赞 + 关注 + 收藏 &#x3D; 学会了","tags":["Canvas"],"categories":["Canvas"]},{"title":"SVG快速入门（图解版）","path":"/2024/04/12/SVG快速入门（图解版）/","content":"原文地址SVG 从入门到后悔，怎么不早点学起来（图解版） - 掘金 在我接触 SVG 之前，我觉得这是一个很高深的东西，有点恐惧。我第一次接触 SVG 是在 iconfont网站，我没理它是什么东西，反正就跟着教程用。第二次接触就是在 《CSS揭秘（图灵出品）》 这本书，里面会讲到 SVG 相关的内容，而我选择了跳过这部分内容。。。 之后是怎么学会的我也忘了。 最近时间比较多，就把我懂的知识用人话整理出来，方便查询。 本文主要把 “可视” 方面的内容整理出来，操作交互方面(动画、交互事件等) 的内容留到下一篇~ 什么是SVG在学习 SVG 之前，首先要了解 位图 和 矢量图 的区别。 简单来说： 位图：放大会失真图像边缘有锯齿；是由像素点组成；前端的 Canvas 就是位图效果。 矢量图：放大不会失真；使用 XML 描述图形。 我在 知乎 上找了一个图对说明一下。 左边是位图，右边是矢量图 那么 SVG 是什么呢？它是矢量图的其中一种格式。它是用 XML 来描述图形的。 对于初学 SVG 的前端来说，可以简单的理解为 “SVG 是一套新标签”。 所以可以使用 CSS 来设置样式，也可以使用 JS 对 SVG 进行操作。 SVG的使用方式使用方法SVG 的使用方式有很多种，我最推荐直接在 HTML 中直接使用，也就是直接当 HTML 标签使用。 我在 《SVG 在前端的7种使用方法》 里记录了几种使用方法： 在浏览器直接打开 内嵌到 HTML 中（推荐⭐⭐⭐） CSS 背景图（推荐⭐） 使用 img 标签引入（推荐⭐） 使用 iframe 标签引入（不推荐❌） 使用 embed 标签引入（不推荐❌） 使用 object 标签引入（不推荐❌） SVG默认宽高在 HTML 中使用 SVG ，直接用 &lt;svg&gt; 标签即可。 1&lt;svg&gt;&lt;/svg&gt; 在不给 &lt;svg&gt; 设置宽高时，它的默认宽度是 300px ，默认高度是 150px 。这点和 &lt;canvas&gt; 是一样的。 基础图形HTML 的元素大多数默认都是矩形，SVG 在形状上更加丰富。 矩形 rect矩形使用 &lt;rect&gt; 标签，默认填充色是黑色，当只设置宽高时，渲染出来的矩形就是黑色的矩形。 稍后还会说明如何设置样式（比如边框、填充色等），这里只列出矩形基础属性： x: 左上角x轴坐标 y: 左上角y轴坐标 width: 宽度 height: 高度 rx: 圆角，x轴的半径 ry: 圆角，y轴的半径 基础款（只设置宽高） 123&lt;svg width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid red;&quot;&gt; &lt;rect width=&quot;200&quot; height=&quot;100&quot;&gt;&lt;/rect&gt;&lt;/svg&gt; 设置矩形位置通过 x 和 y 可以设置矩形位置 123456789&lt;svg width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid red;&quot;&gt; &lt;rect x=&quot;30&quot; y=&quot;20&quot; width=&quot;200&quot; height=&quot;100&quot; &gt; &lt;/rect&gt;&lt;/svg&gt; 圆角矩形 123456789&lt;svg width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid red;&quot;&gt; &lt;rect width=&quot;200&quot; height=&quot;100&quot; rx=&quot;20&quot; ry=&quot;40&quot; &gt; &lt;/rect&gt;&lt;/svg&gt; rx 是设置x轴的半径，ry 设置y轴的半径。 rx 的最大值是矩形宽度的一半，ry 的最大值是矩形高度的一半。 当只设置 rx 或者 ry 其中一个值时，另一个属性也会使用一样的值。 比如 12345678&lt;svg width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid red;&quot;&gt; &lt;rect width=&quot;200&quot; height=&quot;100&quot; rx=&quot;30&quot; &gt; &lt;/rect&gt;&lt;/svg&gt; 此时 rx 和 ry 都是 30。 rect版的圆形圆角的概念和 CSS 的 border-radius 有点像，所以有没有一种可能，用 &lt;rect&gt; 也可以画圆形呢？ 12345678&lt;svg width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid red;&quot;&gt; &lt;rect width=&quot;100&quot; height=&quot;100&quot; rx=&quot;50&quot; &gt; &lt;/rect&gt;&lt;/svg&gt; 只要把宽高设成一样，圆角设成宽度的一半就能实现圆形。这是在 HTML 里的实现方式之一。 同理也用 &lt;rect&gt; 实现椭圆，但在 SVG 中是不会这样做的。因为 SVG 里有专门的圆形和椭圆的标签。 圆形 circle圆形使用 &lt;circle&gt; 标签，基础属性有： cx: 圆心在x轴的坐标 cy: 圆心在y轴的坐标 r: 半径 12345678&lt;svg width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid red;&quot;&gt; &lt;circle cx=&quot;60&quot; cy=&quot;80&quot; r=&quot;50&quot; &gt; &lt;/circle&gt;&lt;/svg&gt; 椭圆 ellipse椭圆使用 &lt;ellipse&gt; 标签，基础属性有： cx: 圆心在x轴的坐标 cy: 圆心在y轴的坐标 rx: x轴的半径 ry: y轴的半径 123456789&lt;svg width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid red;&quot;&gt; &lt;ellipse cx=&quot;100&quot; cy=&quot;40&quot; rx=&quot;80&quot; ry=&quot;30&quot; &gt; &lt;/ellipse&gt;&lt;/svg&gt; &lt;ellipse&gt; 和 &lt;circle&gt; 差不多，只是将半径拆成x轴和y轴的。 直线 line直线使用 &lt;line&gt; 标签，基础属性有： x1: 起始点x坐标 y1: 起始点y坐标 x2: 结束点x坐标 y2: 结束点y坐标 stroke: 描边颜色 12345678910&lt;svg width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid red;&quot;&gt; &lt;line x1=&quot;30&quot; y1=&quot;40&quot; x2=&quot;200&quot; y2=&quot;180&quot; stroke=&quot;blue&quot; &gt; &lt;/line&gt;&lt;/svg&gt; 只有 x1 和 x2 ，没有 x3 ，也没有 y3 。 需要注意的是，&lt;line&gt; 需要使用设置 stroke 属性才会有绘制效果。 折线 polyline使用 &lt;polyline&gt; 可以绘制折线，基础属性有： points: 点集 stroke: 描边颜色 fill: 填充颜色 12345678&lt;svg width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid red;&quot;&gt; &lt;polyline points=&quot;10 10, 200 80, 230 230&quot; stroke=&quot;#000&quot; fill=&quot;none&quot; &gt; &lt;/polyline&gt;&lt;/svg&gt; points 接受的值是一串点集，点集是两两一组表示一个坐标。 其实点集完全不需要用逗号隔开，上面的例子中我使用了逗号隔开，完全是为了让自己阅读代码时比价易懂。一个逗号分隔一个 xy 坐标。 在绘制折线是，我通常是将 fill 设置成 none ，因为 fill 默认值是黑色，如果不设置成 none 会出现以下效果： 1234567&lt;svg width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid red;&quot;&gt; &lt;polyline points=&quot;10 10, 200 80, 230 230&quot; stroke=&quot;#000&quot; &gt; &lt;/polyline&gt;&lt;/svg&gt; 将 fill 设置成 none 后，必须设置 stroke 为一个有颜色的值，不然不会有渲染效果。 多边形 polygon多边形使用 &lt;polygon&gt; 标签，基础属性和 &lt;polyline&gt; 差不多： points: 点集 stroke: 描边颜色 fill: 填充颜色 &lt;polygon&gt; 会自动闭合（自动将起始点和结束点链接起来）。 123&lt;svg width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid red;&quot;&gt; &lt;polygon points=&quot;10 10, 200 80, 230 230&quot;&gt;&lt;/polygon&gt;&lt;/svg&gt; 直线路径 path其实在 SVG 里，所有基本图形都是 &lt;path&gt; 的简写。所有描述轮廓的数据都放在 d 属性里，d 是 data 的简写。 d 属性又包括以下主要的关键字（注意大小写！）： M: 起始点坐标，moveto 的意思。每个路径都必须以 M 开始。M 传入 x 和 y 坐标，用逗号或者空格隔开。 L: 轮廓坐标，lineto 的意思。L 是跟在 M 后面的。它也是可以传入一个或多个坐标。大写的 L 是一个绝对位置。 l: 这是小写 L，和 L 的作用差不多，但 l 是一个相对位置。 H: 和上一个点的Y坐标相等，是 horizontal lineto 的意思。它是一个绝对位置。 h: 和 H 差不多，但 h 使用的是相对定位。 V: 和上一个点的X坐标相等，是vertical lineto 的意思。它是一个绝对位置。 v: 这是一个小写的 v ，和大写 V 的差不多，但小写 v 是一个相对定位。 Z: 关闭当前路径，closepath 的意思。它会绘制一条直线回到当前子路径的起点。 概念说了一堆，还是用写 demo 的方式来展示会更加直观。 基础版 12345678&lt;svg width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid red;&quot;&gt; &lt;path d=&quot;M 10 10 L 50 40 L 100 10&quot; stroke=&quot;blue&quot; fill=&quot;none&quot; &gt; &lt;/path&gt;&lt;/svg&gt; 上面的例子里，通过1个 M 和3个 L 描绘了3个点。 使用 stroke 设置描边的颜色，使用 fill=&quot;none&quot; 将填充色改成透明。最后就形成上图的效果。 简写如果全是使用大写 L 来描述每个点的位置，那可以把 L 也去掉，直接写点集。 12345678&lt;svg width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid red;&quot;&gt; &lt;path d=&quot;M 10 10 50 40 100 10&quot; stroke=&quot;blue&quot; fill=&quot;none&quot; &gt; &lt;/path&gt;&lt;/svg&gt; 上面的 d=&quot;M 10 10 50 40 100 10&quot; 等同于 d=&quot;M 10 10 L 50 40 L 100 10&quot; 。 闭合路径在 d 的数据集里，使用 Z 可以闭合路径。 12345678&lt;svg width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid red;&quot;&gt; &lt;path d=&quot;M 10 10 L 50 40 L 100 10 Z&quot; stroke=&quot;blue&quot; fill=&quot;none&quot; &gt; &lt;/path&gt;&lt;/svg&gt; 轮廓坐标相对位置 l使用 L 的小写方式 l 可以实现相对位置写法。 12345678&lt;svg width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid red;&quot;&gt; &lt;path d=&quot;M 10 10 l 50 40 l 100 10 Z&quot; stroke=&quot;blue&quot; fill=&quot;none&quot; &gt; &lt;/path&gt;&lt;/svg&gt; 上面的代码中，d=&quot;M 10 10 l 50 40 l 100 10 Z&quot; 等同于 d=&quot;M 10 10 L 60 50 L 160 60 Z&quot; 。 l 里的参数会与前一个点的 x 和 y 进行相加，得到一个新的坐标。 H 和 hH 后面只需传入 X坐标 即可，它的 Y坐标 与前一个点相同。 12345678&lt;svg width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid red;&quot;&gt; &lt;path d=&quot;M 10 10 H 100&quot; stroke=&quot;blue&quot; fill=&quot;none&quot; &gt; &lt;/path&gt;&lt;/svg&gt; 上面的代码中，d=&quot;M 10 10 H 100&quot; 等同于 d=&quot;M 10 10 L 100 10&quot; 而 h 和 H 的作用差不多，只不过传入的数据会和前一个点的 X坐标 相加，形成一个新的点，这就是相对位置。 12345678&lt;svg width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid red;&quot;&gt; &lt;path d=&quot;M 10 10 h 100&quot; stroke=&quot;blue&quot; fill=&quot;none&quot; &gt; &lt;/path&gt;&lt;/svg&gt; 可以讲 H 和 h 的例子产生的图片对照一下。 V 和 vV 后面只需传入 Y坐标 即可，它的 X坐标 与前一个点相同。 12345678&lt;svg width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid red;&quot;&gt; &lt;path d=&quot;M 10 10 V 100&quot; stroke=&quot;blue&quot; fill=&quot;none&quot; &gt; &lt;/path&gt;&lt;/svg&gt; v 和 V 的作用差不多，小写 v 是一个相对位置。 12345678&lt;svg width=&quot;300&quot; height=&quot;300&quot; style=&quot;border: 1px solid red;&quot;&gt; &lt;path d=&quot;M 10 10 v 100&quot; stroke=&quot;blue&quot; fill=&quot;none&quot; &gt; &lt;/path&gt;&lt;/svg&gt; 曲线 - 椭圆弧路径 path在 SVG 中，画曲线其实有很多种方法。我觉得最简单的是 椭圆弧曲线，其实还有 贝塞尔曲线、三次贝塞尔曲线 等一系列复杂的曲线。但我觉得这对初学者来说可能一下子难以接受，所以我在 《Canvas 从入门到劝朋友放弃（图解版）》 里也没写。之后打算再写一篇贝塞尔曲线相关的文章骗点赞~ 什么是椭圆弧？前面讲到的 直线路径 path 是比较好理解的，它把所有点都用直线连接起来即可。只要确定2个点就可以画出一根线段。 但如果只用两个点，可以产生无数条曲线。所以需要添加更多的参数来确定如何绘制一条曲线。而在种种方法中，我认为 椭圆弧曲线 是最简单的。 椭圆弧曲线，顾名思义就是和椭圆有关的。如果在椭圆上选择两个点，就可以截取2条曲线。 比如这样，红线处就将椭圆截取成2段弧线。 椭圆弧公式在 SVG 中可以使用 path 配合 A属性 绘制椭圆弧。 1A(rx, ry, xr, laf, sf, x, y) rx: 椭圆X轴半径 ry: 椭圆Y轴半径 xr: 椭圆旋转角度 laf: 是否选择弧长较长的那一段。0: 短边（小于180度）; 1: 长边（大于等于180度） sf: 是否顺时针绘制。0: 逆时针; 1: 顺时针 x: 终点X轴坐标 y: 终点Y轴坐标 上面的公式中并没有开始点，开始点是由 M 决定的。 也就是说，确定2个点，再确定椭圆半径，就可画出2个椭圆 通过开始点和结束点裁切，可以得到4条弧线，也就是说2个点可以确定2个相同旋转角度的椭圆的位置，可以切出4条弧线。 1234567891011121314151617181920212223242526272829&lt;svg width=&quot;400&quot; height=&quot;400&quot; style=&quot;border: 1px solid red;&quot;&gt; &lt;!-- 红 --&gt; &lt;path d=&quot;M 125 75 A 100 50 0 0 0 225 125&quot; stroke=&quot;red&quot; fill=&quot;none&quot; /&gt; &lt;!-- 黄 --&gt; &lt;path d=&quot;M 125 75 A 100 50 0 0 1 225 125&quot; stroke=&quot;yellow&quot; fill=&quot;none&quot; /&gt; &lt;!-- 蓝 --&gt; &lt;path d=&quot;M 125 75 A 100 50 0 1 0 225 125&quot; stroke=&quot;blue&quot; fill=&quot;none&quot; /&gt; &lt;!-- 绿 --&gt; &lt;path d=&quot;M 125 75 A 100 50 0 1 1 225 125&quot; stroke=&quot;green&quot; fill=&quot;none&quot; /&gt;&lt;/svg&gt; 绘制弧线是比较抽象的，通常我是不会手动绘制的，我会使用 Illustrator 绘制，然后生成 SVG 来使用。 设置样式的方法设置 SVG 元素样式其实和 CSS 差不多，常见的方法有4种。 属性样式 内联样式 内部样式 外部样式 属性样式直接在元素属性上设置样式，比如将矩形填充色改成粉红 123456789&lt;svg width=&quot;400&quot; height=&quot;400&quot; style=&quot;border: 1px solid red;&quot;&gt; &lt;rect x=&quot;100&quot; y=&quot;100&quot; width=&quot;200&quot; height=&quot;100&quot; fill=&quot;pink&quot; /&gt;&lt;/svg&gt; 内联样式把所有样式写在 style 属性里 123456789&lt;svg width=&quot;400&quot; height=&quot;400&quot; style=&quot;border: 1px solid red;&quot;&gt; &lt;rect x=&quot;100&quot; y=&quot;100&quot; width=&quot;200&quot; height=&quot;100&quot; style=&quot;fill: pink;&quot; /&gt;&lt;/svg&gt; 内部样式将样式写在 &lt;style&gt; 标签里 123456789101112131415&lt;style&gt; .rect &#123; fill: pink; &#125;&lt;/style&gt;&lt;svg width=&quot;400&quot; height=&quot;400&quot; style=&quot;border: 1px solid red;&quot;&gt; &lt;rect x=&quot;100&quot; y=&quot;100&quot; width=&quot;200&quot; height=&quot;100&quot; class=&quot;rect&quot; /&gt;&lt;/svg&gt; 外部样式将样式写在 .css 文件里，然后在页面中引入该 CSS 文件。 常用样式设置SVG 设置样式的属性和 CSS 稍微有点不同，但初学时不需要了解太深入，我们只需将常用的学会即可。 比如填充色、描边颜色等。 说到颜色，SVG 和 CSS 支持的颜色值其实差不多的，比如： 关键字: red、pink、blue 等 十六进制: 支持3位或6位，#0f0、#00ff00 RGB 和 RGBA: 比如 rgb(10, 20, 30) 或 rgba(10, 20, 30, 0.4) HSL 和 HSLA 接下来讲到的所有常规属性，除了在元素属性上设置之外，都支持在 CSS 中设置。 填充 fill要填充图案颜色，可以设置 fill 属性。这个属性在前面的例子也使用过多次。 fill 默认是 #000000 ，也就是黑色。 123456789&lt;svg width=&quot;400&quot; height=&quot;400&quot; style=&quot;border: 1px solid red;&quot;&gt; &lt;rect x=&quot;100&quot; y=&quot;100&quot; width=&quot;200&quot; height=&quot;100&quot; fill=&quot;greenyellow&quot; /&gt;&lt;/svg&gt; 也可以使用 none 或者 transparent 将填充色设置成透明。 填充色的不透明度 fill-opacity如果想让填充色有点 半透明 的感觉，可以设置 fill-opacity 属性，也可以在 fill 属性中使用 RGBA 或者 HSLA。 本例使用 fill-opacity 设置，它的取值是 0 - 1，0 代表完全透明，1 代表完全不透明。小于 0 的值会被改为 0，大于 1 的值会被改为 1 。 12345678910&lt;svg width=&quot;400&quot; height=&quot;400&quot; style=&quot;border: 1px solid red;&quot;&gt; &lt;rect x=&quot;100&quot; y=&quot;100&quot; width=&quot;200&quot; height=&quot;100&quot; fill=&quot;red&quot; fill-opacity=&quot;0.2&quot; /&gt;&lt;/svg&gt; fill 属性中使用 RGBA 或者 HSLA 的方式你自己动手试试看~ 描边颜色 stroke可以通过 stroke 属性设置描边的颜色，之前也使用过。如果不设置 stroke ，图形默认是没有描边颜色的。 12345678910&lt;svg width=&quot;400&quot; height=&quot;400&quot; style=&quot;border: 1px solid red;&quot;&gt; &lt;rect x=&quot;100&quot; y=&quot;100&quot; width=&quot;200&quot; height=&quot;100&quot; fill=&quot;none&quot; stroke=&quot;blue&quot; /&gt;&lt;/svg&gt; 我将填充色设置成透明，方便观察蓝色边框。 描边颜色的不透明度 stroke-opacity和 fill-opacity 差不多，只不过 stroke-opacity 是设置描边的不透明度 1234567891011&lt;svg width=&quot;400&quot; height=&quot;400&quot; style=&quot;border: 1px solid red;&quot;&gt; &lt;rect x=&quot;100&quot; y=&quot;100&quot; width=&quot;200&quot; height=&quot;100&quot; fill=&quot;none&quot; stroke=&quot;blue&quot; stroke-opacity=&quot;0.3&quot; /&gt;&lt;/svg&gt; 描边宽度 stroke-width如果需要调整描边的宽度，可以使用 stroke-width，它接收一个数值 1234567891011&lt;svg width=&quot;400&quot; height=&quot;400&quot; style=&quot;border: 1px solid red;&quot;&gt; &lt;rect x=&quot;100&quot; y=&quot;100&quot; width=&quot;200&quot; height=&quot;100&quot; fill=&quot;none&quot; stroke=&quot;blue&quot; stroke-width=&quot;10&quot; /&gt;&lt;/svg&gt; 虚线描边 stroke-dasharray边框的 点线 或者 虚线 样式，可以使用 stroke-dasharray 设置，这和 Canvas 里设置虚线的操作其实是差不多。 stroke-dasharray 接收一串数字，这串数字可以用来代表 线的长度和空隙的长度，数字之间用逗号或者空格分隔。 建议传入偶数个数字。但如果你传入了奇数个数字，SVG 会将这串数字重复一遍，使它的数量变成 偶数个 。 123456789101112131415161718192021222324252627&lt;svg width=&quot;400&quot; height=&quot;400&quot; style=&quot;border: 1px solid red;&quot;&gt; &lt;line x1=&quot;30&quot; y1=&quot;30&quot; x2=&quot;300&quot; y2=&quot;30&quot; stroke=&quot;blue&quot; /&gt; &lt;line x1=&quot;30&quot; y1=&quot;70&quot; x2=&quot;300&quot; y2=&quot;70&quot; stroke=&quot;blue&quot; stroke-dasharray=&quot;20 10&quot; /&gt; &lt;line x1=&quot;30&quot; y1=&quot;110&quot; x2=&quot;300&quot; y2=&quot;110&quot; stroke=&quot;blue&quot; stroke-dasharray=&quot;20 10 30&quot; /&gt;&lt;/svg&gt; 虚线偏移量 stroke-dashoffset虚线还可以通过 stroke-dashoffset 属性设置偏移量，它接收一个数值类型的值。 12345678910111213141516171819202122&lt;svg width=&quot;400&quot; height=&quot;400&quot; style=&quot;border: 1px solid red;&quot;&gt; &lt;line x1=&quot;30&quot; y1=&quot;30&quot; x2=&quot;300&quot; y2=&quot;30&quot; stroke=&quot;blue&quot; stroke-width=&quot;10&quot; stroke-dasharray=&quot;20 10 30&quot; /&gt; &lt;line x1=&quot;30&quot; y1=&quot;90&quot; x2=&quot;300&quot; y2=&quot;90&quot; stroke=&quot;blue&quot; stroke-width=&quot;10&quot; stroke-dasharray=&quot;20 10 30&quot; stroke-dashoffset=&quot;10&quot; /&gt;&lt;/svg&gt; 我加粗了虚线，方便观察偏移量。 线帽 stroke-linecap线帽就是线的起始点和结束点的位置，用 stroke-linecap 属性可以设置线帽样式。 线帽有3个值： butt: 平头（默认值） round: 圆头 square: 方头 12345678910111213141516171819202122232425262728293031323334&lt;svg width=&quot;400&quot; height=&quot;400&quot; style=&quot;border: 1px solid red;&quot;&gt; &lt;!-- 平头 --&gt; &lt;line x1=&quot;30&quot; y1=&quot;30&quot; x2=&quot;300&quot; y2=&quot;30&quot; stroke=&quot;blue&quot; stroke-width=&quot;10&quot; stroke-linecap=&quot;butt&quot; /&gt; &lt;!-- 圆头 --&gt; &lt;line x1=&quot;30&quot; y1=&quot;70&quot; x2=&quot;300&quot; y2=&quot;70&quot; stroke=&quot;blue&quot; stroke-width=&quot;10&quot; stroke-linecap=&quot;round&quot; /&gt; &lt;!-- 方头 --&gt; &lt;line x1=&quot;30&quot; y1=&quot;110&quot; x2=&quot;300&quot; y2=&quot;110&quot; stroke=&quot;blue&quot; stroke-width=&quot;10&quot; stroke-linecap=&quot;square&quot; /&gt;&lt;/svg&gt; 可以看到 square 比 butt 要稍微长一丢丢。 拐角 stroke-linejoin拐角就是折线的交接点，可以使用 stroke-linejoin 设置，它接收以下属性： miter: 尖角（默认） round: 圆角 bevel: 平角 12345678910111213141516171819202122232425262728&lt;svg width=&quot;400&quot; height=&quot;400&quot; style=&quot;border: 1px solid red;&quot;&gt; &lt;!-- 尖角 --&gt; &lt;polyline points=&quot;30 60, 60 30, 90 60&quot; fill=&quot;none&quot; stroke=&quot;blue&quot; stroke-width=&quot;20&quot; stroke-linejoin=&quot;miter&quot; /&gt; &lt;!-- 圆角 --&gt; &lt;polyline points=&quot;30 120, 60 90, 90 120&quot; fill=&quot;none&quot; stroke=&quot;blue&quot; stroke-width=&quot;20&quot; stroke-linejoin=&quot;round&quot; /&gt; &lt;!-- 平角 --&gt; &lt;polyline points=&quot;30 180, 60 150, 90 180&quot; fill=&quot;none&quot; stroke=&quot;blue&quot; stroke-width=&quot;20&quot; stroke-linejoin=&quot;bevel&quot; /&gt;&lt;/svg&gt; 消除锯齿 shape-rendering如果你觉得 SVG 在浏览器显示出来的图像有点模糊，那可能是开启了 反锯齿 功能，可以通过 CSS 属性关闭该功能。 1shape-rendering: crispEdges; 将该属性设置到对应的 svg 元素上，就会关闭反锯齿功能，突显看起来就会清晰很对，但在某些情况关闭了该功能会让图像看起来有点毛躁的感觉。 如果想开启反锯齿功能，可以这样设置：shape-rendering: geometricPrecision; 文本元素 textSVG 可以使用 &lt;text&gt; 标签渲染文本。文本是有 “基线” 概念的，这个概念和 CSS 的一样。这里推荐 AndyHu 的文章，可以快速搞懂基线。《彻底搞懂vertical-align 底线、基线、中线的含义》 基础版和 Canvas 一样，SVG 的文本对齐方式是以第一个字基线的左下角为基准。 123&lt;svg width=&quot;400&quot; height=&quot;400&quot; style=&quot;border: 1px solid red;&quot;&gt; &lt;text&gt;雷猴啊&lt;/text&gt;&lt;/svg&gt; 可以看到，文字跑去左上角了。但这并不是我们想要的效果。 SVG 如果没设置字号，它会跟随父元素的字号，一直往上跟跟跟上去。 在本例中，默认字号是跟随了浏览器的，也就是 16px 。 如果我们想看到文本，就需要将文字往下移动 16px，因为本文的对齐方式是以第一个字的基线的左下角为参考，默认的位置坐标是 (0, 0) ，现在要将y轴坐标改成 16px 才能完整显示文本 123&lt;svg width=&quot;400&quot; height=&quot;400&quot; style=&quot;border: 1px solid red;&quot;&gt; &lt;text y=&quot;16&quot;&gt;雷猴啊&lt;/text&gt;&lt;/svg&gt; 设置字号 font-size 12345678&lt;svg width=&quot;400&quot; height=&quot;400&quot; style=&quot;border: 1px solid red;&quot;&gt; &lt;text y=&quot;60&quot; font-size=&quot;60&quot; &gt; 雷猴啊 &lt;/text&gt;&lt;/svg&gt; 粗体 font-weight使用 font-weight 可以将文本设置成粗体。 normal: 默认（非粗体） bold: 粗体 这和 CSS 是一样的 12345678910111213141516171819&lt;svg width=&quot;400&quot; height=&quot;400&quot; style=&quot;border: 1px solid red;&quot;&gt; &lt;!-- 默认 --&gt; &lt;text y=&quot;60&quot; font-size=&quot;60&quot; font-weight=&quot;normal&quot; &gt; 雷猴啊 &lt;/text&gt; &lt;!-- 粗体 --&gt; &lt;text y=&quot;140&quot; font-size=&quot;60&quot; font-weight=&quot;bold&quot; &gt; 雷猴啊 &lt;/text&gt;&lt;/svg&gt; 装饰线 text-decoration和 CSS 一样，可以使用 text-decoration 设置装饰线 none：默认 underline: 下划线 overline: 上划线 line-through: 删除线 12345678910111213141516171819202122232425262728293031323334353637&lt;svg width=&quot;400&quot; height=&quot;400&quot; style=&quot;border: 1px solid red;&quot;&gt; &lt;!-- 默认 --&gt; &lt;text y=&quot;30&quot; font-size=&quot;30&quot; text-decoration=&quot;none&quot; &gt; 雷猴啊 &lt;/text&gt; &lt;!-- 上划线 --&gt; &lt;text y=&quot;100&quot; font-size=&quot;30&quot; text-decoration=&quot;overline&quot; &gt; 雷猴啊 &lt;/text&gt; &lt;!-- 删除线 --&gt; &lt;text y=&quot;170&quot; font-size=&quot;30&quot; text-decoration=&quot;line-through&quot; &gt; 雷猴啊 &lt;/text&gt; &lt;!-- 下划线 --&gt; &lt;text y=&quot;240&quot; font-size=&quot;30&quot; text-decoration=&quot;underline&quot; &gt; 雷猴啊 &lt;/text&gt;&lt;/svg&gt; 水平对齐方式 text-anchor可以通过 text-anchor 属性设置文本水平对齐方式。 如果本子是从左向右书写，那这几个参数的意思就是： start: 左对齐 middle: 居中对齐 end: 右对齐 多行文本多行文可以使用本 &lt;tspan&gt; 标签辅助实现 12345678&lt;svg width=&quot;400&quot; height=&quot;400&quot; style=&quot;border: 1px solid red;&quot;&gt; &lt;text fill=&quot;blue&quot;&gt; &lt;tspan x=&quot;10&quot; y=&quot;30&quot; fill=&quot;red&quot;&gt;雷猴&lt;/tspan&gt; &lt;tspan x=&quot;10&quot; y=&quot;60&quot;&gt;鲨鱼辣椒&lt;/tspan&gt; &lt;tspan x=&quot;10&quot; y=&quot;90&quot;&gt;蟑螂恶霸&lt;/tspan&gt; &lt;tspan x=&quot;10&quot; y=&quot;120&quot;&gt;蝎子莱莱&lt;/tspan&gt; &lt;/text&gt;&lt;/svg&gt; &lt;tspan&gt; 要放在 &lt;text&gt; 里，而且会继承 &lt;text&gt; 设置的样式。 如果在 &lt;tspan&gt; 里设置的样式和 &lt;text&gt; 的样式有冲突，最后会使用 &lt;tspan&gt; 的样式。 水平对齐方式 12345678910111213141516171819202122232425262728293031&lt;svg width=&quot;400&quot; height=&quot;400&quot; style=&quot;border: 1px solid red;&quot;&gt; &lt;!-- 参考线 --&gt; &lt;path d=&quot;M 200 0 200 400&quot; stroke=&quot;red&quot;&gt;&lt;/path&gt; &lt;!-- 左对齐 --&gt; &lt;text x=&quot;200&quot; y=&quot;100&quot; text-anchor=&quot;start&quot; &gt; 雷猴 &lt;/text&gt; &lt;!-- 居中对齐 --&gt; &lt;text x=&quot;200&quot; y=&quot;130&quot; text-anchor=&quot;middle&quot; &gt; 雷猴 &lt;/text&gt; &lt;!-- 右对齐 --&gt; &lt;text x=&quot;200&quot; y=&quot;160&quot; text-anchor=&quot;end&quot; &gt; 雷猴 &lt;/text&gt;&lt;/svg&gt; 垂直对齐方式 dominant-baseline可以通过 dominant-baseline 属性设置文本垂直对齐方式 auto: 默认的对齐方式，保持与父元素相同的配置。 text-after-edge: 在基线上方 middle: 居中基线 text-before-edge: 在基线下方 12345678910111213141516171819202122232425262728293031323334353637383940&lt;svg width=&quot;400&quot; height=&quot;400&quot; style=&quot;border: 1px solid red;&quot;&gt; &lt;!-- 参考线 --&gt; &lt;path d=&quot;M 0 200 400 200&quot; stroke=&quot;red&quot;&gt;&lt;/path&gt; &lt;!-- 默认 --&gt; &lt;text x=&quot;20&quot; y=&quot;200&quot; dominant-baseline=&quot;auto&quot; &gt; 雷猴 &lt;/text&gt; &lt;!-- 在基线上方 --&gt; &lt;text x=&quot;80&quot; y=&quot;200&quot; dominant-baseline=&quot;text-after-edge&quot; &gt; 雷猴 &lt;/text&gt; &lt;!-- 居中基线 --&gt; &lt;text x=&quot;160&quot; y=&quot;200&quot; dominant-baseline=&quot;middle&quot; &gt; 雷猴 &lt;/text&gt; &lt;!-- 在基线下方 --&gt; &lt;text x=&quot;240&quot; y=&quot;200&quot; dominant-baseline=&quot;text-before-edge&quot; &gt; 雷猴 &lt;/text&gt;&lt;/svg&gt; 纵向文字 writing-mode将 writing-mode 设置成 tb 就可以让文字纵向排列。 需要注意英文和中文的文字角度！ 1234&lt;svg width=&quot;400&quot; height=&quot;400&quot; style=&quot;border: 1px solid red;&quot;&gt; &lt;text x=&quot;20&quot; y=&quot;20&quot; writing-mode=&quot;tb&quot;&gt;Hello World!&lt;/text&gt; &lt;text x=&quot;100&quot; y=&quot;20&quot; writing-mode=&quot;tb&quot;&gt;鲨鱼辣椒&lt;/text&gt;&lt;/svg&gt; 有些教程里面会讲 glyph-orientation-vertical 属性可以旋转文字方向，但不推荐这个方法，因为现在的浏览器可能不再支持它了。 可以看看这个文档的说明：《glyph-orientation-vertical》 超链接和 HTML 一样，超链接可以使用 &lt;a&gt; 标签实现。 在 SVG 里，链接要放在 xlink:href 属性里。 如果希望鼠标放到链接上出现提示信息，可以在 xlink:title 属性里编写提示信息。 如需在新窗口打开链接，可以设置 target=&quot;_blank&quot; 。 12345&lt;svg width=&quot;400&quot; height=&quot;400&quot; style=&quot;border: 1px solid red;&quot;&gt; &lt;a xlink:href=&quot;https://juejin.cn/post/7116784455561248775&quot; xlink:title=&quot;canvas&quot; target=&quot;_blank&quot;&gt; &lt;text x=&quot;20&quot; y=&quot;20&quot;&gt;也学学Canvas吧&lt;/text&gt; &lt;/a&gt;&lt;/svg&gt; 此时点击图片上的链接就会跳到对应的页面。 &lt;a&gt; 标签里除了可以包裹文本外，还可以包裹各种图形和图片等元素。 图片 image在 SVG 中可以使用 &lt;image&gt; 标签加载图片，包括位图。 &lt;image&gt; 是使用 xlink:href 属性获取图片的 123&lt;svg width=&quot;400&quot; height=&quot;400&quot; style=&quot;border: 1px solid red;&quot;&gt; &lt;image xlink:href=&quot;./img.jpg&quot;&gt;&lt;/image&gt;&lt;/svg&gt; 图片标签其实没什么好说的，和 HTML 的 &lt;img&gt; 标签用法差不多。 总结通过上面这么多例子应该对 SVG 有一个大致的了解了。SVG 在前端编码中，感觉就像一堆新的标签。我们只要当它是 HTML 那样使用就行了。 本文记录的所有知识点都是 SVG 基础中的基础。 下一篇会介绍进阶的标签。比如实现渐变、分组，还会介绍比较难理解的坐标系统。 代码仓库⭐雷猴 SVG 推荐阅读👍《Fabric.js 从入门到膨胀》 👍《『Three.js』起飞！》 👍《Canvas 从入门到劝朋友放弃（图解版）》 👍《SVG 在前端的7种使用方法，你还知道哪几种？》 点赞 + 关注 + 收藏 &#x3D; 学会了","tags":["SVG"],"categories":["SVG"]},{"title":"curl实用教程","path":"/2024/04/10/curl实用教程/","content":"curl 是一种命令行工具，作用是发出网络请求，然后得到和提取数据，显示在\"标准输出\"（stdout）上面。 参考 curl 用法指南 基础用法直接请求指定资源123# 如 url包含查询参数，需要用引号括起来，# 因为参数中包含&amp;符号，在shell中表示后台执行curl www.sina.com 响应内容导出到文件默认输出到stdout, 指定 -o file 则输出到指定文件 1curl -o sina.html www.sina.com 发起GET请求并带参数-G 表示 GET请求，默认也是GET请求，所以不加也可以。 12curl -G --data &quot;login=1&amp;name=sindy&quot; localhost:7001curl &quot;https://www.baidu.com/s?wd=weather&amp;rsv_spt=1&quot; 发起POST请求并带参数-X 指定请求方法，-d 指定请求参数，--data-urlencode 对参数进行URL编码, -H&#x2F;--header 指定请求头 用 -d 参数以后，HTTP 请求会自动加上标头 Content-Type : application/x-www-form-urlencoded。并且会自动将请求转为 POST 方法，因此可以省略 -X POST。 12345678# curl -X POST --data &#x27;data&#x27; --header &#x27;header&#x27; url POST请求curl -X POST --data &#x27;&#123;&quot;name&quot;:&quot;controller&quot;&#125;&#x27; --header &#x27;Content-Type:application/json&#x27; http://127.0.0.1:7001/form# 可用多个-d发送多个键值对数据curl -d &#x27;login=emma&#x27; -d &#x27;password=123&#x27; -X POST https://google.com/login -d 参数可以读取本地文本文件的数据，向服务器发送。 1curl -d &#x27;@data.txt&#x27; https://google.com/login 设置请求头-H&#x2F;--header 指定请求头，设置多个header，可指定多个 --header 选项 1234# curl -H val url # curl --header val urlcurl --header &quot;content-type: application/json&quot; --header &quot;authorization: Bearer token&quot; url 设置 useragent-A&#x2F;--user-agent 指定UA, 对于带反爬虫的网站，可以设置UA来伪装浏览器。 12curl -A val urlcurl --user-agent val url 指定 referer对于防止盗链的网站，可以指定 referer 来伪装请求来源。 1curl --referer val url 指定 cookie接口需要鉴权的话，可以指定 cookie 来发送相关鉴权信息。 12curl --cookie &quot;name=alice&quot; url 高级用法追踪重定向，获取重定向后的内容1234567curl -L www.sina.com# 用eggjs起个web服务，controller.home.index中 # ctx.redirect(&#x27;https://www.baidu.com&#x27;)curl http://localhost:7001 # 301 不会返回百度首页内容curl -L http://localhost:7001 # 会返回百度首页内容 显示响应头1234curl -i www.sina.com # 返回响应头和响应体# curl -I url 只显示响应头curl -I www.sina.com 显示完整的 http 通信过程1234curl -v www.sina.com# curl --trace output.txt url 显示更加详细的数据curl --trace output.txt www.baidu.com 自动urlencode传入的数据--data&#x2F;-d 默认不会encode数据 1curl -X POST --data-urlencode &quot;data&quot; url 文件上传1curl --form upload=@localfilename --form press=ok url 保存返回的cookie1curl -c cookies.txt http://example.com 发送 cookie 文件1curl -b cookies.txt http://example.com http 认证1curl --user name:password url 多参数示例123456curl -iv -d &quot;@data.json&quot; --cookie &#x27;csrfToken=REhEag2ATP5vfl2Za6aOXoCT&#x27; --header &#x27;x-csrf-token:REhEag2ATP5vfl2Za6aOXoCT&#x27; --header &#x27;content-type: application/json&#x27; -o out.txt http://localhost:7002/component/create","tags":["curl"]},{"title":"163邮箱发邮件550错误解决方法","path":"/2024/04/01/163邮箱发邮件550错误解决方法/","content":"原文地址163邮箱无法发送邮件发生退信问题 550 User has no permission以及554, DT:SPM的解决办法-CSDN博客 前言 最近项目在做163邮箱转发的时候，发现无法通过163邮箱转发邮件，并会有错误代码的提示，于是在项目里一顿操作，今天分享下这段经验吧。 首先163邮箱在无法完成发送时是会有提示的，本人在项目里分别遇到的是550 User has no permission和554, DT:SPM两种错误代码的提示，163邮箱也会提供一个完整的错误代码的对照表来告诉你错误代码的含义，就是下面这个网址：163邮箱退信代码说明 然后接下来说一下我遇到的两个问题的解决经过。 1. 550 User has no permission 首先这个错误代码的意思是我没有用户权限，我一开始猜测是邮箱设置的问题，然后我参考了下面链接里这篇博客。 邮箱不可用 550 User has no permission 这篇博客虽然底下很多人都评论说解决了问题，但是这篇博客已经是好几年前的博客了，我是用的163邮箱的版本根本没有博客中所提到的设置，于是只能自己摸索。最终还是摸索出来了，现在可以进入下图的设置 然后开启POP3&#x2F;SMTP服务，开启后会生成一个授权密码，用那个授权密码代替邮箱密码进行设置，就可以修复550 User has no permission这个问题了。ps：这个授权码生成后一定要保存好，它生成一次后就不展示了。 2. 554, DT:SPM 解决完550以后，我这边并没有就一步搞定了，而是又遇到了一个554的问题，我这个554的问题在163的文档里介绍是这样的。 很头疼，项目里设置的内容感觉是没问题的，但还是被检测说是垃圾邮件，然后我又参考了以下两篇博客。 smtplib.SMTPDataError: (554, b’DT:SPM的异常 python发送邮件554DT:SPM已解决 代码示例可以成功发送邮件的例子: 1234567891011121314151617181920212223242526272829303132333435const nodemailer = require(&quot;nodemailer&quot;);// !!! 用这个配置方式会报错: connect ECONNREFUSED 127.0.0.1:465// Create a transporter using the Gmail SMTP configuration// const transporter = nodemailer.createTransport(&#123;// service: &quot;smtp.163.com&quot;,// port: 465,// secure: true,// auth: &#123;// user: &quot;your-email@163.com&quot;,// pass: &quot;your-password&quot;,// &#125;,// &#125;);const transporter = nodemailer.createTransport( &quot;smtps://stephenykk_pan@163.com:&#123;邮箱开通SMTP服务后生成的授权码&#125;@smtp.163.com&quot;);// Compose the emailconst mailOptions = &#123; from: &quot;stephenykk_pan@163.com&quot;, to: &quot;your-friend@163.com&quot;, subject: &quot;Temporary Password&quot;, text: &quot;Your temporary password is: 123456&quot;,&#125;;// Send the emailtransporter.sendMail(mailOptions, function (error, info) &#123; if (error) &#123; console.log(&quot;Error sending email:&quot;, error); &#125; else &#123; console.log(&quot;Email sent:&quot;, info.response); &#125;&#125;); 总结一下就是说在发送的时候也给自己抄送一份就可以不被识别成垃圾邮件，这样也可以解决554, DT:SPM这个错误代码的问题。 ps:其实用了抄送的方法以后也没能够解决554这个问题，但感觉是自己设置的问题，最后一生气换成了QQ邮箱去发送，同样的发送内容QQ邮箱倒是没有识别成垃圾邮件。。。"},{"title":"实用的Python编码技巧","path":"/2024/03/29/实用的Python编码技巧/","content":"实用的Python编码技巧 原文地址提高你的Python编码效率 - 掘金 我用Python编程有几年了, 并且我仍然经常惊讶于Python代码可以如何的简洁，如何的 DRY。 我学到了很多小贴士和技巧，大多数来自于阅读开源项目的源代码，像 Django, Flask, Requests 等。 这里我挑出了几个有时被大家忽略的几条，但是它们在日常工作中会有很大帮助。 1. 字典和集合推导式 大多数Python开发者知道使用列表推导式。你不熟悉这一点？ 一个列表推导式是一个创造列表的简短方式:: 1234&gt;&gt;&gt; some_list = [1, 2, 3, 4, 5]&gt;&gt;&gt; another_list = [ x + 1 for x in some_list ]&gt;&gt;&gt; another_list[2, 3, 4, 5, 6] 从Python 3.1开始(也反向地移植到了Python 2.7),我们可以用同样的方式创建集合和字典:: 12345678910&gt;&gt;&gt; # Set Comprehensions&gt;&gt;&gt; some_list = [1, 2, 3, 4, 5, 2, 5, 1, 4, 8]&gt;&gt;&gt; even_set = &#123; x for x in some_list if x % 2 == 0 &#125;&gt;&gt;&gt; even_setset([8, 2, 4])&gt;&gt;&gt; # Dict Comprehensions&gt;&gt;&gt; d = &#123; x: x % 2 == 0 for x in range(1, 11) &#125;&gt;&gt;&gt; d&#123;1: False, 2: True, 3: False, 4: True, 5: False, 6: True, 7: False, 8: True, 9: False, 10: True&#125; 第一个例子中，我们用 some_list 建立了一个元素不重复的集合，但只有偶数。第二个字典的例子中展示了一个字典的创建，这个字典的键是1到10（包括10），值是布尔值，指明该键是不是一个偶数。 另一个值得注意的地方是集合的文法，我们可以这么简单的创建一个集合:: 123&gt;&gt;&gt; my_set = &#123;1, 2, 1, 2, 3, 4&#125;&gt;&gt;&gt; my_setset([1, 2, 3, 4]) 而没有使用到内建的 set 方法 2.使用计数器对象计数 很明显，但很容易遗忘。计数是一个寻常不过的编程任务，而且大多数情形下这不是个难事。不过计数可以更简单。 Python的 collections 库包含一个 dict 的子类，专门解决计数任务:: 123456&gt;&gt;&gt; from collections import Counter&gt;&gt;&gt; c = Counter(&#x27;hello world&#x27;)&gt;&gt;&gt; cCounter(&#123;&#x27;l&#x27;: 3, &#x27;o&#x27;: 2, &#x27; &#x27;: 1, &#x27;e&#x27;: 1, &#x27;d&#x27;: 1, &#x27;h&#x27;: 1, &#x27;r&#x27;: 1, &#x27;w&#x27;: 1&#125;)&gt;&gt;&gt; c.most_common(2)[(&#x27;l&#x27;, 3), (&#x27;o&#x27;, 2)] 3. 漂亮地打印JSON JSON是一个很棒的序列格式，如今广泛应用在API和web服务中，但是很难用裸眼来看大数据量的JSON,它们很长，还在一行里。 可以用参数 indent 来更好地打印JSON数据，这在跟 REPL或是日志打交道的时候很有用:: 1234567891011121314151617181920&gt;&gt;&gt; import json&gt;&gt;&gt; print(json.dumps(data)) # No indention&#123;&quot;status&quot;: &quot;OK&quot;, &quot;count&quot;: 2, &quot;results&quot;: [&#123;&quot;age&quot;: 27, &quot;name&quot;: &quot;Oz&quot;, &quot;lactose_intolerant&quot;: true&#125;, &#123;&quot;age&quot;: 29, &quot;name&quot;: &quot;Joe&quot;, &quot;lactose_intolerant&quot;: false&#125;]&#125;&gt;&gt;&gt; print(json.dumps(data, indent=2)) # With indention&#123; &quot;status&quot;: &quot;OK&quot;, &quot;count&quot;: 2, &quot;results&quot;: [ &#123; &quot;age&quot;: 27, &quot;name&quot;: &quot;Oz&quot;, &quot;lactose_intolerant&quot;: true &#125;, &#123; &quot;age&quot;: 29, &quot;name&quot;: &quot;Joe&quot;, &quot;lactose_intolerant&quot;: false &#125; ]&#125; 另外，去看看内建模块 pprint , 它可以帮助你漂亮地输出其它的东西。 4. 快速建立一个web服务 有时我们需要一个建立RPC服务简单而快速的方法。我们需要的只是让程序B去调用程序A(可能在另一个机器上)的方法。 我们不用了解关于这个的任何技术，但是我们只是需要这么个简单的东西，我们可以使用一个叫做 XML-RPC 的协议(对应的Python库实现 SimpleXMLRPCServer )来处理这种事。 这里是一个简单粗糙的文件阅读服务器:: 123456789101112from SimpleXMLRPCServer import SimpleXMLRPCServerdef file_reader(file_name): with open(file_name, &#x27;r&#x27;) as f: return f.read()server = SimpleXMLRPCServer((&#x27;localhost&#x27;, 8000))server.register_introspection_functions()server.register_function(file_reader)server.serve_forever() 响应它的客户端:: 123import xmlrpclibproxy = xmlrpclib.ServerProxy(&#x27;http://localhost:8000/&#x27;)proxy.file_reader(&#x27;/tmp/secret.txt&#x27;) 现在我们就有了一个远程的文件阅读器，除了一点代码，没有外部依赖。(当然，不安全，所以只在”家”用这个吧) 5. Python的开源社区 刚我一直在说Python的标准库了，这些库只要你安装Python就会包含在你的Python中。对于大多数的其他任务，这里有大量的社区维护的第三方库来满足我们的需求。 这是一个我挑选Python库的办法: 包含一个明确的协议，以便我们使用 积极活跃的开发和维护 可以用 pip 来安装，可以轻易地重复部署 拥有一个合适覆盖率的测试集 如果你发现了一个适合你需求的Python库，不要害羞，大多数开源项目欢迎我们贡献代码和协助，即使你不是一个Python老将。帮助之手随时受欢迎！ 6.追加的技巧 快速在一个目录建立HTTP服务器 :: python -m SimpleHTTPServer 在 Python 3 中:: python -m http.server 命令行上漂亮地打印JSON:: echo &#39;&#123;&quot;json&quot;:&quot;obj&quot;&#125;&#39; | python -mjson.tool 而且，如果你安装了 Pygments 模块，可以高亮地打印JSON:: echo &#39;&#123;&quot;json&quot;:&quot;obj&quot;&#125;&#39; | python -mjson.tool | pygmentize -l json 注意 &#123;&#125; 是一个空的字典，而不是空的集合","tags":["Python"],"categories":["Python"]},{"title":"Hexo Stellar主题标签使用入门","path":"/2024/03/26/Hexo-Stellar主题标签入门/","content":"更全面的使用方法请参考stellar官方文档 ，这里只介绍一些常用的标签。 emoji 表情标签语法格式: 1&#123;% emoji [source] name [height:1.75em] %&#125; 其中 source 可省略，默认source为emoji配置列表的第一个。比如：配置如下时，默认source就是tieba对应的链接 _config.yml123456789tag_plugins: ... emoji: tieba: https://gcore.jsdelivr.net/gh/cdn-x/emoji/tieba/&#123;name&#125;.png default: https://gcore.jsdelivr.net/gh/cdn-x/emoji/qq/&#123;name&#125;.gif twemoji: https://gcore.jsdelivr.net/gh/twitter/twemoji/assets/svg/&#123;name&#125;.svg qq: https://gcore.jsdelivr.net/gh/cdn-x/emoji/qq/&#123;name&#125;.gif aru: https://gcore.jsdelivr.net/gh/cdn-x/emoji/aru-l/&#123;name&#125;.gif blobcat: https://gcore.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs/&#123;name&#125;.png 代码示例： 123&#123;% emoji qq 爱你 %&#125; &#123;% emoji blobcat ablobcatattentionreverse %&#125; # 指定source为blobcat&#123;% emoji 滑稽 %&#125; # 使用默认source, 即 emoji.tieba 显示效果: 我觉得贴吧的静态表情更加好一些，不容易分散读者的注意力，所以把它调整到第一个，作为默认source。 这里还有个比较关键的问题，我们怎么知道每个source下面有哪些表情可用呢？或者说source链接中可用的 name 变量有哪些? 很简单，只要把source链接地址删除文件名部分后如: https://gcore.jsdelivr.net/gh/cdn-x/emoji/tieba/，在浏览器中打开，就能看到所有可用表情了。 对于文字为主的内容来说，下面这些表情应该够用了。 tieba常用表情12345678910&#123;% emoji 泪 %&#125;&#123;% emoji 乖 %&#125;&#123;% emoji 汗 %&#125;&#123;% emoji 酷 %&#125;&#123;% emoji 真棒 %&#125;&#123;% emoji 滑稽 %&#125;&#123;% emoji 惊讶 %&#125;&#123;% emoji 鄙视 %&#125;&#123;% emoji 你懂的 %&#125;&#123;% emoji 不高兴 %&#125; 上面谈及emoji的配置，这里特别说明一下hexo主题配置的优先级，有3处可进行主题的配置，优先级高的排前面， 具体如下： 主题配置的优先级123- 项目根目录/_config.yml theme_config- 项目根目录/_config.stellar.yml- 项目根目录/themes/stellar/_config.yml icon 图标标签语法格式: 1&#123;% icon name|link [color:colorVal] %&#125; 配置默认颜色: _config.yml1234tag_plugins: icon: # 留空时，图标和文字颜色相同 default_color: accent # theme, accent, red, orange, yellow, green, cyan, blue, purple 可用的颜色名称theme, accent, red, orange, yellow, green, cyan, blue, purple 代码示例: 123icons.yml 中的图标：&#123;% icon solar:planet-bold-duotone %&#125;外链图标：&#123;% icon https://api.iconify.design/solar:link-circle-bold.svg %&#125;指定颜色：&#123;% icon ph:seal-question-fill color:red %&#125; 显示效果: themes/stellar/_data/icons.yml 中的图标：themes/stellar/_data/icons.yml 中的图标，指定颜色：外链图标： 注意： 图标的source配置是在 themes/stellar/_data/icons.yml 文件中，想知道更多的图标名称，可到该文件查看。 更多图标12&#123;% icon github:tag color:red %&#125;&#123;% icon share:link color:orange %&#125; 图标在独立页面上或许有用，普通的文章不需要什么图标 mark 标记标签这个标签可以用来标记文章中的重点内容 *类似马克笔效果*，非常实用 语法格式: 1&#123;% mark content [color:colorVal] %&#125; 代码示例: 1234567891011121314支持多彩标记，包括：&#123;% mark 默认 %&#125;&#123;% mark 红 color:red %&#125;&#123;% mark 橙 color:orange %&#125;&#123;% mark 黄 color:yellow %&#125;&#123;% mark 绿 color:green %&#125;&#123;% mark 青 color:cyan %&#125;&#123;% mark 蓝 color:blue %&#125;&#123;% mark 紫 color:purple %&#125;&#123;% mark 亮 color:light %&#125;&#123;% mark 暗 color:dark %&#125;&#123;% mark 警告 color:warning %&#125;&#123;% mark 错误 color:error %&#125;一共 12 种颜色。 显示效果: 支持多彩标记，包括：默认 红 橙 黄 绿 青 蓝 紫 亮 暗 警告 错误 一共 12 种颜色。 hashtag 标签用来显示一个超链接，比markdown的链接会好看一些。 语法: 1&#123;% hashtag content link [color:colorVal] %&#125; 代码示例: 1234&#123;% hashtag Stellar https://xaoxuu.com/wiki/stellar/ %&#125;&#123;% hashtag Hexo https://hexo.io/ %&#125;&#123;% hashtag GitHub https://github.com/xaoxuu/ %&#125;&#123;% hashtag Gitea https://git.xaox.cc/ color:green %&#125; 显示效果: Stellar Hexo GitHub Gitea 如果没有指定颜色，且没有设置默认颜色，则随机取一个颜色 image 图标标签图片标签是一个精心设计的应对各种尺寸插图的标签，对于大图，可以放置一个「下载」按钮，语法格式如下： 1&#123;% image src [description] [download:bool/string] [width:px] [padding:px] [bg:hex] %&#125; 参数说明123456src: 图片地址description: 图片描述download: href # 下载地址，设置此值后鼠标放在图片上会显示下载地址，如果下载地址为图片地址，可以设置为 truewidth: 200px # 图片宽度padding: 16px # 图片四周填充宽度bg: &#x27;#ffffff&#x27; # 图片区域背景颜色，16进制 代码示例: 花括号内的代码换行书写也是可以的 123456&#123;% image https://s.xaox.cc/xaoxuu/posts/202401131914137.jpg-hd 图片由 xaoxuu 拍摄于一个阳光明媚的下午 download:https://s.xaox.cc/xaoxuu/posts/202401131914137.jpg-hd %&#125; 显示效果: 图片由 xaoxuu 拍摄于一个阳光明媚的下午 支持 Fancybox 插件点击放大在任意 image 标签中增加 fancybox:true 参数即可为特定图片开启缩放功能。 代码示例: 12345&#123;% image https://www.apple.com.cn/newsroom/images/product/iphone/lifestyle/2022/Apple_Shot-on-iphone-macro-challenge_Cat_big.jpg.large_2x.jpg 这是一只好奇的猫 fancybox:true%&#125; 显示效果: 这是一只好奇的猫 如果您希望全站所有的 image 标签都开启此功能，可在主题配置文件中修改以下参数： _config.stellar.yml123456######## Tag Plugins ########tag_plugins: # &#123;% image %&#125; image: fancybox: true 建议全局统一开启图片缩放功能。 quot 引用标签语法格式: 123&#123;% quot title [icon:iconVal] [prefix:icon] [suffix:icon] [el:h2|h3|h4|h5|h6] %&#125;#iconVal: default , hashtag 代码示例: 1234567891011121314151617181920适合居中且醒目的引用：&#123;% quot Stellar 是迄今为止最好用的主题 %&#125;支持自定义引号：&#123;% quot 热门话题 icon:hashtag %&#125;&#123;% quot 特别引用 icon:default %&#125;&#123;% quot 这是一个 icons.yml 配置的示例 prefix:solar:planet-bold-duotone %&#125;&#123;% quot 这是一个 url 的示例 prefix:https://api.iconify.design/line-md:moon-alt-to-sunny-outline-loop-transition.svg suffix:https://api.iconify.design/solar:list-heart-minimalistic-line-duotone.svg%&#125;&#123;% quot 添加el:h3参数作为标题使用 el:h3 %&#125; 显示效果: 默认的引用标题： Stellar 是迄今为止最好用的主题 支持自定义引号： 热门话题 特别引用 这是一个 icons.yml 配置的示例 这是一个 url 的示例 添加el:h3参数作为标题使用 此外，quot标签加上参数 el:h2/h3/h4/h5/h6 可以作为标题使用，这个比较实用。 note 备注标签语法格式: 1&#123;% note [title] content [color:color] %&#125; 代码示例: 123456&#123;% note 支持12种颜色 color 可设置 red、orange、amber、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 color:warning%&#125; 支持12种颜色color 可设置 red、orange、amber、yellow、 green、cyan、blue、purple、light、dark、warning、error 几种取值。 对文章的理解和点评可以用备注块 link 链接卡片标签语法格式: 1&#123;% link href [title] [icon:src] [desc:true/false] %&#125; 参数说明12345href: 链接title: 可选，手动设置标题（为空时会自动抓取页面标题）icon: 可选，手动设置图标（为空时会自动抓取页面图标）desc: 可选，是否显示摘要描述，为true时将会显示页面描述 代码示例: 12345不带摘要的样式：&#123;% link https://xaoxuu.com/blog/20221029/ %&#125;带摘要的样式：&#123;% link https://xaoxuu.com/blog/20221029/ desc:true %&#125; 显示效果: 不带摘要的样式： https://xaoxuu.com/blog/20221029/https://xaoxuu.com/blog/20221029/ 带摘要的样式： https://xaoxuu.com/blog/20221029/https://xaoxuu.com/blog/20221029/ 相关配置: _config.stellar.yml1234567######## Tag Plugins ########services: # &#123;% link %&#125; siteinfo: # 设置 api 可以自动提取网页标题、图标，服务部署方法：https://github.com/xaoxuu/site-info-api/ # 接口测试通过后，把按钮的 href 部分替换成 &#123;href&#125; 之后填写到下方，例如：https://api.vlts.cc/site_info/v1?url=&#123;href&#125; api: ... 一般用hashtag标签引入外部链接即可，如果要突出某个链接，可以考虑使用link标签。 button 按钮标签语法格式: 1&#123;% button text url [icon:key/src] [color:color] [size:xs] %&#125; 参数说明12345678 # 必填text: 探索 # 显示文字url: # 跳转链接# 可选参数color: orange # theme, accent, red, orange, yellow, green, cyan, blue, purpleicon: solar:planet-bold-duotone # 显示图标，支持 icon.yml 中的文件名和外链图标size: xs # 按钮尺寸，目前只有两种尺寸：默认是普通大小， xs 是最小号 代码示例: 12&#123;% button 探索 https://github.com/xaoxuu/hexo-theme-stellar/ icon:solar:planet-bold-duotone %&#125; 显示效果: 探索 button 和 hashtag , link 标签一样，都可以引入外部链接。 copy 复制行标签语法格式: 1&#123;% copy content [prefix:str] %&#125; 代码示例: 1234567&#123;% copy curl -s https://sh.xaox.cc/install | sh %&#125;&#123;% copy curl -s https://sh.xaox.cc/install | sh prefix:$ %&#125;# github 链接, 根据git参数相应转换&#123;% copy git:https xaoxuu.com/hexo-theme-stellar %&#125;&#123;% copy git:ssh xaoxuu.com/hexo-theme-stellar %&#125;&#123;% copy git:gh xaoxuu.com/hexo-theme-stellar %&#125; $ github 链接, 根据git参数相应转换 radio 单选框标签语法格式: 1&#123;% radio title [check:bool] [color:colorVal]&#125; 参数说明12checked: true/falsecolor: red/orange/yellow/green/cyan/blue/purple 代码示例: 123&#123;% radio 没有勾选的单选框 %&#125;&#123;% radio checked:true 已勾选的单选框 %&#125;&#123;% radio checked:true 已勾选的单选框 color:yellow %&#125; 显示效果: 没有勾选的单选框 已勾选的单选框 已勾选的单选框 checkbox 多选框标签语法格式: 1&#123;% checkbox title [check:bool] [color:colorVal] [symbol:plus/minus/times] %&#125; 参数说明1234checked: true/falsecolor: red/orange/yellow/green/cyan/blue/purplesymbol: plus/minus/times 代码示例: 123456&#123;% checkbox 普通的没有勾选的复选框 %&#125;&#123;% checkbox checked:true 普通的已勾选的复选框 %&#125;&#123;% checkbox symbol:plus color:green checked:true 显示为加号的绿色的已勾选的复选框 %&#125;&#123;% checkbox symbol:minus color:yellow checked:true 显示为减号的黄色的已勾选的复选框 %&#125;&#123;% checkbox symbol:times color:red checked:true 显示为乘号的红色的已勾选的复选框 %&#125; 显示效果: 普通的没有勾选的复选框 普通的已勾选的复选框 显示为加号的绿色的已勾选的复选框 显示为减号的黄色的已勾选的复选框 显示为乘号的红色的已勾选的复选框 radio 和 checkbox 一般都不需要用到 audio 音频标签 可以嵌入网易音乐，这个很惊艳~ 语法格式: 1&#123;% audio src [type:2/0] [netease:id] [autoplay:1/0] %&#125; 参数说明1234type: 2/0 # 歌曲/歌单 # 不设置默认为2歌曲模式netease: xxx # 歌曲/歌单 id ，具体 id 在网易云网页版的网址链接中寻找 autoplay: 1/0 # 自动播放/手动播放 # 不设置默认0手动播放 代码示例: 123456&#123;% audio https://github.com/volantis-x/volantis-docs/releases/download/assets/Lumia1020.mp3 %&#125;&#123;% audio netease:1856385686 %&#125;&#123;% audio netease:1856385686 type:2 autoplay:0 %&#125; 显示效果: Your browser does not support the audio tag. video 视频标签 竟然可以插入B站视频，大赞！ 代码示例: 1234567891011&#123;% video bilibili:BV1GP4y1d729 %&#125;&#123;% video bilibili:BV1GP4y1d729 width:100% autoplay:0 %&#125;&#123;% grid c:2 %&#125;&lt;!-- cell --&gt;&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov %&#125;&lt;!-- cell --&gt;&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov width:100% %&#125;&#123;% endgrid %&#125; 参数说明12width: 500px # 须带单位 80% 20em 100mm...autoplay: 1/0 # 自动播放/手动播放 # 不设置默认为0手动播放 显示效果: Your browser does not support the video tag. Your browser does not support the video tag. 文本修饰标签集示例代码： 12345678- 这是 &#123;% psw 密码 %&#125; 标签- 这是 &#123;% u 下划线 %&#125; 标签- 这是 &#123;% emp 着重号 %&#125; 标签- 这是 &#123;% wavy 波浪线 %&#125; 标签- 这是 &#123;% del 删除线 %&#125; 标签- 这是 &#123;% sup 上角标 color:red %&#125; 标签- 这是 &#123;% sub 下角标 %&#125; 标签- 这是 &#123;% kbd 键盘样式 %&#125; 标签，试一试：&#123;% kbd ⌘ %&#125; + &#123;% kbd D %&#125; 显示效果: 这是 密码 标签 这是 下划线 标签 这是 着重号 标签 这是 波浪线 标签 这是 删除线 标签 这是 上角标 标签 这是 下角标 标签 这是 键盘样式 标签，试一试：⌘ + D 突出文章部分内容，可以使用 wavy 和 u 标签，但是我觉得 mark 标签突出和标记效果更好。 显示快捷按钮之类的，用 kbd 标签会更加形象，其他的修饰标签感觉用户不大。 folding 折叠容器标签语法格式: 123&#123;% folding title [codeblock:bool] [open:bool] [color:color] %&#125; content&#123;% endfolding %&#125; 参数说明123codeblock: true/falseopen: true/falsecolor: red/orange/yellow/green/cyan/blue/purple/light/dark 代码示例: 12345&#123;% folding 默认折叠的代码框 open:false color:green %&#125;func test() &#123; print(&quot;hello world&quot;)&#125;&#123;% endfolding %&#125; 显示效果: 默认折叠的代码框func test() { print(“hello world”)} box 盒子容器标签note 标签就是使用 box 容器实现的，它们样式是相同的： 语法格式: 1234&#123;% box [title] [color:color] [child:codeblock/tabs] %&#125;...&#123;% endbox %&#125; 代码示例: 123456789101112131415161718192021&#123;% grid %&#125;&lt;!-- cell --&gt;**推荐的写法**&#123;% box child:codeblock color:green %&#125;&#x27;&#x27;&#x27;swiftfunc test() &#123; // ...&#125;&#x27;&#x27;&#x27;&#123;% endbox %&#125;&lt;!-- cell --&gt;**不推荐的写法**&#123;% box child:codeblock color:red %&#125;&#x27;&#x27;&#x27;swiftfunc test() -&gt; () &#123; // ...&#125;&#x27;&#x27;&#x27;&#123;% endbox %&#125;&#123;% endgrid %&#125; 显示效果： 推荐的写法123func test() &#123; // ...&#125; 不推荐的写法123func test() -&gt; () &#123; // ...&#125; box 是容器，相对 note 标签来说，它更灵活，可以放置任何内容。 总结 stellar 主题的标签确实非常丰富，还有很多高级的标签，没有再这里列举，可以看出作者的审美能力和开发主题投入的大量精力；写作博客其实是相对简单的需求，没想到作者能从中提取出这么多实用的功能，从各方面来说都很值得学习。 之所以花时间去过一遍标签的用法，因为这能大大增强文章的层次结构和阅读体验。 题外话hexo主题琳琅满目，对移动端非常友好是我喜欢stellar主题的主要原因","tags":["Hexo","stellar"],"categories":["Hexo"]},{"title":"如何解决TS2322报错","path":"/2024/03/13/如何解决TS2322报错/","content":"原文地址如何解决 TS2322: “could be instantiated with a different subtype of constraint” - 掘金 如何解决 TS2322 报错: “could be instantiated with a different subtype of constraint” 遇到问题最近使用 ts 写个工具类函数时, 遇到了 ts 报错: 123456789101112function renameKeys&lt;T extends &#123; [key: string]: unknown &#125;&gt;( keysMap: &#123; [key: string]: string &#125;, obj: T): T &#123; return Object.keys(obj).reduce( (acc, key) =&gt; (&#123; ...acc, ...&#123; [keysMap[key] || key]: obj[key] &#125;, &#125;), &#123;&#125; );&#125; 问题出在函数返回的泛型 T. 随后我将泛型 T 改为 &#123; [key: string]: unknown &#125; , 报错消失了. 123456789101112function renameKeys&lt;T extends &#123; [key: string]: unknown &#125;&gt;( keysMap: &#123; [key: string]: string &#125;, obj: T): &#123; [key: string]: unknown &#125; &#123; return Object.keys(obj).reduce( (acc, key) =&gt; (&#123; ...acc, ...&#123; [keysMap[key] || key]: obj[key] &#125;, &#125;), &#123;&#125; );&#125; 这就很奇怪, &#123; [key: string]: unknown &#125; 本身就为 T 的约束, 用 &#123; [key: string]: unknown &#125; 和用 T 有什么区别吗? 在我一顿 Google 之后, 在一篇文章中明白了其中道理. 理解 TS 报错信息下面我将分解错误消息的每句话: 12Type &#x27;&#123;&#125;&#x27; is not assignable to type &#x27;T&#x27;. &#x27;&#123;&#125;&#x27; is assignable to the constraint of type &#x27;T&#x27;, but &#x27;T&#x27; could be instantiated with a different subtype of constraint &#x27;&#123; [key: string]: unknown; &#125;&#x27; Type &#39;&#123;&#125;&#39; 什么意思?这个类型可以分配任何值，除了 null 或 undefined。例如: 1234567type A = &#123;&#125;;const a0: A = undefined; // errorconst a1: A = null; // errorconst a2: A = 2; // okconst a3: A = &quot;hello world&quot;; //okconst a4: A = &#123; foo: &quot;bar&quot; &#125;; //ok// and so on... is not assignable 什么意思?分配是实例与类型相匹配。如果你的实例不匹配类型，你会得到一个错误。例如: 12345// type string is not assignable to type numberconst a: number = &quot;hello world&quot;; //error// type number is assinable to type numberconst b: number = 2; // ok a different subtype 什么意思? A 是 S 的子类型: 类型 A 在类型 S 的基础上增加了额外属性. A 和 B 是 S 的不同子类型: 类型 A 与类型 B 分别在类型 S 的基础上增加了不同的额外属性. 例如: 下面代码的情况是 A 和 D 是相同的类型 B 是 A 的子类型 E 不是 A 的子类型 B 和 C 是 A 的不同子类型 12345type A = &#123; readonly 0: &quot;0&quot; &#125;;type B = &#123; readonly 0: &quot;0&quot;; readonly foo: &quot;foo&quot; &#125;;type C = &#123; readonly 0: &quot;0&quot;; readonly bar: &quot;bar&quot; &#125;;type D = &#123; readonly 0: &quot;0&quot; &#125;;type E = &#123; readonly 1: &quot;1&quot;; readonly bar: &quot;bar&quot; &#125;; 12345type A = number;type B = 2;type C = 7;type D = number;type E = `hello world`; 12345type A = boolean;type B = true;type C = false;type D = boolean;type E = number; 当你在 ts 中使用 type 关键字时, 例如: type A = &#123; foo: &#39;Bar&#39; &#125;, 那么 A 指向的是该值的结构. constraint of type &#39;T&#39; 什么意思?类型约束仅仅是你放在 extends 关键字右侧的内容。在下面的例子中，类型约束是’B’。 1const func = &lt;A extends B&gt;(a: A) =&gt; `hello!`; 所以, Type ‘B’ is the constraint of type ‘A’. 类型约束 extends为了说明这一点，我将展示三种情况。在每种情况下唯一会变化的是类型约束，其他什么都不会改变。 我想让你注意的是，类型约束不会限制其子类型。看以下示例: Given: 123456type Foo = &#123; readonly 0: &quot;0&quot; &#125;;type SubType = &#123; readonly 0: &quot;0&quot;; readonly a: &quot;a&quot; &#125;;type DiffSubType = &#123; readonly 0: &quot;0&quot;; readonly b: &quot;b&quot; &#125;;const foo: Foo = &#123; 0: &quot;0&quot; &#125;;const foo_SubType: SubType = &#123; 0: &quot;0&quot;, a: &quot;a&quot; &#125;;const foo_DiffSubType: DiffSubType = &#123; 0: &quot;0&quot;, b: &quot;b&quot; &#125;; CASE 1: 无类型约束 123456789101112const func = &lt;A&gt;(a: A) =&gt; `hello!`;// call examplesconst c0 = func(undefined); // okconst c1 = func(null); // okconst c2 = func(() =&gt; undefined); // okconst c3 = func(10); // okconst c4 = func(`hi`); // okconst c5 = func(&#123;&#125;); //okconst c6 = func(foo); // okconst c7 = func(foo_SubType); //okconst c8 = func(foo_DiffSubType); //ok CASE 2: 一般的类型约束 在 Typescript 中，类型约束不会限制其子类型. 123456789101112const func = &lt;A extends Foo&gt;(a: A) =&gt; `hello!`;// call examplesconst c0 = func(undefined); // errorconst c1 = func(null); // errorconst c2 = func(() =&gt; undefined); // errorconst c3 = func(10); // errorconst c4 = func(`hi`); // errorconst c5 = func(&#123;&#125;); // errorconst c6 = func(foo); // okconst c7 = func(foo_SubType); // ok &lt;-- Allowedconst c8 = func(foo_DiffSubType); // ok &lt;-- Allowed CASE 3: 更具体的约束 123456789101112const func = &lt;A extends SubType&gt;(a: A) =&gt; `hello!`;// call examplesconst c0 = func(undefined); // errorconst c1 = func(null); // errorconst c2 = func(() =&gt; undefined); // errorconst c3 = func(10); // errorconst c4 = func(`hi`); // errorconst c5 = func(&#123;&#125;); // errorconst c6 = func(foo); // error &lt;-- Restricted nowconst c7 = func(foo_SubType); // ok &lt;-- Still allowedconst c8 = func(foo_DiffSubType); // error &lt;-- NO MORE ALLOWED ! 总结示例以下函数: 1const func = &lt;A extends Foo&gt;(a: A = foo_SubType) =&gt; `hello!`; //error! 产生如下错误信息: 12Type &#x27;SubType&#x27; is not assignable to type &#x27;A&#x27;. &#x27;SubType&#x27; is assignable to the constraint of type &#x27;A&#x27;, but &#x27;A&#x27; could be instantiated with a different subtype of constraint &#x27;Foo&#x27;.ts(2322) 因为 Typescript 是从函数调用中推断出 A，并且在语言中并没有限制你用不同的 ‘Foo’ 子类型来调用函数。例如，下面的所有函数调用都被认为是有效的: 123const c0 = func(foo); // ok! type &#x27;Foo&#x27; will be infered and assigned to &#x27;A&#x27;const c1 = func(foo_SubType); // ok! type &#x27;SubType&#x27; will be inferedconst c2 = func(foo_DiffSubType); // ok! type &#x27;DiffSubType&#x27; will be infered 因此，将具体类型赋值给泛型类型形参是不正确的，因为在 TS 中，类型形参总是可以实例化为任意不同的子类型。 结论: 永远不要将具体类型赋给泛型类型参数，将其视为只读类型! 相反, 这样做: 1const func = &lt;A extends Foo&gt;(a: A) =&gt; `hello!`; //ok! 结论 泛型是函数运行时推断出的类型; 不要给泛型类型的形参设置默认值; 若非设置默认值不可, 只能断言泛型 😞 参考 How to fix TS2322: “could be instantiated with a different subtype of constraint ‘object’”? Issue a custom error message when trying to assign constraint type to generic type parameter","tags":["Typescript"],"categories":["Typescript"]},{"title":"十分钟学会WebSocket","path":"/2024/03/12/十分钟学会WebSocket/","content":"原文地址十分钟学会 WebSocket - 掘金 WebSocket 简介WebSocket 是一种在客户端和服务器之间实现双向通信的网络协议。它通过在单个 TCP 连接上提供全双工通信功能，使得服务器可以主动向客户端推送数据，而不需要客户端发起请求。 WebSocket 与 HTTP 的区别与传统的 HTTP 协议相比，WebSocket 具有以下几个显著的区别： 双向通信：WebSocket 支持客户端和服务器之间的实时双向通信，而 HTTP 协议是单向请求-响应模式。 低延迟：由于 WebSocket 使用长连接，避免了 HTTP 的连接建立和断开过程，可以降低通信延迟。 更少的数据传输：WebSocket 头部信息相对较小，减少了数据传输的开销。 跨域支持：WebSocket 可以轻松跨域，而 HTTP 需要通过 CORS 等机制来实现。 WebSocket 的工作原理WebSocket 的握手过程和 HTTP 有所不同。客户端通过发送特定的 HTTP 请求进行握手，服务器收到请求后进行验证，如果验证通过，则会建立 WebSocket 连接。 建立连接后，客户端和服务器之间可以通过 WebSocket 发送和接收消息，可以使用文本、二进制数据等进行通信。 WebSocket 的应用场景WebSocket 的实时双向通信特性使得它在许多应用场景中发挥重要作用，例如： 即时聊天：WebSocket 可以实现实时的聊天功能，用户可以发送和接收消息，实现快速、低延迟的聊天体验。 实时数据更新：对于需要实时更新数据的应用，如股票行情、实时监控等，WebSocket 可以将数据实时推送给客户端，确保数据的及时更新。 在线游戏：在线游戏需要实时的双向通信，WebSocket 可以提供稳定的通信通道，支持实时交互和多人游戏。 WebSocket 的使用以下是使用 JavaScript 与 WebSocket 建立连接的示例代码： 1var Socket = new WebSocket(&quot;url, [protocol]&quot;); 以上代码中的第一个参数url, 指定连接的 URL。第二个参数protocol是可选的，指定了可接受的子协议。 WebSocket 属性以下是 WebSocket 对象的属性。 属性 描述 Socket.readyState 只读属性 readyState 表示连接状态， 可以是以下值： 0-表示连接尚未建立。 1-表示连接已建立，可以进行通信。 2-表示连接正在进行关闭。 3-表示连接已经关闭或者连接不能打开。 Socket.bufferedAmount 只读属性 bufferedAmount 已被 send()放入正在队列中等待传输，但是还没有发出的 UTF-8 文本字节数。 0-表示连接尚未建立。 1-表示连接已建立，可以进行通信。 2-表示连接正在进行关闭。 3-表示连接已经关闭或者连接不能打开。 WebSocket 事件以下是 WebSocket 对象的相关事件。 事件 事件处理程序 描述 open Socket.onopen 连接建立时触发 message Socket.onmessage 客户端接收服务端数据时触发 error Socket.onerror 通信发生错误时触发 close Socket.onclose 连接关闭时触发 下面是相关示例代码： 1234567891011121314151617181920Socket.onopen = function () &#123; //连接建立时触发 console.log(&quot;WebSocket连接已建立&quot;);&#125;;Socket.onmessage = function (event) &#123; //客户端接收服务端数据时触发 var message = event.data; console.log(&quot;收到消息：&quot; + message);&#125;;Socket.onerror = function () &#123; //通信发生错误时触发 console.log(&quot;WebSocket连接发生了错误&quot;);&#125;;Socket.onclose = function () &#123; //连接关闭时触发 console.log(&quot;WebSocket连接已关闭&quot;);&#125;; WebSocket 方法以下是 WebSocket 对象的相关方法。 方法 描述 Socket.send() 使用连接发送数据 Socket.close() 关闭连接 1234//发送一条消息Socket.send(&quot;你好&quot;);//关闭WebSocket连接Socket.close(); WebSocket 除了发送和接收文本消息外，还支持发送和接收二进制数据。对于发送二进制数据，可以使用 send() 方法传递一个 ArrayBuffer 或 Blob 对象，例如： 1234const buffer = new ArrayBuffer(4);const view = new DataView(buffer);view.setUint32(0, 1234);socket.send(buffer); 在接收二进制数据时，可以通过 event.data 获取到 ArrayBuffer 对象，然后进行处理。 WebSocket 的心跳机制WebSocket 的心跳机制是一种用于保持 WebSocket 连接的稳定性和活跃性的方法。心跳机制的目的是定期发送小的探测消息，以确保连接仍然有效，如果连接断开或出现问题，可以及时发现并采取措施。 下面是 WebSocket 心跳机制的详细步骤和相关代码示例： 定义心跳间隔：为了定期发送心跳消息，你需要定义一个心跳间隔，通常以毫秒为单位。在示例中，我们将心跳间隔设置为 30 秒。 1const heartbeatInterval = 30000; // 30秒 定义心跳消息：你需要定义用于发送心跳的消息内容。这通常是一个简单的字符串，如”heartbeat”，但可以根据应用的需求自定义。 1const heartbeatMessage = &quot;heartbeat&quot;; 设置心跳定时器：一旦 WebSocket 连接打开，你可以使用setInterval函数设置一个定时器，以便每隔一段时间发送心跳消息。 123456789let heartbeat;socket.addEventListener(&quot;open&quot;, () =&gt; &#123; console.log(&quot;WebSocket连接已打开&quot;); heartbeat = setInterval(() =&gt; &#123; socket.send(heartbeatMessage); &#125;, heartbeatInterval);&#125;); 处理心跳消息：当你接收到来自服务器的消息时，你需要检查它是否是心跳消息。这可以通过比较接收到的消息内容和心跳消息的内容来实现。 1234567891011socket.addEventListener(&quot;message&quot;, (event) =&gt; &#123; const message = event.data; if (message === heartbeatMessage) &#123; console.log(&quot;接收到心跳消息&quot;); // 在这里可以执行一些处理心跳消息的操作 &#125; else &#123; console.log(&quot;接收到其他消息：&quot;, message); // 处理其他类型的消息 &#125;&#125;); 清除心跳定时器：当 WebSocket 连接关闭时，你应该清除之前设置的心跳定时器，以防止继续发送心跳消息。 12345socket.addEventListener(&quot;close&quot;, () =&gt; &#123; console.log(&quot;WebSocket连接已关闭&quot;); clearInterval(heartbeat);&#125;); 通过这些步骤，你可以实现 WebSocket 的心跳机制，确保连接的持续稳定，以适应长时间的通信需求。如果连接断开或出现问题，你可以根据需要添加进一步的错误处理机制。 WebSocket 的安全性和跨域问题WebSocket 支持通过 wss:// 前缀建立加密的安全连接，使用 TLS&#x2F;SSL 加密通信，确保数据的安全性。在使用加密连接时，服务器需要配置相应的证书。 对于跨域问题，WebSocket 遵循同源策略，只能与同源的服务器建立连接。如果需要与不同域的服务器通信，可以使用 CORS（跨域资源共享）来进行跨域访问控制。 好用的 WebSocket 第三方库 Socket.io： Socket.io是一个流行的实时通信库，它提供了客户端 JavaScript 库，可用于在浏览器中与 Socket.io服务器建立 WebSocket 连接。它支持自动重连、事件处理等功能，用于构建实时应用非常方便。 ReconnectingWebSocket：ReconnectingWebSocket 是一个带有自动重连功能的 WebSocket 客户端库，可以很好地处理网络连接断开和重新连接的情况，适合用于浏览器端的 WebSocket 开发。 SockJS：SockJS 提供了一个浏览器端的 JavaScript 客户端库，用于与 SockJS 服务器建立连接。它可以在不支持 WebSocket 的浏览器上自动降级到其他传输方式，具有良好的兼容性。 RxJS WebSocketSubject：RxJS 是一个流式编程库，它提供了 WebSocketSubject 类，可以将 WebSocket 转换为可观察对象，方便进行响应式编程。 autobahn.js：autobahn.js 是一个用于实现 WebSocket 和 WAMP（Web Application Messaging Protocol）的客户端库，在浏览器中可以方便地使用它来与 WAMP 路由进行通信。 这些库都提供了良好的接口封装和功能特性，可以根据项目需求选择适合的库来进行浏览器端的 WebSocket 开发。 总结WebSocket 协议是一种基于 TCP 的应用层协议，它提供了在客户端和服务器之间进行双向通信的能力。相比传统的 `HTTP` 协议，它具有更低的延迟和更高的实时性。 WebSocket 协议通过建立一条持久化的连接来实现双向通信，从而避免了 `HTTP` 协议中频繁建立和断开连接的过程，减少了网络开销和服务器的负担。客户端可以发送消息给服务器，服务器也可以发送消息给客户端，实现了真正的双向通信。 在使用 WebSocket 协议时，客户端和服务器会进行一次握手过程，以建立起 WebSocket 连接。握手过程中，客户端会发送一个 HTTP 请求，请求头中包含 Upgrade 和 Connection 字段，告诉服务器它希望升级到 WebSocket 连接。服务器收到请求后会返回一个 HTTP 响应，响应头中包含 Upgrade 和 Connection 字段，以及一个 Sec-WebSocket-Accept 字段，用于验证请求的合法性。握手成功后，客户端和服务器就可以开始使用 WebSocket 协议进行通信了。 WebSocket 协议支持二进制数据和文本数据的传输，开发者可以根据实际需求进行选择。同时，WebSocket 还提供了心跳机制、自动重连等功能，可以提高连接的稳定性和可靠性。 总之，WebSocket 协议在实时通信、游戏、在线聊天等场景中得到了广泛应用，它为 Web 应用提供了更加高效、可靠的双向通信方式。","tags":["Websocket"],"categories":["Websocket"]},{"title":"Nextjs项目最佳实践","path":"/2024/03/12/Nextjs项目最佳实践/","content":"原文地址Next.js 项目最佳实践 - 掘金 什么是 Next.js “ Next.js 通过提供所有生产环境需要的功能来给你最佳的开发体验：构建时预渲染，服务端渲染，TypeScript 支持，智能打包，路由预加载，零配置等等 ” 正如上文的介绍，Next.js 是一个非常全面的现代全栈应用构建方案。它包含了非常优雅的 TypeScript 和 React 支持，同时提供了现代应用常见的需求解决方案，例如：路由，API，PostCSS 工具和代码分割等。 与此同时它也支持静态站点生成（用于可以在任何地方托管的高性能静态 HTML 页面）或者是通过 Vercel &#x2F; AWS 等部署 Node.js 服务来进行数据按需加载的服务端渲染页面 Next.js 已迅速成为 Web 开发领域最抢手的技能之一。本教程旨在充当 Next.js 文档 的 “ 实用 ” 延伸，并帮助你使用大量最佳实践来开发项目，这将有利于你在今后对项目实施进一步的扩展。 介绍本教程不是为了替代官方文档，因为官方文档已经写得非常简单易懂了。我强烈推荐你在学习本文之前先大致过一下 这一章 的内容，这样你对文中的术语和工具会比较熟悉，他们提供的一些组件与普通 HTML 组件相似，但通常是“更强大”的版本。 我承认其中许多的是严格的并且带有主观色彩的，如果其中任何一个对你没有吸引力，那么在大多数情况下可以简单地跳过这些部分并且应该仍然能够完成本教程而不会遇到太多麻烦 现在，如果你已经准备好了，那就开始学习吧 ！ 项目创建我们将使用 TypeScript 模版来创建一个默认的 Next.js 应用 1234567npx create-next-app@latest --typescript nextjs-fullstack-app-template-zncd nextjs-fullstack-app-template-zn// ESLInt : YES// `src/` directory : YES// `app/` directory : NO 首先我们试试这个项目能不能正常运行。我们在这个例子中会使用 yarn ，当然你也可以用 NPM 或其他的工具 1yarn dev 你可以打开 http://localhost:3000/ 看到这个 demo 已经成功运行 也推荐你运行 1yarn build 来确保你的项目能够成功打包。推荐（非必需）关闭开发服务器来运行 Next.js 的构建命令。大多数时候没有问题，但偶尔构建会使你的开发服务器处于需要重新启动的奇怪状态。 构建成功之后你可以在命令行看到这些绿色和白色文字的报告，构建过程是高效的，我们将在开发的过程中尽量保持这样的状态。 引擎锁定我们在本项目中使用的 v16 的 Node.js。你可以通过 node --version 检查版本。打开 package.json engines 字段是你指定所使用工具的特定版本的地方。 1234567891011121314151617181920212223242526&#123; &quot;name&quot;: &quot;nextjs-fullstack-app-template-zn&quot;, &quot;version&quot;: &quot;0.1.0&quot;, &quot;private&quot;: true, &quot;author&quot;: &quot;YOUR_NAME&quot;, &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;next dev&quot;, &quot;build&quot;: &quot;next build&quot;, &quot;start&quot;: &quot;next start&quot;, &quot;lint&quot;: &quot;next lint&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;@next/font&quot;: &quot;13.1.6&quot;, &quot;@types/node&quot;: &quot;18.11.18&quot;, &quot;@types/react&quot;: &quot;18.0.27&quot;, &quot;@types/react-dom&quot;: &quot;18.0.10&quot;, &quot;next&quot;: &quot;13.1.6&quot;, &quot;react&quot;: &quot;18.2.0&quot;, &quot;react-dom&quot;: &quot;18.2.0&quot;, &quot;typescript&quot;: &quot;4.9.4&quot; &#125;, &quot;engines&quot;: &#123; &quot;node&quot;: &quot;&gt;=16.0.0&quot;, &quot;yarn&quot;: &quot;&gt;=1.22.0&quot; &#125;&#125; Git 配置这将是我们第一次提交到远程仓库的好时机，以确保更改得到备份，并遵循最佳实践将相关更改分组在一个提交中，然后再做新的修改。 默认情况下，你的 Next.js 项目已经初始化了一个 repo。 你可以使用 git status 检查你所在的分支。 它应该会显示类似下面的文案 12345678910111213$ git statusOn branch mainChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: package.jsonUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) .npmrc .vscode/no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 这告诉我们我们在 main 分支上，我们还没有暂存或做出任何提交 让我们提交目前的变更 123git add .git commit -am &quot;feat: project init&quot; 第一个命令将在项目目录中添加并暂存所有在 .gitignore 中未被忽略的文件。 第二个将使用我们在 -m 标志之后写的消息来提交当前项目的状态 跳转到你喜欢的 git 托管服务提供商（ 比如 Github）并且创建一个新的仓库来存放你的项目。 现在你已准备好添加仓库的远程源并进行推送。 Github 会在你创建的时候给你准确的说明。 你的语法可能与我的略有不同，具体取决于使用的是 HTTPS 还是 SSH。 123git remote add origin git@github.com:&#123;YOUR_GITHUB_USERNAME&#125;/&#123;YOUR_REPOSITORY_NAME&#125;.gitgit push -u origin &#123;YOUR_BRANCH_NAME&#125; 请注意，从这一点开始，我们将使用 Conventional Commits 标准，特别是 此处描述 的 Angular 约定 原因与该项目中的许多其他功能一样，只是为所有开发人员设置一个一致的标准，以便在为项目做出贡献时最大程度地减少培训时间。我个人不太关心选择什么标准，只要每个人都同意遵循它，才是最重要的。 一致性就是一切 ！！！ 代码格式化和质量工具为了设定一个标准，供项目的所有贡献者使用，以保持代码风格一致并遵循基本的最佳实践，我们将使用两个工具： eslint - 代码规范的最佳实践 prettier - 自动格式化代码文件 ESLint我们从 ESLint 开始，它非常简单因为在我们创建 Next.js 项目的时候已经自动安装好并且有了默认配置。 我们仅需要添加少部分额外的配置就可以让它比默认配置更加严格。如果你不同意其中的任何一条规则配置，不用担心，我们可以非常简单的手动关闭这些规则。我们将所有的 ESLint 配置都写在 .eslintrc.json 文件中，这个文件已经存在于我们项目的根目录。 .eslintrc.json 123456789101112&#123; &quot;extends&quot;: [&quot;next&quot;, &quot;next/core-web-vitals&quot;, &quot;eslint:recommended&quot;], &quot;globals&quot;: &#123; &quot;React&quot;: &quot;readonly&quot; &#125;, &quot;rules&quot;: &#123; &quot;no-unused-vars&quot;: [ 1, &#123; &quot;args&quot;: &quot;after-used&quot;, &quot;argsIgnorePattern&quot;: &quot;^_&quot; &#125; ] &#125;&#125; 在上面的代码示例中，我们添加了一些额外的默认值，我们声明 React 将始终被定义，即使我们没有专门导入它，我还添加了个人自定义规则，它允许你为变量添加前缀（带下划线 _） 如果你已声明它们但未在代码中使用它们 我发现当你正在处理一项功能并想准备一些变量以备后面使用但又尚未达到实现它们的地步时，这种情况经常出现 你可以测试一下你的配置通过运行： 1yarn lint 你会得到类型的提示 12✔ No ESLint warnings or errors✨ Done in 3.48s. 如果你遇到任何错误，那么 ESLint 非常擅长清楚地解释它们是什么。如果遇到你不喜欢的规则，你可以简单的将它从 1（告警）设置成 0（忽略） 来关闭它 123&quot;rules&quot;: &#123; &quot;no-unused-vars&quot;: 0, &#125; 让我们在这时候进行一次提交，带上信息 build: configure eslint Prettierprettier 会为我们处理文件的自动格式化。让我们将它添加到项目中 它只需要在开发过程中使用，所以需要添加到 devDependency 1yarn add -D prettier 同时我也推荐你安装 Prettier VS Code 插件 ，这样你不用依赖命令行工具就可以在 VS Code 中进行文件格式化。在你的项目中安装和配置它意味着 VSCode 将使用你项目的设置，因此仍然有必要在此处添加它。 我们将在根目录添加两个文件： .prettierrc 123456&#123; &quot;trailingComma&quot;: &quot;es5&quot;, &quot;tabWidth&quot;: 2, &quot;semi&quot;: true, &quot;singleQuote&quot;: true&#125; 这些配置完全由你自行决定什么最适合你的团队和项目 .prettierignore 1234.yarn.nextdistnode_modules 在这个文件中我列了一些目录，我不希望 prettier 在这些目录中浪费任何资源去进行格式化。你也可以使用类似 *.html 这样的方式去忽略你选择的文件类似 现在我们在 package.json 添加新的 script ，然后我们就可以运行 Prettier： package.json 123456... &quot;scripts: &#123; ... &quot;prettier&quot;: &quot;prettier --write .&quot; &#125; 你可以运行 1yarn prettier 自动格式化、修复和保存项目中你未忽略的所有文件。 默认情况下，我的格式化程序更新了大约 5 个文件。 你可以在 VS Code 左侧的源代码管理选项卡中的已更改文件列表中看到它们。 让我们在这时候进行一次提交，带上信息 build: implement prettier Git Hooks在我们开始进行组件开发之前，还有一节是关于配置的。 请记住，如果你要长期构建该项目，你将希望该项目尽可能坚如磐石，尤其是与其他开发人员团队合作时。 花时间在一开始就把它做好是值得的。 我们将使用一个叫做 Husky 的工具 Husky 是一个用于在 git 进程的不同阶段运行脚本的工具，例如 add、commit、push 等。我们希望能够设置某些条件，并且只有在我们的代码满足这些条件时才允许提交和推送之类的事情成功，假设这表明我们的项目质量是可以接受的。 安装 Husky 123yarn add -D huskynpx husky install 第二个命令将在你的项目中创建一个 .husky 目录。这就是你的 hooks 存放的地方。确保此目录包含在你的代码仓库中，因为它也适用于其他开发人员，而不仅仅是你自己。 在 package.json 文件中添加 script package.json 123456... &quot;scripts: &#123; ... &quot;prepare&quot;: &quot;husky install&quot; &#125; 这将确保在其他开发人员运行该项目时自动安装 Husky 创建一个 hook 1npx husky add .husky/pre-commit &quot;yarn lint&quot; 上面说为了让我们的提交成功，yarn lint 必须首先运行并成功。 在这种情况下，” 成功 ”意味着没有错误。 它将允许你有告警（请记住，在 ESLint 配置中，设置 1 是警告，设置 2 是错误） 让我们在这时候进行一次提交，带上信息 ci: implement husky 。如果所有设置都完成，在你进行提交之前就会运行 lint script 让我们再添加一个 1npx husky add .husky/pre-push &quot;yarn build&quot; 以上确保我们只有在代码构建成功的时候才可以将代码推送到远程仓库中。 这似乎是一个相当合理的条件，不是吗？ 通过提交此更改并尝试推送来随意测试它。 最后，我们将再添加一个工具。 到目前为止，我们一直在遵循所有提交消息的标准约定，让我们确保团队中的每个人都遵循它们（包括我们自己！）。 我们可以为我们的提交消息添加一个 linter： 1yarn add -D @commitlint/config-conventional @commitlint/cli 要配置它，我们将使用一组标准默认值，但我喜欢将该列表显式包含在 commitlint.config.js 文件中，因为我有时会忘记可用的前缀： commitlint.config.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// build: 影响构建系统或外部依赖项的更改（示例范围：gulp、broccoli、npm）// ci: 更改我们的 CI 配置文件和脚本（示例范围：Travis、Circle、BrowserStack、SauceLabs）// docs: 文档修改// feat: 一个新的功能// fix: 一个 bug 修复// perf: 提升性能的代码修改// refactor: 既不修复错误也不添加功能的代码更改// style: 不影响代码含义的更改（空格、格式、缺少分号等）// test: 添加缺失的测试或更正现有测试module.exports = &#123; extends: [&quot;@commitlint/config-conventional&quot;], rules: &#123; &quot;body-leading-blank&quot;: [1, &quot;always&quot;], &quot;body-max-line-length&quot;: [2, &quot;always&quot;, 100], &quot;footer-leading-blank&quot;: [1, &quot;always&quot;], &quot;footer-max-line-length&quot;: [2, &quot;always&quot;, 100], &quot;header-max-length&quot;: [2, &quot;always&quot;, 100], &quot;scope-case&quot;: [2, &quot;always&quot;, &quot;lower-case&quot;], &quot;subject-case&quot;: [ 2, &quot;never&quot;, [&quot;sentence-case&quot;, &quot;start-case&quot;, &quot;pascal-case&quot;, &quot;upper-case&quot;], ], &quot;subject-empty&quot;: [2, &quot;never&quot;], &quot;subject-full-stop&quot;: [2, &quot;never&quot;, &quot;.&quot;], &quot;type-case&quot;: [2, &quot;always&quot;, &quot;lower-case&quot;], &quot;type-empty&quot;: [2, &quot;never&quot;], &quot;type-enum&quot;: [ 2, &quot;always&quot;, [ &quot;build&quot;, &quot;chore&quot;, &quot;ci&quot;, &quot;docs&quot;, &quot;feat&quot;, &quot;fix&quot;, &quot;perf&quot;, &quot;refactor&quot;, &quot;revert&quot;, &quot;style&quot;, &quot;test&quot;, &quot;translation&quot;, &quot;security&quot;, &quot;changeset&quot;, ], ], &#125;,&#125;; 然后使用 Husky 启用 commitlint： 12345npx husky add .husky/commit-msg &#x27;npx --no -- commitlint --edit &quot;$1&quot;&#x27;## 有的时候上述的命令会在某些命令行环境失效，也可以试试下面的命令npx husky add .husky/commit-msg \\&quot;npx --no -- commitlint --edit &#x27;$1&#x27;\\&quot;## 或者npx husky add .husky/commit-msg &quot;npx --no -- commitlint --edit $1&quot; 我现在要使用消息 ci: implement commitlint 创建一个新的提交 你可以在下面的屏幕截图中看到此设置的最终结果，希望你的结果与此类似： 如果提交信息格式不正确的话，则会报错 VS Code 配置现在我们已经实现了 ESLint 和 Prettier，我们可以利用一些便利的 VS Code 功能让它们自动运行。 在项目的根目录中创建一个名为 .vscode 的目录和一个名为 settings.json 的文件。 这将是一个覆盖已安装 VS 代码默认设置的值列表。 我们想要将它们放在项目文件夹中的原因是我们可以设置仅适用于该项目的特定设置，并且我们可以通过将它们包含在代码仓库中来与我们团队的其他成员共享它们。 在 settings.json 中，我们将添加以下值 .vscode/settings.json 12345678&#123; &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;, &quot;editor.formatOnSave&quot;: true, &quot;editor.codeActionsOnSave&quot;: &#123; &quot;source.fixAll&quot;: true, &quot;source.organizeImports&quot;: true &#125;&#125; 以上将告诉 VS Code 使用你的 Prettier 扩展作为默认格式化程序（如果你愿意，可以手动覆盖另一个）并在每次保存时自动格式化你的文件并组织你的导入语句 非常方便的东西，你不再需要考虑的另一件事，因此可以专注于重要的事情，例如解决业务问题 让我们在这时候进行一次提交，带上信息 build: implement vscode project settings 调试让我们设置一个方便的环境来调试我们的应用程序，以防我们在开发过程中遇到任何问题。 在 .vscode 目录下创建 launch.json 文件 launch.json 1234567891011121314151617181920212223242526272829&#123; &quot;version&quot;: &quot;0.1.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;Next.js: debug server-side&quot;, &quot;type&quot;: &quot;node-terminal&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;command&quot;: &quot;npm run dev&quot; &#125;, &#123; &quot;name&quot;: &quot;Next.js: debug client-side&quot;, &quot;type&quot;: &quot;pwa-chrome&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;url&quot;: &quot;&lt;http://localhost:3000&gt;&quot; &#125;, &#123; &quot;name&quot;: &quot;Next.js: debug full stack&quot;, &quot;type&quot;: &quot;node-terminal&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;command&quot;: &quot;npm run dev&quot;, &quot;console&quot;: &quot;integratedTerminal&quot;, &quot;serverReadyAction&quot;: &#123; &quot;pattern&quot;: &quot;started server on .+, url: (https?://.+)&quot;, &quot;uriFormat&quot;: &quot;%s&quot;, &quot;action&quot;: &quot;debugWithChrome&quot; &#125; &#125; ]&#125; 使用该脚本你可以选择三种调试方式。单击 VS Code 左侧的小 “错误和播放图标” 或按 Ctrl + Shift + D 访问调试菜单。你可以选择要运行的脚本并使用启动&#x2F;停止按钮启动 &#x2F; 停止它 除此之外，或者如果你没有使用 VS Code，我们也可以在项目中设置一些有用的调试脚本 首先，我们将安装 cross-env ， 如果你有同事在不同的环境（Windows、Linux、Mac 等）上工作，则有必要设置环境变量。 1yarn add -D cross-env 安装完这个包之后，我们可以更新下 package.json 文件中的 dev 脚本 1234567&#123; ... &quot;scripts&quot;: &#123; ... &quot;dev&quot;: &quot;cross-env NODE_OPTIONS=&#x27;--inspect&#x27; next dev&quot;, &#125;,&#125; 这将允许你在开发模式下工作时在浏览器中记录服务器数据，从而更容易调试问题。 在这个阶段，我将创建一个新的提交 build: add debugging configuration 目录结构本节现在将介绍在我们的项目中设置文件夹结构。这是许多人都会有非常强烈意见的话题之一，并且有充分的理由！从长远来看，目录结构确实可以在项目失控时成就或破坏项目，尤其是当团队成员不得不花费不必要的时间来猜测将东西放在哪里（或找到东西）时。 我个人喜欢采用相当简单的方法，基本上以类的 model &#x2F; view 将事物分开。我们将使用三个主要文件夹 PS: 原文没有 src 目录，我个人喜欢用 src 目录，所以加了 src 根目录 123/components/lib/pages components - 组成应用程序的各个 UI 组件将位于此处 lib - 业务 &#x2F; 应用程序&#x2F; 领域 逻辑将存在于此 pages - 项目的实际 路由&#x2F; 页面 除此之外，我们还会有其他目录来支持该项目，但构成我们的应用程序的几乎所有内容的核心都将位于这三个目录中 在 components 中，我们将有子目录，这些子目录将相似类型的组件组合在一起。你可以使用你喜欢的任何方法来执行此操作。 我过去经常使用 MUI 库，所以我倾向于遵循他们在文档中用于组件的相同组织 例如输入框、导航、工具方法、布局等。 你不需要提前创建这些目录并将它们留空。我会在构建组件时随手创建它们 本节旨在解释我将如何设置这个项目，你可以选择许多其他方式来组织你的项目，我鼓励你选择最适合你和团队的方式。 这里我再使用 feat: create directory structure 创建一个提交 添加 Storybook我们可以使用的一种很棒的现代工具叫做 Storybook Storybook 为我们提供了一个环境来展示和测试我们在我们正在使用它们的应用程序之外构建的 React 组件。它是将开发人员与设计人员联系起来并能够根据设计要求验证我们开发的组件的外观和功能的好工具 请注意，Storybook 是一种可视化测试工具，稍后我们将引入其他工具来进行功能单元测试和端到端测试 学习如何使用 Storybook 的最佳方式是安装并试用它！ 1npx sb init --builder webpack5 我们将使用 webpack5 版本来与最新版本的 webpack 保持同步（我不确定为什么它仍然不是默认版本。也许在你使用本教程时已经是了）。 当 Storybook 安装时，它会自动检测有关项目的很多信息，比如它是一个 React 应用程序，以及正在使用的其他工具。 它应该兼容好所有配置本身。 如果你收到有关 eslintPlugin 的提示，你可以选择“是”。 不过，我们将手动配置它，所以如果你收到一条消息说它没有自动配置，请不要担心。 打开 eslintrc.json 文件并更新它 123456789101112131415161718192021222324252627&#123; &quot;extends&quot;: [ &quot;plugin:storybook/recommended&quot;, // 新加入 &quot;next&quot;, &quot;next/core-web-vitals&quot;, &quot;eslint:recommended&quot; ], &quot;globals&quot;: &#123; &quot;React&quot;: &quot;readonly&quot; &#125;, // 新加入 &quot;overrides&quot;: [ &#123; &quot;files&quot;: [&quot;*.stories.@(ts|tsx|js|jsx|mjs|cjs)&quot;], &quot;rules&quot;: &#123; // example of overriding a rule &quot;storybook/hierarchy-separator&quot;: &quot;error&quot; &#125; &#125; ], &quot;rules&quot;: &#123; &quot;no-unused-vars&quot;: [ 1, &#123; &quot;args&quot;: &quot;after-used&quot;, &quot;argsIgnorePattern&quot;: &quot;^_&quot; &#125; ] &#125;&#125; 我添加了 // 新加入 来标记 Storybook 特定的两个新部分和行。 我们注意到，Storybook 也已将 &#x2F;stories 目录添加到项目中，其中包含许多示例。如果你是 Storybook 的新手，我强烈建议你通读它们并将它们留在那里，直到你能够脱离模板自如地创建自己的示例。 在我们运行它之前，我们需要确保我们使用的是 webpack5。 将以下内容添加到 package.json 文件中： 123456&#123; ... &quot;resolutions&quot;: &#123; &quot;webpack&quot;: &quot;^5&quot; &#125;&#125; 然后运行 1yarn install 确保 webpack5 已经被安装 接下来更新 .storybook/main.js 文件 1234567891011121314module.exports = &#123; stories: [&quot;../**/*.stories.mdx&quot;, &quot;../**/*.stories.@(js|jsx|ts|tsx)&quot;], /** 暴露 public 目录给到 stotrybook，作为静态资源目录 */ staticDirs: [&quot;../public&quot;], addons: [ &quot;@storybook/addon-links&quot;, &quot;@storybook/addon-essentials&quot;, &quot;@storybook/addon-interactions&quot;, ], framework: &quot;@storybook/react&quot;, core: &#123; builder: &quot;@storybook/builder-webpack5&quot;, &#125;,&#125;; 在这里，我们更改了 stories 文件的模式，以便它可以在我们的组件（或其他）目录中选取任何 .stories 文件。 我们暴露了 Next.js 的 “public” 目录作为 Storybook 的静态资源目录，这样我们就可以在 Storybook 中测试类似图片，视频等资源了 最后，在我们运行 Storybook 本身之前，让我们在 .storybook/preview.js 中添加一些有用的值。 这是我们控制 stories 渲染方式默认值的文件。 storybook/preview.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445import &quot;../styles/globals.css&quot;;import * as NextImage from &quot;next/image&quot;;const BREAKPOINTS_INT = &#123; xs: 375, sm: 600, md: 900, lg: 1200, xl: 1536,&#125;;const customViewports = Object.fromEntries( Object.entries(BREAKPOINTS_INT).map(([key, val], idx) =&gt; &#123; console.log(val); return [ key, &#123; name: key, styles: &#123; width: `$&#123;val&#125;px`, height: `$&#123;(idx + 5) * 10&#125;vh`, &#125;, &#125;, ]; &#125;));// 允许 Storybook 处理 Next 的 &lt;Image&gt; 组件const OriginalNextImage = NextImage.default;Object.defineProperty(NextImage, &quot;default&quot;, &#123; configurable: true, value: (props) =&gt; &lt;OriginalNextImage &#123;...props&#125; unoptimized /&gt;,&#125;);export const parameters = &#123; actions: &#123; argTypesRegex: &quot;^on[A-Z].*&quot; &#125;, controls: &#123; matchers: &#123; color: /(background|color)$/i, date: /Date$/, &#125;, &#125;, viewport: &#123; viewports: customViewports &#125;,&#125;; 上面有几个属于个人喜好，大家可以随意配置。请务必设置默认断点以匹配应用中对你重要的任何内容。我们还添加了一个处理方法，以便 Storybook 可以处理 Next 的 组件而不会崩溃。 现在我们准备来测试一下，运行 1yarn storybook 如果一切顺利，将在控制台中看到一条消息，如下所示： 然后你可以通过 http://localhost:6006 访问到 如果你以前从未使用过这些示例，我希望你尝试并熟悉这些示例。 在这个阶段，我再创建一个提交 build: implement storybook 创建一个组件模版是时候将我们已经完成的所有配置放在一起，看看如何使用我们为自己设定的标准来创建和实现我们的第一个组件了 我们将创建一个简单的卡片。创建如下的目录 /src/components/template/base 在这个目录中创建 BaseTemplate.tsx 。这将遵循文件名的标准模式，该模式与指向它的目录相匹配。例如，这允许我们在卡片目录中拥有其他类型的卡片，如 PhotoCard 或 TextCard 等。 BaseTemplate.tsx 1234567export interface IBaseTemplate &#123;&#125;const BaseTemplate: React.FC&lt;IBaseTemplate&gt; = () =&gt; &#123; return &lt;div&gt;Hello world!&lt;/div&gt;;&#125;;export default BaseTemplate; 我们的每一个组件都将遵循这个确切的结构。即使它不使用 props，它仍然会为组件导出一个空的 props 接口。这样做的原因是它将允许我们在许多组件和文件中复制这个精确的结构，并使用相同的模式交换组件，并且只查找&#x2F;替换组件的名称。 当你开始使用 stories 和 mock props 时，就会明白为所有组件文件维护一致的命名方案和界面是多么方便和强大。 这其中就遵循了我们之前提及到的 一致性就是一切 接下来我们会为组件创建样式文件。我个人更喜欢将样式文件存放在各个组件的文件夹中 BaseTemplate.module.css 12.component &#123;&#125; 作为顶级样式，将在你的组件目录中放置标准空模板。你可以像如下一样更新 BaseTemplate 文件 BaseTemplate.tsx 123456789import styles from &quot;./BaseTemplate.module.css&quot;;export interface IBaseTemplate &#123;&#125;const BaseTemplate: React.FC&lt;IBaseTemplate&gt; = () =&gt; &#123; return &lt;div className=&#123;styles.container&#125;&gt;Hello world!&lt;/div&gt;;&#125;;export default BaseTemplate; 现在，我们拥有了一个干净的样式模版 现在让我们为组件添加一个实验性质的 prop BaseTemplate.tsx 1234567891011import styles from &quot;./BaseTemplate.module.css&quot;;export interface IBaseTemplate &#123; sampleTextProp: string;&#125;const BaseTemplate: React.FC&lt;IBaseTemplate&gt; = (&#123; sampleTextProp &#125;) =&gt; &#123; return &lt;div className=&#123;styles.container&#125;&gt;&#123;sampleTextProp&#125;&lt;/div&gt;;&#125;;export default BaseTemplate; 对于每一个我们创建的组件，我们希望能够快速的方便的在不同环境（比如在 storybook，或者在 app 内，或者在我们编写的单元测试中）中去测试它。快速访问数据来渲染组件将会很方便。 让我们创建一个文件来存储这个组件的模拟数据，这些模拟数据是给后续测试使用的。 BaseTemplate.mocks.ts 123456789import &#123; IBaseTemplate &#125; from &quot;./BaseTemplate&quot;;const base: IBaseTemplate = &#123; sampleTextProp: &quot;Hello world!&quot;,&#125;;export const mockBaseTemplateProps = &#123; base,&#125;; 这个结构看起来有点点复杂，但很快我们将看到它的优点。我使用十分见名知意的一致命名模式，所以这个模板很容易复制并粘贴到你创建的每个新组件。 现在我们为这个组件创建一个 story BaseTemplate.stories.tsx 12345678910111213141516171819import &#123; ComponentStory, ComponentMeta &#125; from &quot;@storybook/react&quot;;import BaseTemplate, &#123; IBaseTemplate &#125; from &quot;./BaseTemplate&quot;;import &#123; mockBaseTemplateProps &#125; from &quot;./BaseTemplate.mocks&quot;;export default &#123; title: &quot;templates/BaseTemplate&quot;, component: BaseTemplate, argTypes: &#123;&#125;,&#125; as ComponentMeta&lt;typeof BaseTemplate&gt;;const Template: ComponentStory&lt;typeof BaseTemplate&gt; = (args) =&gt; ( &lt;BaseTemplate &#123;...args&#125; /&gt;);export const Base = Template.bind(&#123;&#125;);Base.args = &#123; ...mockBaseTemplateProps.base,&#125; as IBaseTemplate; 我不会告诉你每一个 story 文件的具体细节，对你来说，做好的学习资源是 Storybook 的官方文档。 这里目标是创建一个容易复制粘贴的一致性的组件模版，以供组件进行开发和测试 现在测试一下 1yarn storybook 如果一切顺利，你将会看到下面的界面（如果有问题，我建议你再重新检查一下之前的配置正不正确） 现在我们开始创建更多文件，最好养成在提交之前运行 yarn lint 的习惯，以确保一切都是干净的并准备就绪。我在这里再创建一个提交 build: create BaseTemplate component 使用组件模版既然我们已经有了组件模版，接下来我们就创建一个真实的组件 创建 components/cards 目录。然后将 templates 目录下的 base 文件夹拷贝到 cards 下面，然后再将 base 重命名为 cat 。我们将创建一个 CatCard 。重命名每个文件以匹配。 完成后应该是这样的： 然后在 components/cards/cat 目录下，全局将 BaseTemplate 替换为 CatCard ，如下 现在我们准备开始工作，我们已经有了一个干净的预生成的模版，其中已经为我们的 Card 组件包含了 story 文件和模拟数据文件。相当的方便！让我们开始开发 Card 组件吧： CatCard.tsx 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import Image from &quot;next/image&quot;;import styles from &quot;./CatCard.module.css&quot;;export interface ICatCard &#123; tag: string; title: string; body: string; author: string; time: string;&#125;const CatCard: React.FC&lt;ICatCard&gt; = (&#123; tag, title, body, author, time &#125;) =&gt; &#123; return ( &lt;div className=&#123;styles.container&#125;&gt; &lt;div className=&#123;styles.card&#125;&gt; &lt;div className=&#123;styles.card__header&#125;&gt; &lt;Image src=&quot;/time-cat.jpg&quot; alt=&quot;card__image&quot; className=&#123;styles.card__image&#125; width=&quot;600&quot; height=&quot;400&quot; /&gt; &lt;/div&gt; &lt;div className=&#123;styles.card__body&#125;&gt; &lt;span className=&#123;`$&#123;styles.tag&#125; $&#123;styles[&quot;tag-blue&quot;]&#125;`&#125;&gt; &#123;tag&#125; &lt;/span&gt; &lt;h4&gt;&#123;title&#125;&lt;/h4&gt; &lt;p&gt;&#123;body&#125;&lt;/p&gt; &lt;/div&gt; &lt;div className=&#123;styles.card__footer&#125;&gt; &lt;div className=&#123;styles.user&#125;&gt; &lt;Image src=&quot;&lt;https://i.pravatar.cc/40?img=3&gt;&quot; alt=&quot;user__image&quot; className=&#123;styles.user__image&#125; width=&quot;40&quot; height=&quot;40&quot; /&gt; &lt;div className=&#123;styles.user__info&#125;&gt; &lt;h5&gt;&#123;author&#125;&lt;/h5&gt; &lt;small&gt;&#123;time&#125;&lt;/small&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; );&#125;;export default CatCard; 设置样式 CatCard.module.css 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273@import url(&quot;&lt;https://fonts.googleapis.com/css2?family=Quicksand:wght@300..700&amp;display=swap&gt;&quot;);.container &#123; margin: 1rem;&#125;.container * &#123; box-sizing: border-box; padding: 0; margin: 0;&#125;.card__image &#123; max-width: 100%; display: block; object-fit: cover;&#125;.card &#123; font-family: &quot;Quicksand&quot;, sans-serif; display: flex; flex-direction: column; width: clamp(20rem, calc(20rem + 2vw), 22rem); overflow: hidden; box-shadow: 0 0.1rem 1rem rgba(0, 0, 0, 0.1); border-radius: 1em; background: #ece9e6; background: linear-gradient(to right, #ffffff, #ece9e6);&#125;.card__body &#123; padding: 1rem; display: flex; flex-direction: column; gap: 0.5rem;&#125;.tag &#123; align-self: flex-start; padding: 0.25em 0.75em; border-radius: 1em; font-size: 0.75rem;&#125;.tag-blue &#123; background: #56ccf2; background: linear-gradient(to bottom, #2f80ed, #56ccf2); color: #fafafa;&#125;.card__body h4 &#123; font-size: 1.5rem; text-transform: capitalize;&#125;.card__footer &#123; display: flex; padding: 1rem; margin-top: auto;&#125;.user &#123; display: flex; gap: 0.5rem;&#125;.user__image &#123; border-radius: 50%;&#125;.user__info &gt; small &#123; color: #666;&#125; 设置模拟数据 CatCard.mocks.ts 12345678910111213import &#123; ICatCard &#125; from &quot;./CatCard&quot;;const base: ICatCard = &#123; tag: &quot;Felines&quot;, title: `What&#x27;s new in Cats`, body: &quot;Lorem ipsum dolor sit amet consectetur adipisicing elit. Sequi perferendis molestiae non nemo doloribus. Doloremque, nihil! At ea atque quidem!&quot;, author: &quot;Alex&quot;, time: &quot;2h ago&quot;,&#125;;export const mockCatCardProps = &#123; base,&#125;; 注意这里从项目的 public 目录用了一张 🐱 的照片(&#x2F;time-cat.jpg)，你可以从项目的仓库中找到它 CatCard.stories 的修改就是需要将 story 的 title 从 templates/CatCard 改为 cards/CatCard 我们需要更新 next.config.js，因为我们正在使用一个没有明确声明允许的域（对于头像）。 只需将配置文件更新为如下所示 next.config.js 123456789/** @type &#123;import(&#x27;next&#x27;).NextConfig&#125; */const nextConfig = &#123; reactStrictMode: true, images: &#123; domains: [&quot;i.pravatar.cc&quot;], &#125;,&#125;;module.exports = nextConfig; 或者，你可以将头像图像放在 public 目录中，但为了学习使用外部域的过程，我们将保留此设置。 现在运行 Storybook，如果你足够幸运，你将会看到 这个组件可以很方便的放置在实际项目中的任何位置。在短期内测试时使用 mock prop，并在准备好后更换为真实 prop pages/index.tsx 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import type &#123; NextPage &#125; from &quot;next&quot;;import Head from &quot;next/head&quot;;import Image from &quot;next/image&quot;;import CatCard from &quot;../components/cards/cat/CatCard&quot;;import &#123; mockCatCardProps &#125; from &quot;../components/cards/cat/CatCard.mocks&quot;;const Home: NextPage = () =&gt; &#123; return ( &lt;div&gt; &lt;Head&gt; &lt;title&gt;Create Next App&lt;/title&gt; &lt;meta name=&quot;description&quot; content=&quot;Generated by create next app&quot; /&gt; &lt;link rel=&quot;icon&quot; href=&quot;/favicon.ico&quot; /&gt; &lt;/Head&gt; &lt;main&gt; &lt;h1&gt; Welcome to &lt;a href=&quot;&lt;https://nextjs.org&gt;&quot;&gt;Next.js!&lt;/a&gt; &lt;/h1&gt; &lt;div style=&#123;&#123; display: &quot;flex&quot; &#125;&#125;&gt; &lt;CatCard &#123;...mockCatCardProps.base&#125; /&gt; &lt;CatCard &#123;...mockCatCardProps.base&#125; /&gt; &lt;CatCard &#123;...mockCatCardProps.base&#125; /&gt; &lt;CatCard &#123;...mockCatCardProps.base&#125; /&gt; &lt;/div&gt; &lt;/main&gt; &lt;footer&gt; &lt;a href=&quot;&lt;https://vercel.com?utm_source=create-next-app&amp;utm_medium=default-template&amp;utm_campaign=create-next-app&gt;&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; &gt; Powered by&#123;&quot; &quot;&#125; &lt;span&gt; &lt;Image src=&quot;/vercel.svg&quot; alt=&quot;Vercel Logo&quot; width=&#123;72&#125; height=&#123;16&#125; /&gt; &lt;/span&gt; &lt;/a&gt; &lt;/footer&gt; &lt;/div&gt; );&#125;;export default Home; 运行如下命令查看界面样式 1yarn dev 添加自定义文档虽然在这个阶段没有必要，但你可能希望对应用的 &lt;head&gt; 中的内容进行更细粒度的控制。在pages目录中创建自定义 _document.tsx pages/_document.tsx 123456789101112131415161718192021222324252627import Document, &#123; Head, Html, Main, NextScript &#125; from &quot;next/document&quot;;class MyDocument extends Document &#123; render() &#123; return ( &lt;Html&gt; &lt;Head&gt; &lt;link rel=&quot;preconnect&quot; href=&quot;&lt;https://fonts.googleapis.com&gt;&quot; /&gt; &lt;link rel=&quot;preconnect&quot; href=&quot;&lt;https://fonts.gstatic.com&gt;&quot; /&gt; &lt;link href=&quot;&lt;https://fonts.googleapis.com/css2?family=Quicksand:wght@300..700&amp;display=swap&gt;&quot; rel=&quot;stylesheet&quot; /&gt; &lt;/Head&gt; &lt;body&gt; &lt;Main /&gt; &lt;NextScript /&gt; &lt;/body&gt; &lt;/Html&gt; ); &#125;&#125;export default MyDocument; 请注意，我已经移除了 components/cards/cat/CatCard.module.css 中的 @import 字体，并且把 google 字体放在这里进行预加载 您需要在 &lt;head&gt; 元素中执行或自定义的任何其他操作现在都可以在此文件中完成。 请注意，此 &lt;Head&gt; 与从 next/head 导入的不同。 它们将一起工作，而这个仅用于你希望在每个页面上加载的数据。 更多的关于自定义 _document ，可以查看这个文档 添加 LayoutsLayouts 是 Next.js 中的重要概念。他们协助我们管理页面间的状态。对于本节，我们将使用与官方示例 中提供的相同的基本模板，并简单地对其进行自定义以适合我们的项目。 在 components 中创建新的目录 layouts 。我们将复制两次 templates/case 目录。一个叫做 primary ，另一个叫做 sidebar 。如下图所示 在每个文件中对 BaseTemplate 进行区分大小写的查找&#x2F;替换，并分别替换为 PrimaryLayout 和 SidebarLayout。 如果你在这一步有遇到困难，可以直接参考这个仓库的结构 更新 PrimaryLayout.tsx 和 PrimaryLayout.module.css 文件： components/layouts/primary/PrimaryLayout.tsx 1234567891011121314151617import Head from &quot;next/head&quot;;import styles from &quot;./PrimaryLayout.module.css&quot;;export interface IPrimaryLayout extends React.ComponentPropsWithoutRef&lt;&quot;div&quot;&gt; &#123;&#125;const PrimaryLayout: React.FC&lt;IPrimaryLayout&gt; = (&#123; children &#125;) =&gt; &#123; return ( &lt;&gt; &lt;Head&gt; &lt;title&gt;Primary Layout Example&lt;/title&gt; &lt;/Head&gt; &lt;main className=&#123;styles.main&#125;&gt;&#123;children&#125;&lt;/main&gt; &lt;/&gt; );&#125;;export default PrimaryLayout; components/layouts/primary/PrimaryLayout.module.css 123456789.main &#123; display: flex; height: calc(100vh - 64px); background-color: white;&#125;.main &gt; section &#123; padding: 32px;&#125; 然后是 sidebar components/layouts/sidebar/SidebarLayout.tsx 1234567891011121314151617import Link from &quot;next/link&quot;;import styles from &quot;./SidebarLayout.module.css&quot;;export interface ISidebarLayout &#123;&#125;const SidebarLayout: React.FC&lt;ISidebarLayout&gt; = () =&gt; &#123; return ( &lt;nav className=&#123;styles.nav&#125;&gt; &lt;input className=&#123;styles.input&#125; placeholder=&quot;Search...&quot; /&gt; &lt;Link href=&quot;/&quot;&gt;Home&lt;/Link&gt; &lt;Link href=&quot;/about&quot;&gt;About&lt;/Link&gt; &lt;Link href=&quot;/contact&quot;&gt;Contact&lt;/Link&gt; &lt;/nav&gt; );&#125;;export default SidebarLayout; components/layouts/sidebar/SidebarLayout.module.css 123456789101112131415161718192021222324252627282930313233343536373839.nav &#123; height: 100%; display: flex; flex-direction: column; width: 250px; background-color: #fafafa; padding: 32px; border-right: 1px solid #eaeaea;&#125;.nav &gt; a &#123; margin: 8px 0; text-decoration: none; background: white; border-radius: 4px; font-size: 14px; padding: 12px 16px; text-transform: uppercase; font-weight: 600; letter-spacing: 0.025em; color: #333; border: 1px solid #eaeaea; transition: all 0.125s ease;&#125;.nav &gt; a:hover &#123; background-color: #eaeaea;&#125;.input &#123; margin: 32px 0; text-decoration: none; background: white; border-radius: 4px; border: 1px solid #eaeaea; font-size: 14px; padding: 8px 16px; height: 28px;&#125; 现在这些文件都创建好了，我们需要使用他们。我们将更新我们的主页并创建另一个名为 about.tsx 的页面来展示如何使用共享 layouts 并在页面之间保持组件状态。 首先，我们需要添加一个类型来扩展默认的 NextPage 接口，因为出于某种原因它不包含开箱即用的 getLayout 函数。 创建一个自定义类型文件，它将为我们处理此问题提供方案 pages/page.d.ts 1234567import &#123; NextPage &#125; from &quot;next&quot;;import &#123; ComponentType, ReactElement, ReactNode &#125; from &quot;react&quot;;export type NextPageWithLayout&lt;P = &#123;&#125;&gt; = NextPage&lt;P&gt; &amp; &#123; getLayout?: (_page: ReactElement) =&gt; ReactNode; layout?: ComponentType;&#125;; 当你需要创建自定义 layouts 的页面，你可以使用 NextPageWithLayout 接口来替代 NextPage 接口 现在让我们更新主页 pages/index.tsx 1234567891011121314151617181920212223242526import CatCard from &quot;../components/cards/cat/CatCard&quot;;import &#123; mockCatCardProps &#125; from &quot;../components/cards/cat/CatCard.mocks&quot;;import PrimaryLayout from &quot;../components/layouts/primary/PrimaryLayout&quot;;import SidebarLayout from &quot;../components/layouts/sidebar/SidebarLayout&quot;;import &#123; NextPageWithLayout &#125; from &quot;./page&quot;;const Home: NextPageWithLayout = () =&gt; &#123; return ( &lt;section&gt; &lt;h1&gt; Welcome to &lt;a href=&quot;&lt;https://nextjs.org&gt;&quot;&gt;Next.js!&lt;/a&gt; &lt;/h1&gt; &lt;CatCard &#123;...mockCatCardProps.base&#125; /&gt; &lt;/section&gt; );&#125;;export default Home;Home.getLayout = (page) =&gt; &#123; return ( &lt;PrimaryLayout&gt; &lt;SidebarLayout /&gt; &#123;page&#125; &lt;/PrimaryLayout&gt; );&#125;; 并且在 pages 目录中创建一个新的 about 页面 pages/about.tsx 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import PrimaryLayout from &quot;../components/layouts/primary/PrimaryLayout&quot;;import SidebarLayout from &quot;../components/layouts/sidebar/SidebarLayout&quot;;import &#123; NextPageWithLayout &#125; from &quot;./page&quot;;const About: NextPageWithLayout = () =&gt; &#123; return ( &lt;section&gt; &lt;h2&gt;Layout Example (About)&lt;/h2&gt; &lt;p&gt; This example adds a property &lt;code&gt;getLayout&lt;/code&gt; to your page, allowing you to return a React component for the layout. This allows you to define the layout on a per-page basis. Since we&amp;apos;re returning a function, we can have complex nested layouts if desired. &lt;/p&gt; &lt;p&gt; When navigating between pages, we want to persist page state (input values, scroll position, etc.) for a Single-Page Application (SPA) experience. &lt;/p&gt; &lt;p&gt; This layout pattern will allow for state persistence because the React component tree is persisted between page transitions. To preserve state, we need to prevent the React component tree from being discarded between page transitions. &lt;/p&gt; &lt;h3&gt;Try It Out&lt;/h3&gt; &lt;p&gt; To visualize this, try tying in the search input in the&#123;&quot; &quot;&#125; &lt;code&gt;Sidebar&lt;/code&gt; and then changing routes. You&amp;apos;ll notice the input state is persisted. &lt;/p&gt; &lt;/section&gt; );&#125;;export default About;About.getLayout = (page) =&gt; &#123; return ( &lt;PrimaryLayout&gt; &lt;SidebarLayout /&gt; &#123;page&#125; &lt;/PrimaryLayout&gt; );&#125;; 更新 _app.tsx pages/_app.tsx 12345678910111213141516import type &#123; AppProps &#125; from &quot;next/app&quot;;import &quot;./globals.css&quot;;import &#123; NextPageWithLayout &#125; from &quot;./page&quot;;interface AppPropsWithLayout extends AppProps &#123; Component: NextPageWithLayout;&#125;function MyApp(&#123; Component, pageProps &#125;: AppPropsWithLayout) &#123; // 如果这个 layout 是可用的，则在页面中使用 const getLayout = Component.getLayout || ((page) =&gt; page); return getLayout(&lt;Component &#123;...pageProps&#125; /&gt;);&#125;export default MyApp; 最后我更新了 PrimaryLayout.mocks.ts 文件，为 IPrimaryLayout 添加了 children: &#39;&#123;&#123;component&#125;&#125;’ 用于在 Storybook 中展示 同时我更新 layout 的 story title 从 templates/...变成 layouts/... 最后你可以保存测试一下 1yarn dev 在侧边栏（ Home 和 about ）的按钮单击可以进行页面切换。 请注意，所使用的布局将持续存在而无需重新加载（正如我们的意图），并且用户将获得超快速的体验。 在 Storybook 这边，我们可以独立于应用预览和测试我们的 layout 组件。这个 PrimaryLayout 组件在没有自组件的情况下没有什么作用，而侧边栏则可以完美的显示。 部署最后一步将讲解如何部署一个 Next.js 应用 我们将使用 Vercel，因为它是 Next.js 应用程序最简单、最直接的部署解决方案。 请注意，Vercel 绝对不是唯一的选择，其他主要服务（如 AWS、Netlify 等）也都可以使用。 假设你使用的不是 静态站点生成 模式，那么实际上你仅仅需要找个服务来运行 next start 命令就行了 作为一个普通用户在 Vercel 上进行部署是完全免费的，我们需要从创建账号开始 登录后，单击 + New Project 并授予 Vercel 访问你的 Github 仓库的权限。 你可以授予全局访问权限，也可以仅选择要部署的仓库。我将选择 nextjs-fullstack-app-template-zn 这个仓库。 选择它后，需要对其进行配置。 在 Build and Output Settings 部分，确保将默认的 NPM 命令替换为 yarn 命令（除非你使用的是 NPM）。 我们还没有使用任何环境变量，所以不需要添加 一旦完成，只需单击 Deploy 即可！ 就这么简单。 现在不仅部署了站点，而且每次提交到主分支时，它都会继续自动重新部署。 如果你不想要这种行为，那么在 Vercel 仪表板中进行配置也很容易。 好消息是，你已经配置了 yarn build 命令以确保在推送代码之前构建有效的生产版本，因此可以自信地推送代码，并假设部署会成功。 唯一需要记住的是两个环境之间的差异。 如果你的脚本不同（使用 NPM 而不是 yarn 或反之亦然），或者更常见的情况是缺少环境变量，你的构建仍然有可能在本地成功但在 Vercel 上失败。 我们将在以后的教程中添加 env 值，因此你需要确保在本地和生产环境中都配置了这些值，因为它们是机密，永远不应提交给公共仓库。 下一步我希望你找到了本教程并学到了一些知识，为你和你的团队设置可靠且可扩展的 Next.js 项目。 这是关于创建生产高质量 Next.js 应用程序的系列教程的第一部分。 下面是我对未来教程的一些想法，我希望你能留下一些反馈，告诉我哪些是你认为最有用的（如果你没有在下面看到它们，则可以留下其他反馈） 如何使用 API 路由和 Tailwind CSS 构建全栈 Next.js 应用程序 如何使用 Recoil 将全局状态管理器添加到 Next.js 应用程序 如何使用 jest 和 playwright 在 Next.js 应用程序中实施单元测试和端到端测试 如何使用 Github actions 和 Vercel 创建 CI&#x2F;CD 流水线 如何使用 NextAuth 和 i18next 在 Next.js 应用程序中实现 SSO 身份验证和国际化 如何使用 Prisma 和 Supabase 将数据库连接到 Next.js 应用程序 如何使用 Next.js 和 Nx 在 monorepo 中管理多个应用程序 其他 代码仓库地址 原文地址 页面地址","tags":["Nextjs","SSR"],"categories":["React","Nextjs"]},{"title":"手把手带你入门NextJs","path":"/2024/03/12/手把手带你入门NextJs/","content":"原文地址手把手带你入门 NextJs（v9.5） - 掘金 前言Next.js 之前用过一次，这次是重新做个小回顾，现在最新版本已经到了 9.5.3，有些 API 也同以前有点不同了，网上大部分教程也都是旧版本 v7 的比较多，故打算写下简单的教程，绝对详细的带你入个小门。 库版本本文案例用的关键库版本如下： 12&quot;next&quot;: &quot;^9.5.2&quot;,&quot;react&quot;: &quot;^16.13.1&quot;, node 版本为 12.18.1（node 版本 &gt;&#x3D; 10.13 即可） 初始化 Next.js 项目 新建一个文件夹 如learn-nextjs-example，先进行初始化 1npm i -y 安装所需要的依赖包 1npm i react react-dom next --save 添加 script 命令 为了是开发输入 npm 命令更快捷，所以把常用的命令作为快捷命令设置 12345&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;next&quot;, &quot;build&quot;: &quot;next build&quot;, &quot;start&quot;: &quot;next start&quot;&#125;, 创建 pages 文件夹，运行第一个页面 pages 文件夹是放置页面的，这里边的文件会自动生成相应路由。 比如创建 pages/about.js，那么访问该页面地址就是 http://localhost:3000/about； 比如创建 pages/about/about.js，那么访问地址为http://localhost:3000/about/about。 现在我们创建 pages/index.js，index.js 就是默认代表根路径了 12345const Home = () =&gt; &#123; return &lt;div&gt;Hello Next.js!&lt;/div&gt;&#125;export default Home 此时运行 1npm rum dev 打开http://localhost:3000/，可以看到页面成功运行了，也可以知道 Next.js 内置 React，因此不用我们再引入 import React from &#39;react&#39;，就可以直接使用 React 的语法，当然你写了也不会报错，不过没必要。 路由跳转页面跳转有两种形式，一种是利用标签Link，一种是编程式路由跳转router.push(&#39;/&#39;)。路由跳转方式还是跟 React 很像的，只不过用的是 next 的包 Link 先创建两个页面 pages/about.js 12345const About = () =&gt; &#123; return &lt;div&gt;About Page&lt;/div&gt;&#125;export default About pages/news.js 12345const News = () =&gt; &#123; return &lt;div&gt;News Page&lt;/div&gt;&#125;export default News 在首页pages/index.js编写路由跳转链接 1234567891011121314151617181920import Link from &#x27;next/link&#x27;const Home = () =&gt; &#123; return ( &lt;div&gt; &lt;div&gt;Hello Next.js!&lt;/div&gt; &lt;div&gt; &lt;Link href=&#x27;/about&#x27;&gt; &lt;a&gt;关于&lt;/a&gt; &lt;/Link&gt; &lt;/div&gt; &lt;div&gt; &lt;Link href=&#x27;/news&#x27;&gt; &lt;a&gt;新闻&lt;/a&gt; &lt;/Link&gt; &lt;/div&gt; &lt;/div&gt; )&#125;export default Home 在这里要注意的是 a 标签不用添加 href 元素，添加了也不起作用。 如果Link里面换成其他标签如span，也依然能成功跳转到对应页面，可以知道Link是给里面的元素添加了点击绑定事件，而不是只会给 a 标签添加 href 而已。 此时 DOM 结构： 还有要注意的是：Link 里面只能有一个根元素，要不然它不知要绑定谁会报错。 编程式路由跳转这里主要用useRouter钩子进行跳转 修改pages/index.js，修改其中一个路由 1234567891011121314151617181920212223import Link from &#x27;next/link&#x27;import &#123; useRouter &#125; from &#x27;next/router&#x27;const Home = () =&gt; &#123; const router = useRouter() const gotoAbout = () =&gt; &#123; router.push(&#x27;/news&#x27;) &#125; return ( &lt;div&gt; &lt;div&gt;Hello Next.js!&lt;/div&gt; &lt;div&gt; &lt;Link href=&#x27;/about&#x27;&gt; &lt;a&gt;关于&lt;/a&gt; &lt;/Link&gt; &lt;/div&gt; &lt;div&gt; &lt;button onClick=&#123;gotoAbout&#125;&gt;新闻&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; )&#125;export default Home 路由传参query 形式传参在 Next.js 中只能通过 query（?name&#x3D;jackylin）来传递参数，不能通过(path:name)的形式传递参数。 修改pages/index.js 1234567891011121314151617181920212223import Link from &#x27;next/link&#x27;import &#123; useRouter &#125; from &#x27;next/router&#x27;const Home = () =&gt; &#123; const router = useRouter() const gotoAbout = () =&gt; &#123; router.push(&#x27;/news&#x27;) &#125; return ( &lt;div&gt; &lt;div&gt;Hello Next.js!&lt;/div&gt; &lt;div&gt; &lt;Link href=&#x27;/about?name=jackylin&#x27;&gt; &lt;a&gt;关于&lt;/a&gt; &lt;/Link&gt; &lt;/div&gt; &lt;div&gt; &lt;button onClick=&#123;gotoAbout&#125;&gt;新闻&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; )&#125;export default Home 也可以变换成这种方式传 1&lt;Link href=&#123;&#123; pathname: &#x27;/about&#x27;, query: &#123; name: &#x27;jackylin&#x27; &#125; &#125;&#125;&gt; 传递了参数name后，接下来是接收参数。 打开pages/about.js添加代码 123456789101112import &#123; withRouter &#125; from &#x27;next/router&#x27;const About = (&#123; router &#125;) =&gt; &#123; return ( &lt;div&gt; &lt;div&gt;About Page&lt;/div&gt; &lt;div&gt;接收到参数为：&#123;router.query.name&#125;&lt;/div&gt; &lt;/div&gt; )&#125;export default withRouter(About) 点击关于，跳转到 about 页面，页面内容为： 12About Page接收到参数为：jackylin 同时也可看到地址栏带有参数：http://localhost:3000/about?name=jackylin 编程式路由跳转传递参数修改pages/index.js中的 gotoAbout方法 12345678const gotoAbout = () =&gt; &#123; router.push(&#123; pathname: &#x27;/news&#x27;, query: &#123; info: &#x27;学习Next.js&#x27;, &#125;, &#125;)&#125; pages/news.js 123456789101112import &#123; withRouter &#125; from &#x27;next/router&#x27;const News = (&#123; router &#125;) =&gt; &#123; return ( &lt;div&gt; &lt;div&gt;News Page&lt;/div&gt; &lt;div&gt;接收到参数为：&#123;router.query.info&#125;&lt;/div&gt; &lt;/div&gt; )&#125;export default withRouter(News) 路由变化的钩子这里就不一个个细细展开了，直接代码说话： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import &#123; useEffect &#125; from &#x27;react&#x27;import Link from &#x27;next/link&#x27;import &#123; useRouter &#125; from &#x27;next/router&#x27;const Home = () =&gt; &#123; const router = useRouter() const gotoAbout = () =&gt; &#123; router.push(&#123; pathname: &#x27;/news&#x27;, query: &#123; info: &#x27;学习Next.js&#x27;, &#125;, &#125;) &#125; useEffect(() =&gt; &#123; const handleRouteChangeStart = url =&gt; &#123; console.log(&#x27;routeChangeStart 路由开始变化，url:&#x27;, url) &#125; const handleRouteChangeComplete = url =&gt; &#123; console.log(&#x27;routeChangeComplete 路由结束变化，url:&#x27;, url) &#125; const handleBeforeHistoryChange = url =&gt; &#123; console.log(&#x27;beforeHistoryChange 在改变浏览器 history之前触发，url:&#x27;, url) &#125; const handleRouteChangeError = (err, url) =&gt; &#123; console.log(`routeChangeError 跳转发生错误: $&#123;err&#125;, url:$&#123;url&#125;`) &#125; const handleHashChangeStart = url =&gt; &#123; console.log(&#x27;hashChangeStart hash路由模式跳转开始时执行，url:&#x27;, url) &#125; const handleHashChangeComplete = url =&gt; &#123; console.log(&#x27;hashChangeComplete hash路由模式跳转完成时，url:&#x27;, url) &#125; router.events.on(&#x27;routeChangeStart&#x27;, handleRouteChangeStart) router.events.on(&#x27;routeChangeComplete&#x27;, handleRouteChangeComplete) router.events.on(&#x27;beforeHistoryChange&#x27;, handleBeforeHistoryChange) router.events.on(&#x27;routeChangeError&#x27;, handleRouteChangeError) router.events.on(&#x27;hashChangeStart&#x27;, handleHashChangeStart) router.events.on(&#x27;hashChangeComplete&#x27;, handleHashChangeComplete) return () =&gt; &#123; router.events.off(&#x27;routeChangeStart&#x27;, handleRouteChangeStart) router.events.off(&#x27;routeChangeComplete&#x27;, handleRouteChangeComplete) router.events.off(&#x27;beforeHistoryChange&#x27;, handleBeforeHistoryChange) router.events.off(&#x27;routeChangeError&#x27;, handleRouteChangeError) router.events.off(&#x27;hashChangeStart&#x27;, handleHashChangeStart) router.events.off(&#x27;hashChangeComplete&#x27;, handleHashChangeComplete) &#125; &#125;, []) return ( &lt;div&gt; &lt;div&gt;Hello Next.js!&lt;/div&gt; &lt;div&gt; &lt;Link href=&#x27;/about?name=jackylin&#x27;&gt; &lt;a&gt;关于&lt;/a&gt; &lt;/Link&gt; &lt;/div&gt; &lt;div&gt; &lt;button onClick=&#123;gotoAbout&#125;&gt;新闻&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; )&#125;export default Home style-jsx 编写页面 CSS 样式我们建立一个头部组件再引入pages/index.js，在根目录下新建components/header.js 123456789const Header = () =&gt; &#123; return ( &lt;div&gt; &lt;div className=&#x27;header-bar&#x27;&gt;Header&lt;/div&gt; &lt;/div&gt; )&#125;export default Header pages/index.js引入 Header 组件 123456789import Header from &#x27;../components/header&#x27;const Home = () =&gt; &#123; return ( &lt;div&gt; &lt;Header /&gt; &lt;/div&gt; )&#125; 接着给 Header 写样式，Next.js 内置支持 style jsx 语法，这是其中一种 CSS-in-JS 的解决方案 1234567891011121314151617181920const Header = () =&gt; &#123; return ( &lt;div&gt; &lt;div className=&#x27;header-bar&#x27;&gt;Header&lt;/div&gt; &lt;style jsx&gt; &#123;` .header-bar &#123; width: 100%; height: 50px; line-height: 50px; background: lightblue; text-align: center; &#125; `&#125; &lt;/style&gt; &lt;/div&gt; )&#125;export default Header 运行样式生效 查看 DOM 结构，会发现 Next.js 会自动加入一个随机类名（jsx-xxxxxxx），这样就能防止 CSS 的全局污染。 添加全局 CSS 文件新建文件夹 public，用于放置静态文件如图片和 css 文件等，注意只有名为public的目录能够存放静态资源并对外提供访问。新建文件public/static/styles/common.css 12345body &#123; margin: 0; padding: 0; font-size: 16px;&#125; 自定义 App Next.js 使用App组件来初始化页面，我们可以覆盖App组件来控制页面的初始化。该App作用一般如下： 在页面切换之间保持布局的持久化 切换页面时保持状态 使用 componentDidCatch 自定义错误处理 向页面注入额外的数据 添加全局 CSS 我们要做的就是添加全局 CSS 样式，所以需要覆盖原来默认的App，首先要创建pages/_app.js 123456789import &#x27;../public/static/styles/common.css&#x27;/** * Component 指当前页面，每次路由切换时，Component 都会更新 * pageProps 是带有初始属性的对象，该初始属性由我们的某个数据获取方法预先加载到你的页面中，否则它将是一个空对象 */export default function MyApp(&#123; Component, pageProps &#125;) &#123; return &lt;Component &#123;...pageProps&#125; /&gt;&#125; 重启服务，运行，全局样式添加成功。 集成 style-components如果想要项目支持 style-components 的话，需要我们自己去配置。我们通过自定义 Document 的方式来改写代码，即是指_document.js文件，它只有在服务器端渲染的时候才会被调用，主要用来修改服务器端渲染的文档内容，一般用来配合第三方 css-in-js 方案使用。 安装所需库 1npm i styled-components --save 编译 styled-components 1npm i babel-plugin-styled-components --save-dev 新建文件.babelrc 1234&#123; &quot;presets&quot;: [&quot;next/babel&quot;], &quot;plugins&quot;: [[&quot;styled-components&quot;, &#123; &quot;ssr&quot;: true &#125;]]&#125; 新建 _document.js，改写覆盖它原来的写法。这里要注意的是，要一定要继承 Document，才来改写 12345678910111213141516171819202122232425262728import Document from &#x27;next/document&#x27;import &#123; ServerStyleSheet &#125; from &#x27;styled-components&#x27;export default class MyDocument extends Document &#123; static async getInitialProps(ctx) &#123; const sheet = new ServerStyleSheet() const originalRenderPage = ctx.renderPage try &#123; ctx.renderPage = () =&gt; originalRenderPage(&#123; enhanceApp: App =&gt; props =&gt; sheet.collectStyles(&lt;App &#123;...props&#125; /&gt;), &#125;) const initialProps = await Document.getInitialProps(ctx) return &#123; ...initialProps, styles: ( &lt;&gt; &#123;initialProps.styles&#125; &#123;sheet.getStyleElement()&#125; &lt;/&gt; ), &#125; &#125; finally &#123; sheet.seal() &#125; &#125;&#125; 这其中详细配置意思可以去官方文档找点线索了解：Next.js 接下来我们使用 styled-components 的方式添加样式，打开pages/about.js 1234567891011121314151617import &#123; withRouter &#125; from &#x27;next/router&#x27;import styled from &#x27;styled-components&#x27;const Title = styled.h1` color: green;`const About = (&#123; router &#125;) =&gt; &#123; return ( &lt;div&gt; &lt;Title&gt;About Page&lt;/Title&gt; &lt;div&gt;接收到参数为：&#123;router.query.name&#125;&lt;/div&gt; &lt;/div&gt; )&#125;export default withRouter(About) 运行，如下图： 获取数据的方式四个 api 都只能在 pages 文件夹内的文件中使用 getStaticProps当页面内容取决于外部数据 Next.js 推荐我们尽可能使用静态生成的方式，因为所有页面都可以只构建一次并托管到 CDN 上，这比让服务器根据每个页面请求来渲染页面快得多。 比如下列一些类型的页面： 营销页面 个人博客 产品列表 静态文档 如果一个页面使用了 静态生成（SSG），在构建时将生成此页面对应的 HTML 文件 。HTML 文件将在每个页面请求时被重用，还可以被 CDN 缓存。这个跟 hexo，Gatsby 类似的，生成静态文件还有 json 文件。 关于 Gatsby，它是基于 React 的上层框架，具体可以看我这篇博客了解：手把手带你入门 Gatsby Next.js 会尽可能地自动优化应用并输出静态 HTML，如果你在你的页面组件添加了getInitialProps方法才会禁用自动静态优化，getInitialProps方法下面会说到。 比如我们可以执行命令查看 1npm run build 打包默认是 SSG 模式： ● (SSG) automatically generated as static HTML + JSON (uses getStaticProps) 会发现.next/server/pages/下多出了几个 HTML 文件，这些就是静态构建出的 HTML 文件。 新建文件pages/blog.js 12345678910111213141516171819const Blog = (&#123; posts &#125;) =&gt; &#123; return &lt;div&gt;title: &#123;posts.title&#125;&lt;/div&gt;&#125;// 此函数在构建时被调用export async function getStaticProps() &#123; // 调用外部 API 获取内容 const res = await fetch(&#x27;https://jsonplaceholder.typicode.com/todos/1&#x27;) const posts = await res.json() // 在构建时将接收到 `posts` 参数 return &#123; props: &#123; posts, &#125;, &#125;&#125;export default Blog 进入http://localhost:3000/blog，发现页面能正常获取到请求结果： 1title: delectus aut autem getStaticPaths当页面的路径取决于外部数据 这种方式和上面就有些不同了，上面http://localhost:3000/blog访问路径时我们已经写了一个 js 页面文件，但如果我们想要根据获取的数据动态生成多篇文章路径的话，那就需要用到这个 API，通常用这个 API 会同时配合getStaticProps一起用。 新建文件pages/posts/[id].js，你没有看错，文件名就是[id].js 用id标识单篇博文，比如你访问http://localhost:3000/posts/1就展示id为 1 的文章。 代码如下： 123456789101112131415161718192021222324252627282930313233const Post = (&#123; post &#125;) =&gt; &#123; return ( &lt;div&gt; &lt;div&gt;文章id: &#123;post.id&#125;&lt;/div&gt; &lt;div&gt;博客标题: &#123;post.title&#125;&lt;/div&gt; &lt;/div&gt; )&#125;// 构建路由export async function getStaticPaths() &#123; // 调用外部 API 获取博文列表 const res = await fetch(&#x27;https://jsonplaceholder.typicode.com/todos&#x27;) const posts = await res.json() // 根据博文列表生成所有需要预渲染的路径 const paths = posts.map(post =&gt; `/posts/$&#123;post.id&#125;`) // fallback为false，表示任何不在 getStaticPaths 的路径的结果将是 404 页面。 return &#123; paths, fallback: false &#125;&#125;// 获取单个页面博文数据export async function getStaticProps(&#123; params &#125;) &#123; // 如果路由是 /posts/1，那么 params.id 就是 1 const res = await fetch(`https://jsonplaceholder.typicode.com/todos/$&#123;params.id&#125;`) const post = await res.json() // 通过 props 参数向页面传递博文的数据 return &#123; props: &#123; post &#125; &#125;&#125;export default Post 拉取下来的数据全部有 200 条，也就是说动态构建了 200 个路由，现在我们访问第 50 篇博文的话，直接输入http://localhost:3000/posts/50 页面显示： 12文章id: 50博文标题: cupiditate necessitatibus ullam aut quis dolor voluptate 接下来让我们再次打包，执行npm run build（如果打包发生错误很可能是网络差和请求链接有关，因为要请求很多页面，如果是网络问题多试几次就行），你会发现这次打包时间变长了，因为要构建的静态页面多了，我们请求返回来的数据有 200 条，所以应该生成 200 个静态 HTML 文件和相应的 json 数据文件。 我们来看 1.json 文件，就是请求后的数据 1&#123;&quot;pageProps&quot;:&#123;&quot;post&quot;:&#123;&quot;userId&quot;:1,&quot;id&quot;:1,&quot;title&quot;:&quot;delectus aut autem&quot;,&quot;completed&quot;:false&#125;&#125;,&quot;__N_SSG&quot;:true&#125; getServerSideProps每次页面请求时重新生成页面的 HTML 如果无法在用户请求之前预渲染页面，那上面的”静态生成”就不太适用了，或者是页面数据需要频繁的更新，并且页面内容会随着每个请求而变化。这个时候，有两种方案： 将“静态生成”与 客户端渲染 一起使用：你可以跳过页面某些部分的预渲染，然后使用客户端 JavaScript 来填充它们 使用 服务器端渲染： Next.js 针对每个页面的请求进行预渲染。由于 CDN 无法缓存该页面，因此速度会较慢，但是预渲染的页面将始终是最新的。 由于服务器端渲染会导致性能比“静态生成”慢，因此仅在绝对必要时才使用此功能。 新建文件pages/server-blog.js 1234567891011121314151617181920const Blog = (&#123; posts &#125;) =&gt; &#123; return &lt;div&gt;title: &#123;posts.title&#125;&lt;/div&gt;&#125;// 在每次页面请求时都会运行，而在构建时不运行。// 要设置某个页面使用服务器端渲染，就需要导出 getServerSideProps 函数export async function getServerSideProps() &#123; // 调用外部 API 获取内容 const res = await fetch(&#x27;https://jsonplaceholder.typicode.com/todos/1&#x27;) const posts = await res.json() // 在构建时将接收到 `posts` 参数 return &#123; props: &#123; posts, &#125;, &#125;&#125;export default Blog 运行npm run build，发现这次并没有生成对应的 html 文件——server-blog.html，因为我们指定了服务端渲染，请求构建时不会执行，不是静态生成。 getInitialPropsgetInitialProps 是在渲染页面之前就会运行的 API。 如果该路径下包含该请求，则执行该请求，并将所需的数据作为 props 传递给页面。当第一次访问直接页面，getInitialProps 就在服务器端运行，加载完毕后页面给客户端托管，使用客户端的路由跳转，之后页面的 getInitialProps 就在客户端执行了。 推荐： getStaticProps 或 getServerSideProps。如果你使用的是 Next.js 9.3 或更高版本，我们建议你使用 getStaticProps 或 getServerSideProps 来替代 getInitialProps。这些新的获取数据的方法使你可以在静态生成（static generation）和服务器端渲染（server-side rendering）之间进行精细控制。 新建文件pages/initial-blog.js 123456789101112131415161718192021import Link from &#x27;next/link&#x27;const InitialBlog = (&#123; post &#125;) =&gt; &#123; return ( &lt;div&gt; &lt;h1&gt;getInitialProps Demo Page&lt;/h1&gt; &lt;div&gt;获取到的title: &#123;post.title&#125;&lt;/div&gt; &lt;Link href=&#x27;/&#x27;&gt; &lt;a&gt;返回首页&lt;/a&gt; &lt;/Link&gt; &lt;/div&gt; )&#125;InitialBlog.getInitialProps = async ctx =&gt; &#123; const res = await fetch(&#x27;https://jsonplaceholder.typicode.com/todos/1&#x27;) const post = await res.json() return &#123; post &#125;&#125;export default InitialBlog 再修改pages/index.js代码，增加一个Link标签可以跳转回该页面 12345&lt;div&gt; &lt;Link href=&#x27;/initial-blog&#x27;&gt; &lt;a&gt;进入Initial Blog&lt;/a&gt; &lt;/Link&gt;&lt;/div&gt; 接着直接地址栏输入http://localhost:3000/initial-blog，在渲染该页面内容前，先会执行getInitialProps方法，执行完的结果再传到页面组件，开始渲染页面。由于我们是第一次访问页面，首屏则为服务端渲染。 页面内容显示为： 12getInitialProps Demo Page获取到的title: delectus aut autem 打开浏览器的 Network 面板，找到 Name 值为initial-blog的请求，会看到请求响应内容的正是该页面的 HTML。 点击返回首页，再从首页点击进入Initial Blog，重新进入该页面，注意的是此时已经不是我们浏览器通过地址栏访问该页面，而是通过前端路由进入该页面。 查看 Network 面板的请求，会看到此时返回的是getInitialProps请求回来的数据，而不是 HTML 页面内容，由此可知此时页面已经交由客户端渲染。这就是所谓 SSR 渲染，首屏交给服务端渲染返回，返回后页面跳转就是客户端渲染了。 自定义 Head之所以会选择 Next.js，相信一个非常重要的原因就是有利用 SEO，那么利于爬虫检索的方式，一种就是在页面写好 TDK（title、description、keyword），Next.js 可以自定义Head标签 修改components/header.js，在最外层 div 根元素里内添加代码 1234&lt;Head&gt; &lt;title&gt;Next.js 教程 -- JackyLin&lt;/title&gt; &lt;meta name=&#x27;viewport&#x27; content=&#x27;initial-scale=1.0, width=device-width&#x27; /&gt;&lt;/Head&gt; 打开http://localhost:3000/，就会看到页面的头部标签 title 已经被我们改了。 LazyLoding 实现模块&#x2F;组件懒加载懒加载是指需要用到或该加载到某个组件&#x2F;模块的时候，才加载那个组件&#x2F;模块的 js 文件，也叫异步加载。 如果页面文件内容多过大，那么可能出现首次打开速度慢，这时就需要进行优化了，懒加载就是其中一种方式。 懒加载模块先安装一个处理日期时间的库 1npm i moment --save 新建pages/time.js 1234567891011121314151617import &#123; useState &#125; from &#x27;react&#x27;import moment from &#x27;moment&#x27;const Time = () =&gt; &#123; const getTime = () =&gt; &#123; setNowTime(moment().format(&#x27;YYYY-MM-DD HH:mm:ss&#x27;)) &#125; const [nowTime, setNowTime] = useState(&#x27;&#x27;) return ( &lt;div&gt; &lt;button onClick=&#123;getTime&#125;&gt;获取当前时间&lt;/button&gt; &lt;div&gt;当前时间：&#123;nowTime&#125;&lt;/div&gt; &lt;/div&gt; )&#125;export default Time 假设我们这个页面内容很多，然后你进入该页面可能不需要点击获取时间，但moment模块依然加载了，这就有点资源浪费。 于是，我们想当我们点击按钮的时候，再来加载moment模块，即是实现异步加载，而不是页面一进入就加载。 此时点击按钮获取时间，可看到 Network 面板看到moment的代码被打包成了一个1.js文件，这样就实现了懒加载了，这样可以减少了主要 JavaScript 包的大小,带来了更快的加载速度。 1234567891011121314151617181920import &#123; useState &#125; from &#x27;react&#x27;const Time = () =&gt; &#123; const getTime = async () =&gt; &#123; const moment = await import(&#x27;moment&#x27;) setNowTime(moment.default().format(&#x27;YYYY-MM-DD HH:mm:ss&#x27;)) // 注意这里使用 default，不能直接用 moment() &#125; const getTime = () =&gt; &#123; setNowTime(moment().format(&#x27;YYYY-MM-DD HH:mm:ss&#x27;)) &#125; const [nowTime, setNowTime] = useState(&#x27;&#x27;) return ( &lt;div&gt; &lt;button onClick=&#123;getTime&#125;&gt;获取当前时间&lt;/button&gt; &lt;div&gt;当前时间：&#123;nowTime&#125;&lt;/div&gt; &lt;/div&gt; )&#125;export default Time 懒加载组件懒加载组件需要引入 next/dynamic模块 新建组件components/content.js 12345const Content = () =&gt; &#123; return &lt;div&gt;content&lt;/div&gt;&#125;export default Content 引入pages/time.js 12345678910111213141516171819202122import &#123; useState &#125; from &#x27;react&#x27;import dynamic from &#x27;next/dynamic&#x27;// 懒加载自定义组件const Content = dynamic(() =&gt; import(&#x27;../components/content&#x27;))const Time = () =&gt; &#123; const getTime = async () =&gt; &#123; const moment = await import(&#x27;moment&#x27;) setNowTime(moment.default().format(&#x27;YYYY-MM-DD HH:mm:ss&#x27;)) // 注意这里使用 default，不能直接用 moment() &#125; const [nowTime, setNowTime] = useState(&#x27;&#x27;) return ( &lt;div&gt; &lt;button onClick=&#123;getTime&#125;&gt;获取当前时间&lt;/button&gt; &lt;div&gt;当前时间：&#123;nowTime&#125;&lt;/div&gt; &lt;Content /&gt; &lt;/div&gt; )&#125;export default Time 观察 Network 可以看到 Content 组件被新单独打包成一个 js 文件 打包生产环境执行 1npm run build 打包完成后，运行服务器 1npm run start 然后查看页面，打包成功！ 本教程的代码地址：手把手带你入门 NextJS 代码 参考： Server side rendering Styled-Components with NextJS ps： 个人技术博文 Github 仓库，觉得不错的话欢迎 star，给我一点鼓励继续写作吧~","tags":["Nextjs","SSR"],"categories":["React","Nextjs"]},{"title":"Nunjucks模版引擎入门","path":"/2024/03/12/Nunjucks模版引擎入门/","content":"原文地址nunjucks 模版引擎入门 - 掘金 1.nunjucksNunjucks 是 Mozilla 开发的一个纯 JavaScript 编写的模板引擎，既可以用在 Node 环境下，又可以运行在浏览器端 2.安装1npm install nunjucks 3. 使用3.1 渲染字符串123456let nunjucks = require(&#x27;nunjucks&#x27;)// autoescape 自动转移非法字符nunjucks.configure(&#123;autoescape:true&#125;)let ret = nunjucks.renderString(&#x27;hello &#123;&#123;username&#125;&#125;&#x27;,&#123;username:&#x27;blued&#x27;&#125;)console.log(ret) // hello blued 3.2 渲染模版文件新建 view 目录，新建 user.html 文件 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; hello &#123;&#123;name&#125;&#125; &lt;div&gt;&lt;/body&gt;&lt;/html&gt; js 123456789101112const nunjucks = require(&#x27;nunjucks&#x27;)const path = require(&#x27;path&#x27;)// 如何渲染模版文件let data = &#123;name:&#x27;blued&#x27;&#125;// 配置模版文件的所在目录nunjucks.configure(path.resolve(__dirname,&#x27;view&#x27;),&#123; autoescape:true&#125;)let result = nunjucks.render(&#x27;user.html&#x27;,data)console.log(result) 输出结果如下 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; hello blued &lt;div&gt;&lt;/body&gt;&lt;/html&gt; 3.3 express12345678910111213141516// 3.nunjucks.js// 如何在express 中使用模版引擎let express = require(&#x27;express&#x27;)const nunjucks = require(&#x27;nunjucks&#x27;)const path = require(&#x27;path&#x27;)let app = express()nunjucks.configure(path.resolve(__dirname,&#x27;view&#x27;),&#123; autoescape:true, express:app//这个参数其实是在向app里注入渲染模版的方法&#125;)app.get(&#x27;/&#x27;,function(req,res)&#123; // render 方法是express内置的res.render(&#x27;user.html&#x27;,&#123;name:&#x27;blued&#x27;&#125;)&#125;)app.listen(8010) node nunjucks.js 运行 访问 http://localhost:8010/ 4. 语法4.1 变量变量会从模版上下文获取，如果你想显示一个变量可以: 1&#123;&#123;username&#125;&#125; 4.2 过滤器过滤器是一些可以执行变量的函数，通过管道操作符（|）调用，并可接受参数。 12345678910let nunjucks = require(&#x27;nunjucks&#x27;)nunjucks.configure(&#123;autoescape:true&#125;)// 使用过滤器let ret = nunjucks.renderString(&quot;&#123;&#123;username|join(&#x27;-&#x27;)&#125;&#125;&quot;,&#123;username:[&#x27;blued&#x27;,&#x27;city&#x27;]&#125;)console.log(ret) //blued-citylet ret2 = nunjucks.renderString(&quot;&#123;&#123;username|replace(&#x27;city&#x27;,&#x27;there&#x27;)|capitalize&#125;&#125;&quot;,&#123;username:&#x27;blued city&#x27;&#125;)console.log(ret2)// Blued there 4.3 ifif 为分支语句，与 javascript 中的 if 类似。 12345678910111213141516let nunjucks = require(&#x27;nunjucks&#x27;)nunjucks.configure(&#123;autoescape:true&#125;)// 使用判断let ret = nunjucks.renderString(`&#123;% if score &gt;90 %&#125;优秀&#123;% elseif score &gt;80%&#125;良好&#123;% elseif score &gt;60%&#125;及格&#123;% else %&#125;不及格&#123;% endif %&#125;`,&#123;score:70&#125;)console.log(ret) // 及格 4.4 forfor 可以遍历数组 (arrays) 和对象 (dictionaries)。 12345678910111213141516171819let nunjucks = require(&#x27;nunjucks&#x27;)nunjucks.configure(&#123;autoescape:true&#125;)// 使用判断 loop.index为索引let ret = nunjucks.renderString(` &lt;ul&gt; &#123;% for user in users %&#125; &lt;li&gt;&#123;&#123;loop.index&#125;&#125; &#123;&#123;user.id&#125;&#125;:&#123;&#123;user.name&#125;&#125;&lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt;`,&#123;users:[ &#123;id:1,name:&#x27;blued1&#x27;&#125;, &#123;id:2,name:&#x27;blued2&#x27;&#125;, &#123;id:3,name:&#x27;blued3&#x27;&#125;, &#123;id:4,name:&#x27;blued4&#x27;&#125;, &#123;id:5,name:&#x27;blued5&#x27;&#125;]&#125;)console.log(ret) 输出结果： 12345678910111213&lt;ul&gt; &lt;li&gt;1 1:blued1&lt;/li&gt; &lt;li&gt;2 2:blued2&lt;/li&gt; &lt;li&gt;3 3:blued3&lt;/li&gt; &lt;li&gt;4 4:blued4&lt;/li&gt; &lt;li&gt;5 5:blued5&lt;/li&gt; &lt;/ul&gt; loop.index: 当前循环数 (1 indexed) loop.index0: 当前循环数 (0 indexed) loop.revindex: 当前循环数，从后往前 (1 indexed) loop.revindex0: 当前循环数，从后往前 (0 based) loop.first: 是否第一个 loop.last: 是否最后一个 loop.length: 总数 使用一下看看效果 1234567891011121314151617181920212223242526let nunjucks = require(&#x27;nunjucks&#x27;)nunjucks.configure(&#123;autoescape:true&#125;)// 使用判断let ret = nunjucks.renderString(` &lt;ul&gt; &#123;% for user in users %&#125; &lt;li&gt; loop.index--&#123;&#123;loop.index&#125;&#125; loop.index0--&#123;&#123;loop.index0&#125;&#125; loop.revindex--&#123;&#123;loop.revindex&#125;&#125; loop.revindex0--&#123;&#123;loop.revindex0&#125;&#125; loop.first--&#123;&#123;loop.first&#125;&#125; loop.last --&#123;&#123;loop.last&#125;&#125; loop.length --&#123;&#123;loop.length&#125;&#125; &#123;&#123;user.id&#125;&#125;:&#123;&#123;user.name&#125;&#125; &lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt;`,&#123;users:[ &#123;id:1,name:&#x27;blued1&#x27;&#125;, &#123;id:2,name:&#x27;blued2&#x27;&#125;, &#123;id:3,name:&#x27;blued3&#x27;&#125;]&#125;)console.log(ret) 输出结果: 123456789101112131415161718192021222324252627282930313233343536373839&lt;ul&gt; &lt;li&gt; loop.index--1 loop.index0--0 loop.revindex--3 loop.revindex0--2 loop.first--true loop.last --false loop.length --3 1:blued1 &lt;/li&gt; &lt;li&gt; loop.index--2 loop.index0--1 loop.revindex--2 loop.revindex0--1 loop.first--false loop.last --false loop.length --3 2:blued2 &lt;/li&gt; &lt;li&gt; loop.index--3 loop.index0--2 loop.revindex--1 loop.revindex0--0 loop.first--false loop.last --true loop.length --3 3:blued3 &lt;/li&gt;&lt;/ul&gt; 4.5 模版继承 模版继承可以达到模版复用的效果，当写一个模版的时候可以定义”blocks”,子模版可以覆盖他 支持多层继承 新建一个 layout.html 作为一个模版(为了方便查看这里只保留了 body 内容) 1234567&lt;body&gt; &lt;h1&gt;我是头&lt;/h1&gt; &#123;% block content%&#125; 我是layout模板的内容name= &#123;&#123;name&#125;&#125; &#123;% endblock%&#125; &lt;h1&gt;我是尾&lt;/h1&gt;&lt;/body&gt; nunjucks.js 123456789101112const nunjucks = require(&#x27;nunjucks&#x27;)const path = require(&#x27;path&#x27;)// 如何渲染模版文件let data = &#123;name:&#x27;blued&#x27;&#125;// 配置模版文件的所在目录nunjucks.configure(path.resolve(__dirname,&#x27;view&#x27;),&#123; autoescape:true&#125;)let result = nunjucks.render(&#x27;layout.html&#x27;,data)console.log(result) 输出结果: 1234567&lt;body&gt; &lt;h1&gt;我是头&lt;/h1&gt; 我是layout模板的内容name= blued &lt;h1&gt;我是尾&lt;/h1&gt;&lt;/body&gt; 接下来我们看一下是如何继承的 新建一个 login.html 文件 1234567&#123;% extends &quot;layout.html&quot; %&#125;&#123;% block content%&#125; &lt;form action=&quot;&quot;&gt; 用户名 &lt;input type=&quot;teåxt&quot;&gt; &lt;/form&gt;&#123;% endblock%&#125; 使用extends关键字，注意模版名称一定要为字符串像这样&quot;layout.html&quot;,否则会报错哦。 接下来修改 js 文件，渲染’login.html’ 12let result = nunjucks.render(&#x27;login.html&#x27;,data)console.log(result) 输出结果： 123456789&lt;body&gt; &lt;h1&gt;我是头&lt;/h1&gt; &lt;form action=&quot;&quot;&gt; 用户名 &lt;input type=&quot;teåxt&quot;&gt; &lt;/form&gt; &lt;h1&gt;我是尾&lt;/h1&gt;&lt;/body&gt; 是不是很简单就实现了继承呢，如果你有多个页面头尾都一样，只有内容不一样就能派上用场了呢！ 4.6 包含include关键字可以引入其他的模版，可以在多模版之间共享一些小模版，如果某个模版已使用了继承那么include将会非常有用。 12345678910111213//nunjucks.jsconst nunjucks = require(&#x27;nunjucks&#x27;)const path = require(&#x27;path&#x27;)// 模版的包含let data = &#123;users:[&#123;id:1,name:&#x27;z1&#x27;&#125;,&#123;id:2,name:&#x27;z2&#x27;&#125;]&#125;// 配置模版文件的所在目录nunjucks.configure(path.resolve(__dirname,&#x27;view&#x27;),&#123; autoescape:true&#125;)let result = nunjucks.render(&#x27;users.html&#x27;,data)console.log(result) users.html 12345678&#123;% extends &quot;layout.html&quot;%&#125;&#123;% block content %&#125;&lt;ul style=&#x27;border:1px solid red&#x27;&gt; &#123;% for user in users %&#125; &#123;% include &quot;item.html&quot; %&#125; &#123;% endfor%&#125;&lt;/ul&gt;&#123;% endblock %&#125; item.html 1&lt;li&gt;名次：&#123;&#123;loop.index&#125;&#125;:&#123;&#123;user.id&#125;&#125;:&#123;&#123;user.name&#125;&#125;&lt;/li&gt; 输出结果： 12345678910111213&lt;body&gt; &lt;h1&gt;我是头&lt;/h1&gt;&lt;ul style=&#x27;border:1px solid red&#x27;&gt; &lt;li&gt;名次：1:1:z1&lt;/li&gt; &lt;li&gt;名次：2:2:z2&lt;/li&gt;&lt;/ul&gt; &lt;h1&gt;我是尾&lt;/h1&gt;&lt;/body&gt; 参考资料 getting-started nunjucks","tags":["模版引擎","nunjucks"]},{"title":"EJS模板引擎使用指南","path":"/2024/03/12/EJS模板引擎使用指南/","content":"原文地址EJS：高效的嵌入式 JavaScript 模板引擎 - 掘金 EJS（Embedded JavaScript Templates）是一种简单而灵活的模板引擎，用于将数据动态渲染到网页上。本文将从介绍EJS的背景和起源开始，详细介绍EJS的特性和使用方法，包括安装配置、基本语法和标签、数据绑定和逻辑控制、模板的继承和包含等方面。然后，重点解析EJS的核心特性，包括嵌入JavaScript代码、支持变量、自定义过滤器和函数、条件判断和循环、模板的复用和组合。接着，给出了EJS的性能优化技巧，如缓存编译后的模板、减少嵌套和重复渲染、合理使用变量以及异步加载和渲染等。最后，通过案例分析，展示了实战中如何使用EJS构建静态网页、动态网页以及与后端数据交互。 详细学习请参考中文文档：ejs.bootcss.com 一、什么是EJS1.1 EJS的背景和起源EJS是一种模板引擎，最早由TJ Holowaychuk在2010年创建。它的目标是提供一种简洁、易用的方式来生成动态网页。EJS的设计受到了Ruby on Rails中ERB模板引擎的启发，并借鉴了其他模板引擎的一些特性。 EJS 的含义你知道吗？ “E” 代表什么？可以表示 “可嵌入（Embedded）”，也可以是“高效（Effective）”、“优雅（Elegant）”或者是“简单（Easy）”。EJS 是一套简单的模板语言，帮你利用普通的 JavaScript 代码生成 HTML 页面。EJS 没有如何组织内容的教条；也没有再造一套迭代和控制流语法；有的只是普通的 JavaScript 代码而已。 1.2 EJS的基本概念和设计思想EJS使用嵌入式JavaScript代码来动态生成HTML。它采用了模板标记（&lt;% %&gt;）来执行JavaScript代码，以及插值标记（&lt;%&#x3D; %&gt;)来输出变量的值。EJS的设计思想是尽可能保持简单和灵活，让开发者可以自由地组织和控制模板的结构和逻辑。 二、开始使用EJS2.1 安装和配置EJS要使用EJS，首先需要在项目中安装EJS包，并进行相应的配置。以下是安装和配置EJS的示例代码： 12345678// 使用npm安装EJS包npm install ejs// 在Node.js中通过require引入EJSconst ejs = require(&#x27;ejs&#x27;);// 配置EJS模板引擎app.set(&#x27;view engine&#x27;, &#x27;ejs&#x27;); 2.2 EJS的基本语法和标签EJS使用尖括号加百分号的标记来执行JavaScript代码和插值。以下是EJS的基本语法和标签示例： 123456&lt;% // 执行JavaScript代码 %&gt;&lt;%= // 输出变量的值 %&gt;&lt;%- // 输出原始HTML代码 %&gt;&lt;%# // 注释 %&gt;&lt;%_ // 删除前导空格 %&gt;&lt;% __line // 添加行号注释 %&gt; 2.3 数据绑定和逻辑控制EJS支持将数据绑定到模板中，使得页面内容能够动态生成。同时，EJS还提供了条件判断和循环等控制结构，以便根据不同的情况来展示不同的内容。以下是数据绑定和逻辑控制的示例代码： 12345678910111213&lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt; // 输出变量title的值&lt;% if (isAdmin) &#123; %&gt; // 条件判断 &lt;p&gt;Welcome, admin!&lt;/p&gt;&lt;% &#125; else &#123; %&gt; &lt;p&gt;Welcome, guest!&lt;/p&gt;&lt;% &#125; %&gt;&lt;ul&gt;&lt;% for (let i = 0; i &lt; items.length; i++) &#123; %&gt; // 循环 &lt;li&gt;&lt;%= items[i] %&gt;&lt;/li&gt;&lt;% &#125; %&gt;&lt;/ul&gt; 2.4 模板的继承和包含在EJS中，可以使用模板的继承和包含功能来重用和组合模板。模板继承允许创建一个基础模板，并在其基础上定义子模板，从而实现模板的层次化管理。模板包含允许将多个模板组合在一起，以便构建更复杂的页面。以下是模板的继承和包含的示例代码： base.ejs（基础模板）： 123456789&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;%- body %&gt;&lt;/body&gt;&lt;/html&gt; index.ejs（子模板）： 12345678910&lt;% extends(&#x27;base&#x27;) %&gt;&lt;% block(&#x27;title&#x27;) %&gt; &lt;%- title %&gt;&lt;% endblock %&gt;&lt;% block(&#x27;body&#x27;) %&gt; &lt;h1&gt;&lt;%= heading %&gt;&lt;/h1&gt; &lt;p&gt;&lt;%= content %&gt;&lt;/p&gt;&lt;% endblock %&gt; 三、EJS的核心特性详解3.1 嵌入JavaScript代码在EJS中，可以使用&lt;% %&gt;标记嵌入JavaScript代码。这使得开发者可以在模板中执行各种逻辑操作，如条件判断、循环等。 3.2 支持局部变量和全局变量EJS支持局部变量和全局变量。局部变量在模板内部定义，并只在当前作用域可见。全局变量则可以在整个应用程序中共享和访问。 3.3 自定义过滤器和函数EJS允许开发者定义自己的过滤器和函数，以便对数据进行处理和转换。通过自定义过滤器和函数，可以实现更灵活和高度定制化的模板功能。 3.4 支持条件判断和循环EJS支持条件判断和循环等控制结构，以便根据不同的条件来展示不同的内容。条件判断可以使用if语句、switch语句等，循环可以使用for循环、while循环等。 3.5 支持模板的复用和组合EJS支持模板的复用和组合，可以使用模板继承和包含功能来重用和组合模板。模板继承允许创建一个基础模板，并在其基础上定义子模板，从而实现模板的层次化管理。模板包含允许将多个模板组合在一起，以便构建更复杂的页面。 四、EJS性能优化技巧4.1 缓存编译后的模板为了提高性能，可以将编译后的模板缓存起来，避免重复编译。这样，在每次渲染时就可以直接使用缓存中的编译结果，减少了编译的开销。 4.2 减少嵌套和重复渲染过多的嵌套和重复的渲染操作会增加模板的复杂度和渲染的时间。为了提高性能，应尽量减少模板的嵌套和重复渲染。 4.3 合理使用局部变量和全局变量在模板中使用局部变量可以提高访问变量的效率。而过多的全局变量可能会导致命名冲突和性能下降，因此应该合理使用全局变量。 4.4 异步加载和渲染对于大型页面或需要从后端加载数据的页面，可以考虑使用异步加载和渲染技术。这样可以提高页面的响应速度，并充分利用浏览器的并行加载能力。 4.5 其他性能优化建议除了以上几点，还可以通过压缩HTML、CSS和JavaScript代码，减少网络传输大小；使用CDN加速静态资源的加载；优化数据库查询和数据处理等方式来提高页面的性能。 五、案例分析：实战中使用EJS5.1 使用EJS构建静态网页EJS可以用于构建静态的网页，只需将数据绑定到模板中，然后将渲染后的HTML保存到文件中即可。 1234567891011const ejs = require(&#x27;ejs&#x27;);const fs = require(&#x27;fs&#x27;);const template = fs.readFileSync(&#x27;template.ejs&#x27;, &#x27;utf8&#x27;);const data = &#123; title: &#x27;My Website&#x27;, content: &#x27;Welcome to my website!&#x27;&#125;;const html = ejs.render(template, data);fs.writeFileSync(&#x27;index.html&#x27;, html, &#x27;utf8&#x27;); 5.2 使用EJS构建动态网页EJS也可以用于构建动态的网页，只需将数据绑定到模板中，然后将渲染后的HTML发送给客户端即可。 1234567891011121314151617const express = require(&#x27;express&#x27;);const ejs = require(&#x27;ejs&#x27;);const app = express();app.set(&#x27;view engine&#x27;, &#x27;ejs&#x27;);app.get(&#x27;/&#x27;, (req, res) =&gt; &#123; const data = &#123; title: &#x27;Home&#x27;, content: &#x27;Welcome to my website!&#x27; &#125;; res.render(&#x27;index&#x27;, data);&#125;);app.listen(3000, () =&gt; &#123; console.log(&#x27;Server is running on port 3000&#x27;);&#125;); 5.3 使用EJS与后端数据交互EJS可以与后端数据进行交互，通过模板中的变量和表达式来显示和处理后端传递的数据。 123456789// 后端 Node.js 代码（示例使用Express框架）app.get(&#x27;/users&#x27;, (req, res) =&gt; &#123; const users = [ &#123; name: &#x27;Alice&#x27;, age: 25 &#125;, &#123; name: &#x27;Bob&#x27;, age: 30 &#125;, &#123; name: &#x27;Charlie&#x27;, age: 35 &#125; ]; res.render(&#x27;users&#x27;, &#123; users &#125;);&#125;); 123456&lt;!-- 前端EJS模板代码 --&gt;&lt;ul&gt;&lt;% users.forEach(user =&gt; &#123; %&gt; &lt;li&gt;&lt;%= user.name %&gt; (age &lt;%= user.age %&gt;)&lt;/li&gt;&lt;% &#125;) %&gt;&lt;/ul&gt; 通过安装和配置EJS，我们可以使用它的基本语法和标签来实现数据绑定和逻辑控制，同时还能利用其核心特性和性能优化技巧来构建灵活、高效的网页应用。通过案例分析，展示了EJS在实战中的应用场景，包括构建静态网页、动态网页以及与后端数据交互。 六、EJS的局限性和其他模板引擎的比较6.1 EJS的局限性虽然EJS是一种简单而灵活的模板引擎，但它也存在一些局限性。以下是一些常见的EJS局限性： 学习曲线：对于新手来说，学习使用EJS可能需要一定的时间和经验积累，特别是对于不熟悉JavaScript语法和模板引擎概念的开发者。 性能：相对于其他一些高性能的模板引擎，EJS的性能可能稍低。特别是在大规模数据渲染和复杂逻辑处理方面，可能需要进行一些性能优化。 安全性：由于EJS允许执行嵌入的JavaScript代码，因此需要特别注意输入的数据的安全性，以避免潜在的安全风险，如XSS（跨站脚本攻击）等问题。 6.2 其他模板引擎的比较除了EJS，还有其他许多流行的模板引擎可供选择。以下是一些与EJS相比的其他模板引擎，并对它们进行了简要比较： Handlebars：Handlebars是一种基于Mustache模板语法的模板引擎，语法简洁易懂。相比EJS，Handlebars更强调模板的可读性和易维护性。 Jade&#x2F;Pug：Jade（现称为Pug）是一种使用缩进和无闭合标签的模板引擎，具有简洁的语法和强大的表达能力。相对于EJS，Jade&#x2F;Pug的模板文件通常更加精简和优雅。 Nunjucks：Nunjucks是一种基于Jinja2模板引擎的JavaScript模板引擎，具有灵活和强大的功能，支持模板继承、宏等高级特性。 React&#x2F;Vue：React和Vue是基于组件化开发的前端框架，它们提供了自己的模板语法和渲染机制，具有更高的性能和更好的交互体验。 这些模板引擎各有特点，适用于不同的场景和需求。选择合适的模板引擎需要根据项目要求、开发经验和个人偏好进行权衡。 七、小结一下本文详细介绍了EJS模板引擎的背景、特性和使用方法。我们了解了EJS的起源和设计思想，学习了EJS的基本语法和标签，并深入探讨了其核心特性，如嵌入JavaScript代码、变量绑定、条件判断和模板继承等。此外，我们还介绍了EJS的性能优化技巧，以帮助提高页面的加载速度和渲染效率。最后，通过实战案例的分析，展示了EJS在静态网页、动态网页和后端数据交互中的应用。 使用EJS可以方便地构建具有动态内容的网页，灵活处理数据和逻辑操作，并与后端进行交互。然而，开发者在选择模板引擎时需要综合考虑不同的因素，如学习曲线、性能要求和项目需求。 希望本文对您理解和使用EJS模板引擎有所帮助。如果你以后有机会使用它，欢迎共同学习进步深度挖掘。","tags":["模板引擎","ejs"]},{"title":"Nginx配置入门教程","path":"/2024/03/08/Nginx配置入门教程/","content":"nginx 入门教程nginx 配置详解nginx 重写规则配置Nginx 正向代理和反向代理详解 - 简书总结 nginx 中的 location 配置Nginx 的 location 匹配规则 Nginx 简介产生背景在互联网产业远没有现在这么红火的时候，每个网站或者应用所需要支持的并发量不需要太大，所以最开始的服务器是 Apache，它对高并发并不支持，所以它不是高性能的 Web 服务器，因为并发量上万之后，会导致服务器消耗大量内存，操作系统对其进行进程或线程间的切换也会消耗大量的 CPU 资源，导致 Http 请求的平均响应速度降低。 但是现在的互联网流量已经远远不是当时所能想象的，所以迫切需要一种高性能的，稳定的 Web 服务器。于是 Nginx 诞生了。 主要优点 开源免费 事件驱动Nginx 使用基于事件驱动架构，使得其可以支持数以百万级别的 TCP 连接 跨平台Nginx 是一个跨平台服务器，可以运行在 Linxu，Windows，MacOS 等主流的操作系统中 高性能并且稳定 应用场景 web 服务器 反向代理 负载均衡服务器 邮件代理服务器 Nginx 的配置 配置示例 123456789101112131415161718192021222324user nobody nobody;worker_processes 2;err_log logs/error.log notice;pid logs/nginx.pid;events &#123; use epoll; worker_connections 1000; # 每个nginx进程的最大连接数&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 60; # 长连接的超时时间 server &#123; listen 88; server_name localhost; location / &#123; root /usr/var/html; &#125; &#125;&#125; 配置信息分为4个层级 （全局 &#x2F; http &#x2F; server &#x2F; location） 全局设置：设置一些影响 Nginx 服务器整体运行的配置指令，比如工作进程数、运行的身份等； events 块：设置影响 Nginx 服务器与用户的网络连接，比如连接超时时间，是否开启对多 work process 的支持等 http 块：可以嵌套多个 server 块，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置； server 块：配置虚拟主机的相关参数，一个 http 中可以有多个 server location 块：配置请求的路由，以及各种页面的处理情况 其他常见配置： upstream：配置负载均衡，设置一系列的后端服务器 location 块URL 地址匹配是进行 Nginx 配置中最灵活的部分。 location 支持正则表达式匹配，也支持条件判断匹配，用户可以通过 location 指令实现 Nginx 对动、静态网页进行过滤处理。使用 location URL 匹配配置还可以实现反向代理，用于实现 PHP 动态解析或者负载负载均衡。 alias 与 root 的区别 root 配置根目录，在根目录中查找 $document_uri 对应的文件 $request_filename = $document_root + $document_uri alias 配置别名目录，在别名目录中查找 $document_uri - 匹配路径 对应的文件 12345678910111213141516location /blogs &#123; root /home/jie; autoindex on;&#125;# 定位文件时， rootValue 作为前缀添加到 $document_uri 前面# curl localhost/blogs/a.html -&gt; /home/jie/blogs/a.html# curl localhost/blogshi/a.html 也会匹配到 -&gt; /home/jie/blogshi/a.htmllocation /comics &#123; alias /home/pan/manhua; autoindex on;&#125;# 定位文件时，aliasValue 替换 $document_uri 中与 locationValue 匹配的部分# aliasValue 替代 /comics# curl localhost/comics/hi.html -&gt; /home/pan/manhua/hi.html location 配置示例多条 location 配置当前 $document_uri 时，会采用权重最高的匹配 （_精确匹配 &gt; 开始位置正则匹配 &gt; 普通正则匹配 &gt; 普通匹配 &gt; 最长字符串匹配_） 1234567891011121314151617181920212223242526272829303132333435363738394041424344# 普通匹配：普通 location，无任何前缀符号# $document_uri 开始位置匹配location /blogs &#123; root /home/jie; # 会在root下查找blogs目录，所以要先新建blogs文件夹 autoindex on;&#125;# curl localhost/blogs 显示文件列表# curl localhost/lastyear/blogs 即使root下有对应目录也不会匹配到 `location /blogs`只匹配url以`/blogs`开头的情况# 精确匹配：带 = 号前缀符号的严格匹配location = /comics &#123; alias /home/pan/manhua; autoindex on;&#125;# 正则匹配location ~ ^.+\\.txt$ &#123; root /home/pan; # 注意 指令都需要分号结尾&#125;# curl localhost/docs/hello.txt 会查找 /home/pan/docs/hello.txt# curl localhost/documents/a.jpg -&gt; 会匹配 configuration E# 以 /documents/ 开头这个专指度比较低，所以会继续查找 正则匹配 规则location /documents/ &#123; # matches any query beginning with /documents/ and continues searching, # so regular expressions will be checked. This will be matched only if # regular expressions don&#x27;t find a match. [ configuration C ]&#125;# 开始位置正则匹配location ^~ /images/ &#123; # matches any query beginning with /images/ and halts searching, # so regular expressions will not be checked. [ configuration D ]&#125;# 不区分大小写正则匹配location ~* \\.(gif|jpg|jpeg)$ &#123; # matches any request ending in gif, jpg, or jpeg. However, all # requests to the /images/ directory will be handled by # Configuration D. [ configuration E ]&#125; location 匹配优先级：location [=|~|~*|^~] /uri/ &#123; … &#125; = 精确匹配 ^~ 开始位置正则匹配（区分大小写） ~ 正则匹配（区分大小写） ~* 不区分大小写的正则匹配 !~ 和 !~* 正则不匹配(区分&#x2F;不区分 大小写) 不用在 location 后面 / 通用匹配，任何请求都会匹配到。 首先匹配 =，其次匹配 ^~ , 其次是按文件中顺序的正则匹配，最后是交给 / 通用匹配。当有匹配成功时候，停止匹配，按当前匹配规则处理请求。 12345678910111213141516171819202122232425262728293031323334# http://localhost/ 将匹配规则Alocation = / &#123; # 规则A&#125;# http://localhost/login 将匹配规则Blocation = /login &#123; # 规则B&#125;# http://localhost/static/a.html 将匹配规则Clocation ^~ /static/ &#123; # 规则C&#125;location ~ \\.(gif|jpg|png|js|css)$ &#123; # 规则D&#125;# http://localhost/a.PNG 则匹配规则Elocation ~* \\.png$ &#123; # 规则E&#125;# http://localhost/a.XHTML 不确定是否有效?location !~ \\.xhtml$ &#123; # 规则F&#125;location !~* \\.xhtml$ &#123; # 规则G&#125;# http://localhost/category/id/1111location / &#123; # 规则H proxy_pass http://tomcat:8080/&#125; rewrite 重写请求重写请求 uri 的简单例子 123456789server &#123; listen 80; server_name comic.bilibili.com; index index.html index.php; root html; if ($http_host !~ &quot;^comic\\.bilibili\\.com$&quot;) &#123; rewrite ^(.*) http://comic.bilibili.com$1 redirect; &#125;&#125; 重写请求防盗链 123456location ~* \\.(gif|jpg|swf)$ &#123; valid_referers none blocked comic.bilibili.com *.comic.bilibili.com; if ($invalid_referer) &#123; rewrite ^/ http://$host/logo.png; &#125;&#125; last 基本上都用这个 Flag。 break 中止 Rewirte，不再继续匹配 permanent 返回永久重定向的 HTTP 状态 301 redirect 返回临时重定向的 HTTP 状态 302 last 和 break 关键字的区别 last 和 break 当出现在 location 之外时，两者的作用是一致的没有任何差异 last 和 break 当出现在 location 内部时： last 使用了 last 指令，rewrite 后会跳出 location 作用域，用 rewrite 的结果重新开始再走一次刚才的行为 break 使用了 break 指令，rewrite 后不会跳出 location 作用域，它的生命也在这个 location 中终结 permanent 和 redirect 关键字的区别 permanent 永久性重定向，请求日志中的状态码为 301 redirect 临时重定向，请求日志中的状态码为 302 判断表达式 -f 和 !-f 用来判断是否存在文件 -d 和 !-d 用来判断是否存在目录 -e 和 !-e 用来判断是否存在文件或目录 -x 和 !-x 用来判断文件是否可执行 根据文件类型设置过期时间 123456location ~* \\.(js|css|jpg|jpeg|gif|png|swf)$ &#123; if (-f $request_filename) &#123; expires 1h; break; &#125;&#125; 禁止访问某些文件类型 1234location ~* \\.(txt|doc)$&#123; root /data/www/wwwroot/linuxtone/test; deny all;&#125; 全局变量 $args $content_length $content_type $document_root $document_uri $host $query $http_origin $http_user_agent $http_cookie $limit_rate $request_body_file $request_method $request_uri $request_filename $remote_addr $remote_port $remote_user 常用的全局变量 12345678# 例：http://localhost:88/test1/test2/test.php$host：localhost$server_port：88$request_uri：http://localhost:88/test1/test2/test.php$document_uri：/test1/test2/test.php$document_root：D: ginx/html$request_filename：D: ginx/html/test1/test2/test.php 负载均衡负载均衡的 5 种策略 负载均衡的5种策略nginx 的 upstream 目前支持的 5 种方式的分配 普通轮询每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除。 1234upstream backserver &#123; server 192.168.0.14; server 192.168.0.15;&#125; 加权轮询指定轮询几率，weight 和访问比率成正比，用于后端服务器性能不均的情况。 12345upstream backserver &#123; server 192.168.0.14 weight=10; server 192.168.0.15 weight=10;&#125; IP HASHIP 绑定 ip_hash, 每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器，可以解决 session 的问题。 12345upstream backserver &#123; server 192.168.0.14:88; server 192.168.0.15:80; ip_hash;&#125; 公平轮询公平轮询(fair)按后端服务器的响应时间来分配请求，响应时间短的优先分配。 12345upstream backserver &#123; server 192.168.0.14:88; server 192.168.0.15:80; fair;&#125; URL HASH按访问 url 的 hash 结果来分配请求，使每个 url 定向到同一个后端服务器，后端服务器为缓存时比较有用。 123456upstream backserver &#123; server squid1:3128; server squid2:3128; hash $request_uri; hash_method crc32;&#125; 负责均衡示例123456789101112131415161718192021222324252627# 在需要使用负载均衡的server中增加events &#123; # todo&#125;http &#123; upstream backserver&#123; ip_hash; server 127.0.0.1:9090 down; # (down 表示当前的server暂时不参与负载) server 127.0.0.1:8080 weight=2; # (weight 默认为1.weight越大，负载的权重就越大) server 127.0.0.1:6060; server 127.0.0.1:7070 backup; # (其它所有的非backup机器down或者忙的时候，请求backup机器) &#125; server &#123; listen 88; server_name localhost; proxy_pass http://backserver/; location / &#123; root html; autoindex on; &#125; &#125;&#125; 反向代理在 nginx 中配置 proxy_pass 代理转发时： proxyPassValue 是路径$document_uri - locationValue 追加到路径后面，得到最终转发的目标路径 proxyPassValue 是域名$document_uri 追加到域名后面，得到最终转发的目标路径 假设下面四种情况分别用 http://192.168.1.1/proxy/test.html 进行访问。 转发到域名第1种（相对于第2种，最后少一个 &#x2F; ） 123location /proxy/ &#123; proxy_pass http://127.0.0.1; # 转发目标是域名&#125; 代理到 URL：http://127.0.0.1/proxy/test.html 转发到路径第2种： 123location /proxy/ &#123; proxy_pass http://127.0.0.1/; # 转发目标是路径&#125; 代理到 URL：http://127.0.0.1/test.html 第3种： 123location /proxy/ &#123; proxy_pass http://127.0.0.1/aaa/; # 转发目标是路径&#125; 代理到 URL：http://127.0.0.1/aaa/test.html 第4种（相对于第三种，最后少一个 &#x2F; ） 123location /proxy/ &#123; proxy_pass http://127.0.0.1/aaa; # 转发目标是路径&#125; 代理到 URL：http://127.0.0.1/aaatest.html","tags":["Nginx"],"categories":["Nginx"]},{"title":"Grid布局详解","path":"/2024/03/07/Grid布局详解/","content":"原文地址最强大的 CSS 布局 —— Grid 布局 - 掘金 Grid 布局是什么？Grid 布局即网格布局，是一种新的 CSS 布局模型，比较擅长将一个页面划分为几个主要区域，以及定义这些区域的大小、位置、层次等关系。号称是最强大的的 CSS 布局方案，是目前唯一一种 CSS 二维布局。利用 Grid 布局，我们可以轻松实现类似下图布局，演示地址 Grid 布局和 flex 布局讲到布局，我们就会想到 flex 布局，甚至有人认为竟然有 flex 布局了，似乎没有必要去了解 Grid 布局。但 flex 布局和 Grid 布局有实质的区别，那就是 flex 布局是一维布局，Grid 布局是二维布局。flex 布局一次只能处理一个维度上的元素布局，一行或者一列。Grid 布局是将容器划分成了“行”和“列”，产生了一个个的网格，我们可以将网格元素放在与这些行和列相关的位置上，从而达到我们布局的目的。 Grid 布局远比 flex 布局强大！ flex 布局示例: Grid 布局示例： Grid 的一些基础概念我们使用 Grid 实现一个小例子，演示 Grid 的一些基础概念，演示地址 12345678&lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;one item&quot;&gt;One&lt;/div&gt; &lt;div class=&quot;two item&quot;&gt;Two&lt;/div&gt; &lt;div class=&quot;three item&quot;&gt;Three&lt;/div&gt; &lt;div class=&quot;four item&quot;&gt;Four&lt;/div&gt; &lt;div class=&quot;five item&quot;&gt;Five&lt;/div&gt; &lt;div class=&quot;six item&quot;&gt;Six&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334.wrapper &#123; margin: 60px; /* 声明一个容器 */ display: grid; /* 声明列的宽度 */ grid-template-columns: repeat(3, 200px); /* 声明行间距和列间距 */ grid-gap: 20px; /* 声明行的高度 */ grid-template-rows: 100px 200px;&#125;.one &#123; background: #19caad;&#125;.two &#123; background: #8cc7b5;&#125;.three &#123; background: #d1ba74;&#125;.four &#123; background: #bee7e9;&#125;.five &#123; background: #e6ceac;&#125;.six &#123; background: #ecad9e;&#125;.item &#123; text-align: center; font-size: 200%; color: #fff;&#125; 容器和项目：我们通过在元素上声明 display：grid 或 display：inline-grid 来创建一个网格容器。一旦我们这样做，这个元素的所有直系子元素将成为网格项目。比如上面 .wrapper 所在的元素为一个网格容器，其直系子元素将成为网格项目。 网格轨道：grid-template-columns 和 grid-template-rows 属性来定义网格中的行和列。容器内部的水平区域称为行，垂直区域称为列。上图中 One、Two、Three 组成了一行，One、Four 则是一列 网格单元：一个网格单元是在一个网格元素中最小的单位， 从概念上来讲其实它和表格的一个单元格很像。上图中 One、Two、Three、Four…都是一个个的网格单元 网格线：划分网格的线，称为”网格线”。应该注意的是，当我们定义网格时，我们定义的是网格轨道，而不是网格线。Grid 会为我们创建编号的网格线来让我们来定位每一个网格元素。m 列有 m + 1 根垂直的网格线，n 行有 n + 1 跟水平网格线。比如上图示例中就有 4 根垂直网格线。一般而言，是从左到右，从上到下，1，2，3 进行编号排序。当然也可以从右到左，从下到上，按照 -1，-2，-3…顺序进行编号排序 容器属性介绍Grid 布局相关的属性以及值众多，需要记忆的不少，建议可以跟 demo 一起结合起来，边敲代码边理解，再利用一些空闲时间记忆一下。笔者会在介绍每个属性的时候，做个小 demo 演示，建议大家可以自己修改看看效果加深记忆 Grid 布局属性可以分为两大类，一类是容器属性，一类是项目属性。我们先来看容器属性 display 属性display 属性演示 我们通过在元素上声明 display：grid 或 display：inline-grid 来创建一个网格容器。声明 display：grid 则该容器是一个块级元素，设置成 display: inline-grid 则容器元素为行内元素 123.wrapper &#123; display: grid;&#125; 123.wrapper-1 &#123; display: inline-grid;&#125; grid-template-columns 属性和 grid-template-rows 属性grid-template-columns 和 grid-template-rows 属性演示地址 grid-template-columns 属性设置列宽，grid-template-rows 属性设置行高，这两个属性在 Grid 布局中尤为重要，它们的值是有多种多样的，而且它们的设置是比较相似的，下面针对 grid-template-columns 属性进行讲解 固定的列宽和行高 12345678.wrapper &#123; display: grid; /* 声明了三列，宽度分别为 200px 100px 200px */ grid-template-columns: 200px 100px 200px; grid-gap: 5px; /* 声明了两行，行高分别为 50px 50px */ grid-template-rows: 50px 50px;&#125; 以上表示固定列宽为 200px 100px 200px，行高为 50px 50px repeat() 函数：可以简化重复的值。该函数接受两个参数，第一个参数是重复的次数，第二个参数是所要重复的值。比如上面行高都是一样的，我们可以这么去实现，实际效果是一模一样的 1234567.wrapper-1 &#123; display: grid; grid-template-columns: 200px 100px 200px; grid-gap: 5px; /* 2行，而且行高都为 50px */ grid-template-rows: repeat(2, 50px);&#125; auto-fill 关键字：表示自动填充，让一行（或者一列）中尽可能的容纳更多的单元格。grid-template-columns: repeat(auto-fill, 200px) 表示列宽是 200 px，但列的数量是不固定的，只要浏览器能够容纳得下，就可以放置元素，代码以及效果如下图所示： 123456.wrapper-2 &#123; display: grid; grid-template-columns: repeat(auto-fill, 200px); grid-gap: 5px; grid-auto-rows: 50px;&#125; fr 关键字：Grid 布局还引入了一个另外的长度单位来帮助我们创建灵活的网格轨道。fr 单位代表网格容器中可用空间的一等份。grid-template-columns: 200px 1fr 2fr 表示第一个列宽设置为 200px，后面剩余的宽度分为两部分，宽度分别为剩余宽度的 1&#x2F;3 和 2&#x2F;3。代码以及效果如下图所示： 123456.wrapper-3 &#123; display: grid; grid-template-columns: 200px 1fr 2fr; grid-gap: 5px; grid-auto-rows: 50px;&#125; minmax() 函数：我们有时候想给网格元素一个最小和最大的尺寸，minmax() 函数产生一个长度范围，表示长度就在这个范围之中都可以应用到网格项目中。它接受两个参数，分别为最小值和最大值。grid-template-columns: 1fr 1fr minmax(300px, 2fr) 的意思是，第三个列宽最少也是要 300px，但是最大不能大于第一第二列宽的两倍。代码以及效果如下： 123456.wrapper-4 &#123; display: grid; grid-template-columns: 1fr 1fr minmax(300px, 2fr); grid-gap: 5px; grid-auto-rows: 50px;&#125; auto 关键字：由浏览器决定长度。通过 auto 关键字，我们可以轻易实现三列或者两列布局。grid-template-columns: 100px auto 100px 表示第一第三列为 100px，中间由浏览器决定长度，代码以及效果如下： 123456.wrapper-5 &#123; display: grid; grid-template-columns: 100px auto 100px; grid-gap: 5px; grid-auto-rows: 50px;&#125; grid-row-gap 属性、grid-column-gap 属性以及 grid-gap 属性grid-row-gap 属性、grid-column-gap 属性以及 grid-gap 属性演示地址 grid-row-gap 属性、grid-column-gap 属性分别设置行间距和列间距。 grid-gap 属性是两者的简写形式。 grid-row-gap: 10px 表示行间距是 10px，grid-column-gap: 20px 表示列间距是 20px。grid-gap: 10px 20px 实现的效果是一样的 123456.wrapper &#123; display: grid; grid-template-columns: 200px 100px 100px; grid-gap: 10px 20px; grid-auto-rows: 50px;&#125; 1234567.wrapper-1 &#123; display: grid; grid-template-columns: 200px 100px 100px; grid-auto-rows: 50px; grid-row-gap: 10px; grid-column-gap: 20px;&#125; 以上两种写法效果是一样的。 grid-template-areas 属性grid-area 以及 grid-template-areas 演示地址 grid-template-areas 属性用于定义区域，一个区域由一个或者多个单元格组成 一般这个属性跟网格元素的 grid-area 一起使用，我们在这里一起介绍。 grid-area 属性指定项目放在哪一个区域 12345678910.wrapper &#123; display: grid; grid-gap: 10px; grid-template-columns: 120px 120px 120px; grid-template-areas: &quot;. header header&quot; &quot;sidebar content content&quot;; background-color: #fff; color: #444;&#125; 上面代码表示划分出 6 个单元格，其中值得注意的是 . 符号代表空的单元格，也就是没有用到该单元格。 1234567891011.sidebar &#123; grid-area: sidebar;&#125;.content &#123; grid-area: content;&#125;.header &#123; grid-area: header;&#125; 以上代码表示将类 .sidebar .content .header所在的元素放在上面 grid-template-areas 中定义的 sidebar content header 区域中 grid-auto-flow 属性grid-auto-flow 属性演示地址 grid-auto-flow 属性控制着自动布局算法怎样运作，精确指定在网格中被自动布局的元素怎样排列。默认的放置顺序是”先行后列”，即先填满第一行，再开始放入第二行，即下图英文数字的顺序 one,two,three…。这个顺序由 grid-auto-flow 属性决定，默认值是 row。 1234567.wrapper &#123; display: grid; grid-template-columns: 100px 200px 100px; grid-auto-flow: row; grid-gap: 5px; grid-auto-rows: 50px;&#125; 细心的同学可能发现了一个问题，就是第五个项目和第六个项目之间有个空白（如下图所示），这个是由于第六块的长度大于了空白处的长度，被挤到了下一行导致的。在实际应用中，我们可能想让下面长度合适的填满这个空白，这个时候可以设置 grid-auto-flow: row dense，表示尽可能填满表格。代码以及效果如下所示： 1234567.wrapper-2 &#123; display: grid; grid-template-columns: 100px 200px 100px; grid-auto-flow: row dense; grid-gap: 5px; grid-auto-rows: 50px;&#125; 可以设置 grid-auto-flow: column，表示先列后行，代码以及效果如下图所示： 1234567.wrapper-1 &#123; display: grid; grid-auto-columns: 100px; grid-auto-flow: column; grid-gap: 5px; grid-template-rows: 50px 50px;&#125; justify-items 属性、align-items 属性以及 place-items 属性justify-items 属性、align-items 属性演示地址 justify-items 属性设置单元格内容的水平位置（左中右），align-items 属性设置单元格的垂直位置（上中下） 下面以 justify-items 属性为例进行讲解，align-items 属性同理，只是方向为垂直方向。它们都有如下属性： 1234.container &#123; justify-items: start | end | center | stretch; align-items: start | end | center | stretch;&#125; 其代码实现以及效果如下： 12345678910111213141516171819.wrapper,.wrapper-1,.wrapper-2,.wrapper-3 &#123; display: grid; grid-template-columns: 100px 200px 100px; grid-gap: 5px; grid-auto-rows: 50px; justify-items: start;&#125;.wrapper-1 &#123; justify-items: end;&#125;.wrapper-2 &#123; justify-items: center;&#125;.wrapper-3 &#123; justify-items: stretch;&#125; start：对齐单元格的起始边缘 end：对齐单元格的结束边缘 center：单元格内部居中 stretch：拉伸，占满单元格的整个宽度（默认值） justify-content 属性、align-content 属性以及 place-content 属性justify-content 属性、align-content 属性演示地址 justify-content 属性是整个内容区域在容器里面的水平位置（左中右），align-content 属性是整个内容区域的垂直位置（上中下）。它们都有如下的属性值。 123456.container &#123; justify-content: start | end | center | stretch | space-around | space-between | space-evenly; align-content: start | end | center | stretch | space-around | space-between | space-evenly;&#125; 下面以 justify-content 属性为例进行讲解，align-content 属性同理，只是方向为垂直方向 start - 对齐容器的起始边框 end - 对齐容器的结束边框 center - 容器内部居中 12345678910111213141516171819.wrapper,.wrapper-1,.wrapper-2,.wrapper-3,.wrapper-4,.wrapper-5,.wrapper-6 &#123; display: grid; grid-template-columns: 100px 200px 100px; grid-gap: 5px; grid-auto-rows: 50px; justify-content: start;&#125;.wrapper-1 &#123; justify-content: end;&#125;.wrapper-2 &#123; justify-content: center;&#125; space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍 space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔 space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔 stretch - 项目大小没有指定时，拉伸占据整个网格容器 123456789101112.wrapper-3 &#123; justify-content: space-around;&#125;.wrapper-4 &#123; justify-content: space-between;&#125;.wrapper-5 &#123; justify-content: space-evenly;&#125;.wrapper-6 &#123; justify-content: stretch;&#125; grid-auto-columns 属性和 grid-auto-rows 属性grid-auto-columns 属性和 grid-auto-rows 属性演示地址 在讲 grid-auto-columns 属性和 grid-auto-rows 属性之前，先来看看隐式和显示网格的概念 隐式和显示网格：显式网格包含了你在 grid-template-columns 和 grid-template-rows 属性中定义的行和列。如果你在网格定义之外又放了一些东西，或者因为内容的数量而需要的更多网格轨道的时候，网格将会在隐式网格中创建行和列 假如有多余的网格（也就是上面提到的隐式网格），那么它的行高和列宽可以根据 grid-auto-columns 属性和 grid-auto-rows 属性设置。它们的写法和 grid-template-columns 和 grid-template-rows 完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高 12345678.wrapper &#123; display: grid; grid-template-columns: 200px 100px; /* 只设置了两行，但实际的数量会超出两行，超出的行高会以 grid-auto-rows 算 */ grid-template-rows: 100px 100px; grid-gap: 10px 20px; grid-auto-rows: 50px;&#125; grid-template-columns 属性和 grid-template-rows 属性只是指定了两行两列，但实际有九个元素，就会产生隐式网格。通过 grid-auto-rows 可以指定隐式网格的行高为 50px 项目属性介绍grid-column-start 属性、grid-column-end 属性、grid-row-start 属性以及 grid-row-end 属性演示地址 可以指定网格项目所在的四个边框，分别定位在哪根网格线，从而指定项目的位置 grid-column-start 属性：左边框所在的垂直网格线 grid-column-end 属性：右边框所在的垂直网格线 grid-row-start 属性：上边框所在的水平网格线 grid-row-end 属性：下边框所在的水平网格线 12345678910111213141516171819202122232425262728293031323334353637383940414243444546.wrapper &#123; display: grid; grid-template-columns: repeat(3, 1fr); grid-gap: 20px; grid-auto-rows: minmax(100px, auto);&#125;.one &#123; grid-column-start: 1; grid-column-end: 2; background: #19caad;&#125;.two &#123; grid-column-start: 2; grid-column-end: 4; grid-row-start: 1; grid-row-end: 2; /* 如果有重叠，就使用 z-index */ z-index: 1; background: #8cc7b5;&#125;.three &#123; grid-column-start: 3; grid-column-end: 4; grid-row-start: 1; grid-row-end: 4; background: #d1ba74;&#125;.four &#123; grid-column-start: 1; grid-column-end: 2; grid-row-start: 2; grid-row-end: 5; background: #bee7e9;&#125;.five &#123; grid-column-start: 2; grid-column-end: 2; grid-row-start: 2; grid-row-end: 5; background: #e6ceac;&#125;.six &#123; grid-column: 3; grid-row: 4; background: #ecad9e;&#125; 上面代码中，类 .two 所在的网格项目，垂直网格线是从 2 到 4，水平网格线是从 1 到 2。其中它跟 .three （垂直网格线是从 3 到 4，水平网格线是从 1 到 4） 是有冲突的。可以设置 z-index 去决定它们的层级关系 grid-area 属性grid-area 属性指定项目放在哪一个区域，在上面介绍 grid-template-areas 的时候有提到过，这里不再具体展开，具体的使用可以参考演示地址： grid-area 以及 grid-template-areas 属性演示地址 justify-self 属性、align-self 属性以及 place-self 属性justify-self 属性&#x2F; align-self 属性&#x2F; place-self 属性演示地址 justify-self 属性设置单元格内容的水平位置（左中右），跟 justify-items 属性的用法完全一致，但只作用于单个项目 align-self 属性设置单元格内容的垂直位置（上中下），跟 align-items 属性的用法完全一致，也是只作用于单个项目 两者很相像，这里只拿 justify-self 属性演示，align-self 属性同理，只是作用于垂直方向 1234.item &#123; justify-self: start | end | center | stretch; align-self: start | end | center | stretch;&#125; 123456789101112.item &#123; justify-self: start;&#125;.item-1 &#123; justify-self: end;&#125;.item-2 &#123; justify-self: center;&#125;.item-3 &#123; justify-self: stretch;&#125; start：对齐单元格的起始边缘 end：对齐单元格的结束边缘 center：单元格内部居中 stretch：拉伸，占满单元格的整个宽度（默认值） Grid 实战——实现响应式布局经过上面的介绍，相信大家都可以看出，Grid 是非常强大的。一些常见的 CSS 布局，如居中，两列布局，三列布局等等是很容易实现的。我们接下来看看 Grid 布局是如何实现响应式布局的 fr 实现等分响应式fr 实现等分响应式 fr 等分单位，可以将容器的可用空间分成想要的多个等分空间。利用这个特性，我们能够轻易实现一个等分响应式。grid-template-columns: 1fr 1fr 1fr 表示容器分为三等分 1234567.wrapper &#123; margin: 50px; display: grid; grid-template-columns: 1fr 1fr 1fr; grid-gap: 10px 20px; grid-auto-rows: 50px;&#125; repeat + auto-fit——固定列宽，改变列数量等分布局并不只有 Grid 布局才有，像 flex 布局也能轻松实现，接下来看看更高级的响应式 上面例子的始终都是三列的，但是需求往往希望我们的网格能够固定列宽，并根据容器的宽度来改变列的数量。这个时候，我们可以用到上面提到 repeat() 函数以及 auto-fit 关键字。grid-template-columns: repeat(auto-fit, 200px) 表示固定列宽为 200px，数量是自适应的，只要容纳得下，就会往上排列，代码以及效果实现如下： 演示地址 1234567.wrapper &#123; margin: 50px; display: grid; grid-template-columns: repeat(auto-fit, 200px); grid-gap: 10px 20px; grid-auto-rows: 50px;&#125; repeat+auto-fit+minmax 去掉右侧空白上面看到的效果中，右侧通常会留下空白，这是我们不希望看到的。如果列的宽度也能在某个范围内自适应就好了。minmax() 函数就帮助我们做到了这点。将 grid-template-columns: repeat(auto-fit, 200px) 改成 grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)) 表示列宽至少 200px，如果还有空余则一起等分。代码以及效果如下所示： 演示地址 1234567.wrapper &#123; margin: 50px; display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); grid-gap: 10px 20px; grid-auto-rows: 50px;&#125; repeat+auto-fit+minmax-span-dense 解决空缺问题似乎一切进行得很顺利，但是某天 UI 来说，每个网格元素的长度可能不相同，这也简单，通过 span 关键字进行设置网格项目的跨度，grid-column-start: span 3，表示这个网格项目跨度为 3。具体的代码与效果如下所示： 123.item-3 &#123; grid-column-start: span 3;&#125; 演示地址 不对，怎么右侧又有空白了？原来是有一些长度太长了，放不下，这个时候就到我们的 dense 关键字出场了。grid-auto-flow: row dense 表示尽可能填充，而不留空白，代码以及效果如下所示： 123456789101112.wrapper,.wrapper-1 &#123; margin: 50px; display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); grid-gap: 10px 20px; grid-auto-rows: 50px;&#125;.wrapper-1 &#123; grid-auto-flow: row dense;&#125; Grid 布局兼容性最后，聊聊 Grid 布局兼容性问题，在 caniuse 中，我们可以看到的结果如下，总体兼容性还不错，但在 IE 10 以下不支持。个人建议在公司的内部系统运用起来是没有问题的，但 TOC 的话，可能目前还是不太合适 参考常见的 Grid 布局用例 CSS Grid 网格布局教程 Grid 布局草案 一行 CSS 代码实现响应式布局 – 使用 Grid 实现的响应式布局 MDN","tags":["CSS","Grid"],"categories":["CSS"]},{"title":"PNPM初级教程和实践","path":"/2024/03/05/Pnpm初级教程和实践/","content":"workspace初始化 monorepo 项目结构1234567891011121314151617181920# 创建root projectmkdir mono-projectcd mono-projectpnpm init# 创建 workspace 配置文件# pnpm-workspace.yamlpackages: - &quot;examples/*&quot; - &quot;shares/*&quot;mkdir -p examples/appmkdir -p shares/down-clicd examples/apppnpm initcd shares/down-clipnpm init 配置子项目的package.json文件, app 依赖 down-cli app&#x2F;package.json 配置如下 12345678910&#123; &quot;name&quot;: &quot;app&quot;, &quot;scripts&quot;: &#123; &quot;down&quot;: &quot;down --help&quot;, &quot;hi&quot;: &quot;echo app hello&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;down-cli&quot;: &quot;workspace:*&quot; &#125;&#125; down-cli&#x2F;package.json 配置如下: 123456789&#123; &quot;name&quot;: &quot;down-cli&quot;, &quot;scripts&quot;: &#123; &quot;hi&quot;: &quot;echo down hello&quot; &#125;, &quot;bin&quot;: &#123; &quot;down&quot;: &quot;bin/index.js&quot; &#125;&#125; down-cli&#x2F;bin&#x2F;index.js 12#!/usr/bin/env nodeconsole.log(&quot;down command starting..&quot;); 安装依赖在 root project 下面执行 pnpm i, pnpm 会自动安装依赖，子项目间的相互依赖会 link 到对应项目的 node_modules 文件夹下. 比如, 以上的项目结构，app/node_modules/down-cli 会软链接到 down-cli/bin/index.js 执行子项目的命令配置 root project 的 npm scripts 执行指定子项目的命令 mono-project/package.json 12345678&#123; &quot;name&quot;: &quot;mono-project&quot;, &quot;scripts&quot;: &#123; &quot;app-hi&quot;: &quot;pnpm run --filter app hi&quot;, &quot;app-hi2&quot;: &quot;pnpm run --filter ./examples/* hi&quot;, &quot;down&quot;: &quot;pnpm --filter app down&quot; &#125;&#125; 更多 --filter 参数的用法可查帮助信息 pnpm help run 在 root project 下执行, pnpm down 可测试子项目的命令，实现脚本工具(down-cli)的开发调试 在 root project 下，按照指定子项目的依赖: pnpm add lodash --filter app 同理，发布某个子工程对应的 package, pnpm publish --filter app or pnpm publish --F app","tags":["pnpm","monorepo"]},{"title":"前端脚手架开发指南","path":"/2024/03/01/前端脚手架开发指南/","content":"你会学到什么其实脚手架并不实现，难的是最佳实践的整理和沉淀。本文不会涉及到最佳实践方面的内容，只是教会你如何实现一个最基础的脚手架，以此作为展示最佳实践的载体。 因为是手把手教妹子写脚手架，所以本文很详细，字数很多，大概有 3 万字左右，读完你会学到： 如何搭建一个脚手架的工程 如何开发和调试一个脚手架 脚手架中如何接收和处理命令参数 脚手架中如何和用户交互 脚手架中如何拷贝一个文件夹或文件 脚手架中如何动态生成一个文件 脚手架中如何处理路径问题 脚手架中如何自动安装模板所需依赖 本文中所有代码已经上传到 GitHub。 1、搭建一个 monorepo 风格的脚手架工程1.1、如何用 Node.js 运行 js 为了避免 Node.js 版本差异导致奇怪的问题，建议安装 16 以上版本的 Node.js 。 随便找个地方建个一个 index.js 文件，并在该文件中添加如下代码： 1console.log(&quot;Welcome to Mortal World&quot;); 在该文件的地址栏上输出 cmd 打开命令行窗口，输入 node index.js 命令，回车运行该命令。 可以在命令行窗口中看到打印了 Welcome to Mortals World。 1.2、声明自己的命令如果你熟悉 Vue , 肯定对 vue-cli 这个脚手架有一定了解，比如运行 vue create myapp 命令来创建一个 Vue 工程。 如果我们没有运行 npm install -g vue-cli 安装 vue-cli 脚手架，在命令行窗口中直接运行 vue create myapp，会报错，报错如下图所示： 可见 vue 不是系统命令， vue 只是 vue-cli 脚手架声明的一个命令。 那怎么给脚手架声明一个命令，其实非常简单，跟我来操作。 随便找个地方创建 mortal-cli 的文件夹，进入该文件夹后，在其地址栏上输出 cmd 打开命令行窗口， 运行 npm init 命令来初始化一个脚手架工程，运行成功后，会在该文件夹中生成一个 pakeage.json 文件。 我们在 pakeage.json 中添加 bin 字段，来声明一个命令，添加后的代码如下所示： 1234567891011121314&#123; &quot;name&quot;: &quot;mortal-cli&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;bin&quot;: &#123; &quot;mortal&quot;: &quot;./bin/index.js&quot; &#125;&#125; 这样我们就声明了一个 mortal 的命令，另外 ./bin/index.js 是运行 mortal 命令后会运行的 js 文件的相对路径。 接着我们在 mortal-cli 的文件夹中创建一个 bin 文件夹，在 bin 文件夹中创建一个 index.js 文件，并在该文件中添加如下代码： 123#!/usr/bin/env nodeconsole.log(&quot;Welcome to Mortal World&quot;); 注意在文件头部添加 #!/usr/bin/env node，否则运行后会报错！！！ 这样就完成了一个最基础的脚手架工程，接下来在命令行窗口输入 mortal 命令，运行该命令。 会发现，还是报错，提示 mortal 命令不是系统命令，当然不是声明命令的方法错误。 假如你把这个脚手架发布到 npm 上后。由于 mortal-cli&#x2F;pakeage.json 中 name 的值为 mortal-cli，所以我们运行 npm install -g mortal-cli 将脚手架安装到本地后，再运行 mortal 命令，就会发现运行成功。 在实际开发脚手架过程中不可能这么做，所以我们还要实现本地调试脚手架的能力，实现起来也非常简单，一个命令搞定。 这个命令就是 npm link，哈哈想不到吧，在这里就不讲述其原理，如果你们需要的话，可以留言，我开个单章讲述一下。 输入 npm link 命令运行后，再输入 mortal 命令，回车运行，看到的结果如下图所示。 到此，我们成功的声明了一个 mortal 命令。 1.3、npm link 的弊端使用 npm link 来实现本地调试有一个弊端。比如在本地有多个版本的脚手架仓库，在仓库 A 中修改代码后，运行 mortal 命令后，发现更改的代码不生效。这是因为已经在仓库 B 的脚手架工程中运行 npm link，导致我们在运行 mortal 命令后是执行仓库 B 中的代码，在仓库 A 中修改代码能生效才怪。要先在仓库 B 的脚手架工程中运行 npm unlink 后，然后在仓库 A 中的脚手架工程中运行 npm link 后，修改仓库 A 中的代码才能生效。 为了解决这个弊端，我们使用 pnpm 来搭建 monorepo 风格的脚手架工程。 在 monorepo 风格的工程中可以含有多个子工程，且每个子工程都可以独立编译打包后将产物发成 npm 包，故又称 monorepo 为多包工程。 由于脚手架发布到 npm 上的包名为 mortal-cli ，修改调试子工程的 package.json 文件中的代码，代码修改部分如下所示： 12345678&#123; &quot;scripts&quot;: &#123; &quot;mortal&quot;: &quot;mortal --help&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;mortal-cli&quot;: &quot;workspace:*&quot; &#125;&#125; 注意，在 dependencies 字段中声明 mortal-cli 依赖包的版本，要用workspace:* 来定义，而不是具体版本号来定义。 在 pnpm 中使用 workspace: 协议定义某个依赖包版本号时，pnpm 将只解析存在工作空间内的依赖包，不会去下载解析 npm 上的依赖包。 把 mortal-cli 依赖包引入，执行 pnpm i 安装依赖，其效果就跟执行 npm install -g mortal-cli一样，只不过不是全局安装而已，只在调试子工程内安装 mortal-cli 脚手架。然后调试子工程就直接引用脚手架子工程本地编译打包后的产物，而不是发布到 npm 上的产物，彻底做到本地调试。 另外脚手架子工程和调试子工程是在同一个工程中，这样就做一对一的调试，从而解决了使用 npm link 来实现本地调试的弊端。 同时在 scripts 定义了脚本命令，在调试工程中执行 pnpm mortal 既是执行了 mortal 命令，不用脚手架工程中执行 npm link 就可以运行 mortal 命令。 1.4、monorepo 风格的脚手架工程下面开始使用 pnpm 搭建 monorepo 风格的脚手架工程，首先在命令行窗口中输入以下代码，执行安装 pnpm 。 1iwr https://get.pnpm.io/install.ps1 -useb | iex 然后重新找个地方创建 mortal 文件夹，进入该文件夹后，在其地址栏上输出 cmd 打开命令行窗口。 输入 pnpm init 初始化工程，pnpm 是使用 workspace (工作空间) 来搭建一个 monorepo 风格的工程。 所以我们要 mortal 文件夹中创建 pnpm-workspace.yaml 工作空间配置文件，并在该文件中添加如下配置代码。 1packages: -&quot;packages/*&quot; - &quot;examples/*&quot;; 配置后，声明了 packages 和 examples 文件夹中子工程是同属一个工作空间的，工作空间中的子工程编译打包的产物都可以被其它子工程引用。 在 packages 文件夹中新建 mortal-cli 文件夹，在其地址栏上输出 cmd 打开命令行窗口。 输入 pnpm init 命令，执行来初始化一个工程，执行成功后，会在该文件夹中生成一个 pakeage.json 文件。 我们在 pakeage.json 中添加 bin 字段，来声明 mortal 命令，添加后的代码如下所示： 1234567891011121314&#123; &quot;name&quot;: &quot;mortal-cli&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;bin&quot;: &#123; &quot;mortal&quot;: &quot;./bin/index.js&quot; &#125;&#125; 在 packages&#x2F;mortal-cli 文件夹中新建 bin 文件夹，在 bin 文件夹中新建 index.js 文件，并在该文件中添加如下代码： 123#!/usr/bin/env nodeconsole.log(&quot;Welcome to Mortal World&quot;); 在 examples 文件夹中新建 app 文件夹，在其地址栏上输出 cmd 打开命令行窗口， 运行 pnpm init 命令来初始化一个工程，运行成功后，会在该文件夹中生成一个 pakeage.json 文件。 我们在 pakeage.json 中添加 dependencies 字段，来添加 mortal-cli 依赖。再给 scripts 增加一条自定义脚本命令。添加后的代码如下所示： 1234567891011121314&#123; &quot;name&quot;: &quot;app&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;mortal&quot;: &quot;mortal&quot; &#125;, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: &#123; &quot;mortal-cli&quot;: &quot;workspace:*&quot; &#125;&#125; 然后在最外层根目录下运行 pnpm i 命令，安装依赖。安装成功后，在 app 文件夹目录下运行 pnpm mortal，会发现命令行窗口打印出 Welcome to Mortal World，说明你的 monorepo 风格的脚手架工程的搭建成功了。 此时整个工程的目录结构如下所示 123456789101112|-- mortal|-- package.json|-- pnpm-lock.yaml|-- pnpm-workspace.yaml|-- examples| |-- app| |-- package.json|-- packages|-- mortal-cli|-- package.json|-- bin|-- index.js 1.5、脚手架必备的模块一个最简单的脚手架包含以下几个模块。 命令参数模块 用户交互模块 文件拷贝模块 动态文件生成模块 自动安装依赖模块 下面我们来一一将他们实现。 2、命令参数模块2.1、获取命令参数Node.js 中的 process 模块提供了当前 Node.js 进程相关的全局环境信息，比如命令参数、环境变量、命令运行路径等等。 123const process = require(&quot;process&quot;);// 获取命令参数console.log(process.argv); 脚手架提供的 mortal 命令后面还可以设置参数，标准的脚手架命令参数需要支持两种格式，比如： 12mortal --name=orderPagemortal --name orderPage 如果通过 process.argv 来获取，要额外处理两种不同的命令参数格式，不方便。 这里推荐 yargs 开源库来解析命令参数。运行以下命令安装 yargs： 1pnpm add yargs --F mortal-cli pnpm add 是 pnpm 中安装依赖包的命令， --F mortal-cli，是指定依赖安装到 mortal-cli 子工程中。 这里要注意，mortal-cli 是取 mortal-cli 子工程中 package.json 中 name 字段的值，而不是 mortal-cli 子工程文件夹的名称。 yargs 的使用非常简单，其提供的 argv 属性是对两个格式的命令参数的处理结果。 在 bin&#x2F;index.js 添加如下代码： 1234#!/usr/bin/env nodeconst yargs = require(&quot;yargs&quot;);console.log(&quot;name&quot;, yargs.argv.name); 注意，以上代码是在 Node.js 环境中运行，Node.js 的模块是遵循 CommonJS 规范的，如果要依赖一个模块，要使用 Node.js 内置 require 系统函数引用模块使用。 在 app 文件夹目录下运行 pnpm mortal -- --name=orderPage ， 注意，在 pnpm mortal 后面需要加上两个连字符（–），这是为了告诉 pnpm 后面的参数是传递给命令mortal 本身的，而不是传递给 pnpm 的。 结果如下图所示： 可以通过 yargs.argv.name 获取命令参数 name 的值。 2.2、设置子命令假如脚手架要对外提供多个功能，不能将所有的功能都集中在 mortal 命令中实现。 可以通过 yargs 提供的 command 方法来设置一些子命令，让每个子命令对应各自功能，各司其职。 yargs.command 的用法是 **yargs.command(cmd, desc, builder, handler)**。 cmd：字符串，子命令名称，也可以传递数组，如 [&#39;create&#39;, &#39;c&#39;]，表示子命令叫 create，其别名是 c； desc：字符串，子命令描述信息； builder：一个返回数组的函数，子命令参数信息配置，比如可以设置参数： alias：别名； demand：是否必填； default：默认值； describe：描述信息； type：参数类型，string | boolean | number。 handler: 函数，可以在这个函数中专门处理该子命令参数。 下面我们来设置一个用来生成一个模板的子命令，把这个子命令命名为create。 修改在 bin&#x2F;index.js 文件中的代码，如下所示： 123456789101112131415161718#!/usr/bin/env nodeconst yargs = require(&quot;yargs&quot;);yargs.command( [&quot;create&quot;, &quot;c&quot;], &quot;新建一个模板&quot;, function (yargs) &#123; return yargs.option(&quot;name&quot;, &#123; alias: &quot;n&quot;, demand: true, describe: &quot;模板名称&quot;, type: &quot;string&quot;, &#125;); &#125;, function (argv) &#123; console.log(&quot;argv&quot;, argv); &#125;).argv; 在 app 文件夹目录下分别运行 pnpm mortal create -- --name=orderPage 和 pnpm mortal c -- --name=orderPage 命令，执行结果如下图所示： 在上面我们配置了子命令 create 的参数 name 的一些参数信息。那这些要怎么展示给用户看呢？其实只要我们输入子命令的参数有错误，就会在命令行窗口中显示这些参数信息。 在 app 文件夹目录下运行 pnpm mortal c -- --abc 命令，执行结果如下图所示： 到此为止，我们最简单地实现了脚手架和用户之间的交互能力，但是如果自定义参数过多，那么命令行参数的交互方法对于用户来说是非常不友好的。所以我们还要实现一个用户交互模块，如何实现请看下一小节。 3、用户交互模块我认为比较好的用户交互方式是讯问式的交互，比如我们在运行 npm init，通过询问式的交互完成 package.json 文件内容的填充。 这里推荐使用 inquirer 开源库来实现询问式的交互，运行以下命令安装 inquirer： 1pnpm add inquirer@8.2.5 --F mortal-cli 为了使用 require 引入 inquirer ，要使用 8.2.5 版本的 inquirer。 这里我们主要使用了 inquirer 开源库的三个方面的能力： 询问用户问题 获取并解析用户的输入 检测用户的答案是否合法 主要通过 inquirer.prompt() 来实现。prompt 函数接收一个数组，数组的每一项都是一个询问项，询问项有很多配置参数，下面是常用的配置项。 type：提问的类型，常用的有 输入框：input； 确认：confirm； 单选组：list； 多选组：checkbox； name：存储当前问题答案的变量； message：问题的描述； default：默认值； choices：列表选项，在某些type下可用； validate：对用户的答案进行校验； filter：对用户的答案进行过滤处理，返回处理后的值。 比如我们创建一个模板文件，大概会询问用户：模板文件名称、模板类型、使用什么框架开发、使用框架对应的哪个组件库开发等等。下面我们来实现这个功能。 在 bin 文件夹中新建 inquirer.js 文件夹，在里面添加如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293const inquirer = require(&quot;inquirer&quot;);function inquirerPrompt(argv) &#123; const &#123; name &#125; = argv; return new Promise((resolve, reject) =&gt; &#123; inquirer .prompt([ &#123; type: &quot;input&quot;, name: &quot;name&quot;, message: &quot;模板名称&quot;, default: name, validate: function (val) &#123; if (!/^[a-zA-Z]+$/.test(val)) &#123; return &quot;模板名称只能含有英文&quot;; &#125; if (!/^[A-Z]/.test(val)) &#123; return &quot;模板名称首字母必须大写&quot;; &#125; return true; &#125;, &#125;, &#123; type: &quot;list&quot;, name: &quot;type&quot;, message: &quot;模板类型&quot;, choices: [&quot;表单&quot;, &quot;动态表单&quot;, &quot;嵌套表单&quot;], filter: function (value) &#123; return &#123; 表单: &quot;form&quot;, 动态表单: &quot;dynamicForm&quot;, 嵌套表单: &quot;nestedForm&quot;, &#125;[value]; &#125;, &#125;, &#123; type: &quot;list&quot;, message: &quot;使用什么框架开发&quot;, choices: [&quot;react&quot;, &quot;vue&quot;], name: &quot;frame&quot;, &#125;, ]) .then((answers) =&gt; &#123; const &#123; frame &#125; = answers; if (frame === &quot;react&quot;) &#123; inquirer .prompt([ &#123; type: &quot;list&quot;, message: &quot;使用什么UI组件库开发&quot;, choices: [&quot;Ant Design&quot;], name: &quot;library&quot;, &#125;, ]) .then((answers1) =&gt; &#123; resolve(&#123; ...answers, ...answers1, &#125;); &#125;) .catch((error) =&gt; &#123; reject(error); &#125;); &#125; if (frame === &quot;vue&quot;) &#123; inquirer .prompt([ &#123; type: &quot;list&quot;, message: &quot;使用什么UI组件库开发&quot;, choices: [&quot;Element&quot;], name: &quot;library&quot;, &#125;, ]) .then((answers2) =&gt; &#123; resolve(&#123; ...answers, ...answers2, &#125;); &#125;) .catch((error) =&gt; &#123; reject(error); &#125;); &#125; &#125;) .catch((error) =&gt; &#123; reject(error); &#125;); &#125;);&#125;exports.inquirerPrompt = inquirerPrompt; 其中 inquirer.prompt() 返回的是一个 Promise，我们可以用 then 获取上个询问的答案，根据答案再发起对应的内容。 在 bin&#x2F;index.js 中引入 inquirerPrompt 。 12345678910111213141516171819202122#!/usr/bin/env nodeconst yargs = require(&quot;yargs&quot;);const &#123; inquirerPrompt &#125; = require(&quot;./inquirer&quot;);yargs.command( [&quot;create&quot;, &quot;c&quot;], &quot;新建一个模板&quot;, function (yargs) &#123; return yargs.option(&quot;name&quot;, &#123; alias: &quot;n&quot;, demand: true, describe: &quot;模板名称&quot;, type: &quot;string&quot;, &#125;); &#125;, function (argv) &#123; inquirerPrompt(argv).then((answers) =&gt; &#123; console.log(answers); &#125;); &#125;).argv; 在 app 文件夹目录下运行 pnpm mortal c -- --n Input 命令，执行结果如下图所示： 可以很清楚地看到“在使用什么框架开发”的询问中回答不同，下一个“使用什么 UI 组件库的开发”的询问可选项不一样。 回答完成后，可以在下图中清楚地看到答案格式 4、文件夹拷贝模块要生成一个模板文件，最简单的做法就是执行脚手架提供的命令后，把脚手架中的模板文件，拷贝到对应的地方。模板文件可以是单个文件，也可以是一个文件夹。本小节先介绍一下模板文件是文件夹时候如何拷贝。 在 Node.js 中拷贝文件夹并不简单，需要用到递归，这里推荐使用开源库copy-dir来实现拷贝文件。 运行以下命令安装 copy-dir 。 1pnpm add copy-dir --F mortal-cli 在 bin 文件夹中新建 copy.js 文件，在里面添加如下代码： 12345678910111213const copydir = require(&quot;copy-dir&quot;);const fs = require(&quot;fs&quot;);function copyDir(from, to, options) &#123; copydir.sync(from, to, options);&#125;function checkMkdirExists(path) &#123; return fs.existsSync(path);&#125;exports.checkMkdirExists = checkMkdirExists;exports.copyDir = copyDir; copyDir 方法实现非常简单，难的是如何使用，下面创建一个场景来介绍一下如何使用。 我们在 bin 文件夹中新建 template 文件夹，用来存放模板文件，比如在 template 文件夹中创建一个 form 文件夹来存放表单模板，这里不介绍表单模板的内容，我们随意在 form 文件夹中创建一个 _index.js_，在里面随便写些内容。其目录结构如下所示： 1234567891011121314151617|-- mortal|-- package.json|-- pnpm-lock.yaml|-- pnpm-workspace.yaml|-- examples| |-- app| |-- package.json|-- packages|-- mortal|-- package.json|-- bin|-- template|-- form|-- index.js|-- copy.js|-- index.js|-- inquirer.js 下面来实现把 packages&#x2F;mortal&#x2F;bin&#x2F;template&#x2F;form 这个文件夹拷贝到 examples&#x2F;app&#x2F;src&#x2F;pages&#x2F;OrderPage 中 。 在 bin&#x2F;index.js 修改代码，修改后的代码如下所示： 1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/env nodeconst yargs = require(&quot;yargs&quot;);const path = require(&quot;path&quot;);const &#123; inquirerPrompt &#125; = require(&quot;./inquirer&quot;);const &#123; copyDir, checkMkdirExists &#125; = require(&quot;./copy&quot;);yargs.command( [&quot;create&quot;, &quot;c&quot;], &quot;新建一个模板&quot;, function (yargs) &#123; return yargs.option(&quot;name&quot;, &#123; alias: &quot;n&quot;, demand: true, describe: &quot;模板名称&quot;, type: &quot;string&quot;, &#125;); &#125;, function (argv) &#123; inquirerPrompt(argv).then((answers) =&gt; &#123; const &#123; name, type &#125; = answers; const isMkdirExists = checkMkdirExists( path.resolve(process.cwd(), `./src/pages/$&#123;name&#125;`) ); if (isMkdirExists) &#123; console.log(`$&#123;name&#125;文件夹已经存在`); &#125; else &#123; copyDir( path.resolve(__dirname, `./template/$&#123;type&#125;`), path.resolve(process.cwd(), `./src/pages/$&#123;name&#125;`) ); &#125; &#125;); &#125;).argv; 使用拷贝文件方法 copyDir 的难点是参数 from 和 to 的赋值。其中 from 表示要拷贝文件的路径，to 表示要把文件拷贝到那里的路径。这里的路径最好使用绝对路径，因为在 Node.js 中使用相对路径会出现一系列奇奇怪怪的问题。 4.1、脚手架中的路径处理我们可以用 Node.js 中的 path 模块提供的 path.resolve( [from…], to ) 方法将路径转成绝对路径，就是将参数 to 拼接成一个绝对路径，[from … ] 为选填项，可以设置多个路径，如 path.resolve(&#39;./aaa&#39;, &#39;./bbb&#39;, &#39;./ccc&#39;) ，使用时要注意path.resolve 的路径拼接规则： 从后向前拼接路径； 若 to 以 / 开头，不会拼接到前面的路径； 若 to 以 ../ 开头，拼接前面的路径，且不含最后一节路径； 若 to 以 ./ 开头或者没有符号，则拼接前面路径。 从以上拼接规则来看，使用 path.resolve 时，要特别注意参数 to 的设置。 下面来介绍一下，使用 copyDir 方法时，参数如何设置： 将 copyDir 的参数 from 设置为 path.resolve(__dirname, `./template/$&#123;type&#125;`)， 其中 __dirname 是用来动态获取当前文件模块所属目录的绝对路径。比如在 bin&#x2F;index.js 文件中使用 __dirname ，__dirname 表示就是 bin&#x2F;index.js 文件所属目录的绝对路径 D:\\mortal\\packages\\mortal-cli\\bin。 因为模板文件存放在 bin&#x2F;template 文件夹中 ，copyDir 是在 bin&#x2F;index.js 中使用，bin&#x2F;template 文件夹相对 bin&#x2F;index.js 文件的路径是 ./template，所以把 path.resolve 的参数 to 设置为 ./template/$&#123;type&#125;，其中 type 是用户所选的模板类型。 假设 type 的模板类型是 form，那么 path.resolve(__dirname, `./template/form`) 得到的绝对路径是 D:\\mortal\\packages\\mortal-cli\\bin\\template\\form。 将 copyDir 的参数 to 设置为 path.resolve(process.cwd(), `$&#123;name&#125;`)， 其中 process.cwd() 当前 Node.js 进程执行时的文件所属目录的绝对路径。比如在 bin 文件夹目录下运行 node index.js 时，process.cwd() 得到的是 D:\\mortal\\packages\\mortal-cli\\bin。 运行 node index.js 相当运行 mortal 命令。而在现代前端工程中都是在 package.json 文件中scripts 定义了脚本命令，如下所示： 1234567891011121314&#123; &quot;name&quot;: &quot;app&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;mortal&quot;: &quot;mortal&quot; &#125;, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: &#123; &quot;mortal-cli&quot;: &quot;workspace:*&quot; &#125;&#125; 运行 pnpm mortal 就相当运行 mortal 命令，那么执行 pnpm mortal 时，当前 Node.js 进程执行时的文件是 package.json 文件。那么 process.cwd() 得到的是 D:\\mortal\\examples\\app。 因为要把 packages&#x2F;mortal&#x2F;bin&#x2F;template&#x2F;form 这个文件夹拷贝到 examples&#x2F;app&#x2F;src&#x2F;pages&#x2F;OrderPage 中，且 process.cwd() 的值是D:\\mortal\\examples\\app，src&#x2F;pages 文件夹相对 examples&#x2F;app 的路径是 ./src/pages ，所以把 path.resolve 的参数 to 设置为 ./src/pages/$&#123;name&#125;，其中 name 是用户所输入的模板名称。 4.2、目录守卫在 app 文件夹目录下运行 pnpm mortal create -- --name=OrderPage，看能不能成功得把 packages&#x2F;mortal&#x2F;bin&#x2F;template&#x2F;form 这个文件夹拷贝到 examples&#x2F;app&#x2F;src&#x2F;pages&#x2F;OrderPage 中。 报错了，提示 examples&#x2F;app&#x2F;src&#x2F;pages 文件夹不存在。为了防止这种报错出现，我们要实现一个目录守护的方法 mkdirGuard ，比如 examples&#x2F;app&#x2F;src&#x2F;pages 文件夹不存在，就创建一个 examples&#x2F;app&#x2F;src&#x2F;pages 文件夹。 在 bin&#x2F;copy.js 文件中，修改代码，如下所示： 1234567891011121314151617181920212223242526272829303132const copydir = require(&quot;copy-dir&quot;);const fs = require(&quot;fs&quot;);const path = require(&quot;path&quot;);function mkdirGuard(target) &#123; try &#123; fs.mkdirSync(target, &#123; recursive: true &#125;); &#125; catch (e) &#123; mkdirp(target); function mkdirp(dir) &#123; if (fs.existsSync(dir)) &#123; return true; &#125; const dirname = path.dirname(dir); mkdirp(dirname); fs.mkdirSync(dir); &#125; &#125;&#125;function copyDir(form, to, options) &#123; mkdirGuard(to); copydir.sync(form, to, options);&#125;function checkMkdirExists(path) &#123; return fs.existsSync(path);&#125;exports.checkMkdirExists = checkMkdirExists;exports.mkdirGuard = mkdirGuard;exports.copyDir = copyDir; fs.mkdirSync 的语法格式：fs.mkdirSync(path[, options])，创建文件夹目录。 path：文件夹目录路径； options：recursive 表示是否要创建父目录，true 要。 fs.existsSync 的语法格式：fs.existsSync(pach)，检测目录是否存在，如果目录存在返回 true ，如果目录不存在返回false。 path：文件夹目录路径。 path.dirname 的语法格式：path.dirname(path)，用于获取给定路径的目录名。 path：文件路径。 在 mkdirGuard 方法内部，当要创建的目录 target 父级目录不存在时，调用fs.mkdirSync(target)，会报错走 catch 部分逻辑，在其中递归创建父级目录，使用 fs.existsSync(dir) 来判断父级目录是否存在，来终止递归。这里要特别注意 fs.mkdirSync(dir) 创建父级目录要在 mkdirp(dirname) 之前调用，才能形成一个正确的创建顺序，否则创建父级目录过程会因父级目录的父级目录不存在报错。 我们再次在 app 文件夹目录下运行 pnpm mortal create -- --name=OrderPage，看这次能不能成功得把 packages&#x2F;mortal&#x2F;bin&#x2F;template&#x2F;form 这个文件夹拷贝到 examples&#x2F;app&#x2F;src&#x2F;pages&#x2F;OrderPage 中。 成功添加，添加结果如下所示： 然后再运行 pnpm mortal create -- --name=OrderPage 命令，会发现控制台打印出模板已经存在在提示。 这是为了防止用户修改后的模板文件，运行命令后被重新覆盖到初始状态。所以我们引入一个校验模板文件是否存在的 checkMkdirExists 方法，内部采用 fs.existsSync 来实现。 5、文件拷贝模块文件拷贝分三步来实现，使用 fs.readFileSync 读取被拷贝的文件内容，然后创建一个文件，再使用 fs.writeFileSync 写入文件内容。 在 bin&#x2F;copy.js 文件，在里面添加如下代码： 12345678910function copyFile(from, to) &#123; const buffer = fs.readFileSync(from); const parentPath = path.dirname(to); mkdirGuard(parentPath); fs.writeFileSync(to, buffer);&#125;exports.copyFile = copyFile; 接下来我们使用 copyFile 方法，在 bin&#x2F;index.js 修改代码，修改后的代码如下所示： 1234567891011121314151617181920212223242526272829303132333435363738#!/usr/bin/env nodeconst yargs = require(&quot;yargs&quot;);const path = require(&quot;path&quot;);const &#123; inquirerPrompt &#125; = require(&quot;./inquirer&quot;);const &#123; copyDir &#125; = require(&quot;./copy&quot;);yargs.command( [&quot;create&quot;, &quot;c&quot;], &quot;新建一个模板&quot;, function (yargs) &#123; return yargs.option(&quot;name&quot;, &#123; alias: &quot;n&quot;, demand: true, describe: &quot;模板名称&quot;, type: &quot;string&quot;, &#125;); &#125;, function (argv) &#123; inquirerPrompt(argv).then((answers) =&gt; &#123; const &#123; name, type &#125; = answers; const isMkdirExists = checkMkdirExists( path.resolve(process.cwd(), `./src/pages/$&#123;name&#125;/index.js`) ); if (isMkdirExists) &#123; console.log(`$&#123;name&#125;/index.js文件已经存在`); &#125; else &#123; copyFile( path.resolve(__dirname, `./template/$&#123;type&#125;/index.js`), path.resolve(process.cwd(), `./src/pages/$&#123;name&#125;/index.js`), &#123; name, &#125; ); &#125; &#125;); &#125;).argv; copyFile 和 copyDir 使用的区别在参数，copyFile 要求参数 from 和参数 to 都精确到文件路径。 在 app 文件夹目录下运行 pnpm mortal create -- --name=OrderPage，执行结果如下图所示： 6、动态文件生成模块假设脚手架中提供的模板文件中某些信息需要根据用户输入的命令参数来动态生成对应的模板文件。 比如下面模板文件中 App 要动态替换成用户输入的命令参数 name 的值，该如何实现呢？ 12345import React from &quot;react&quot;;const App = () =&gt; &#123; return &lt;div&gt;&lt;/div&gt;;&#125;;export default App; 这里推荐使用开源库mustache来实现，运行以下命令安装 copy-dir 。 1pnpm add mustache --F mortal-cli 我们在 packages&#x2F;mortal-cli&#x2F;bin&#x2F;template&#x2F;form 文件夹中创建一个 index.tpl 文件，内容如下： 1234567import React from &#x27;react&#x27;;const &#123;&#123;name&#125;&#125; = () =&gt; &#123; return ( &lt;div&gt;&lt;/div&gt; );&#125;;export default &#123;&#123;name&#125;&#125;; 先写一个 readTemplate 方法来读取这个 index.tpl 动态模板文件内容。在 bin&#x2F;copy.js 文件，在里面添加如下代码： 12345678const Mustache = require(&quot;mustache&quot;);function readTemplate(path, data = &#123;&#125;) &#123; const str = fs.readFileSync(path, &#123; encoding: &quot;utf8&quot; &#125;); return Mustache.render(str, data);&#125;exports.readTemplate = readTemplate; readTemplate 方法接收两个参数，path 动态模板文件的相对路径，data 动态模板文件的配置数据。 使用 Mustache.render(str, data) 生成模板文件内容返回，因为 Mustache.render 的第一个参数类型是个字符串，所以在调用 fs.readFileSync 时要指定 encoding 类型为 utf8，否则 fs.readFileSync 返回 Buffer 类型数据。 在写一个 copyTemplate 方法来拷贝模板文件到对应的地方，跟 copyFile 方法非常相似。在 bin&#x2F;copy.js 文件，在里面添加如下代码： 12345678function copyTemplate(from, to, data = &#123;&#125;) &#123; if (path.extname(from) !== &quot;.tpl&quot;) &#123; return copyFile(from, to); &#125; const parentToPath = path.dirname(to); mkdirGuard(parentToPath); fs.writeFileSync(to, readTemplate(from, data));&#125; path.extname(from) 返回文件扩展名，比如 path.extname(index.tpl) 返回 .tpl。 在 bin&#x2F;index.js 修改代码，修改后的代码如下所示： 1234567891011121314151617181920212223242526272829303132333435363738#!/usr/bin/env nodeconst yargs = require(&quot;yargs&quot;);const path = require(&quot;path&quot;);const &#123; inquirerPrompt &#125; = require(&quot;./inquirer&quot;);const &#123; copyTemplate &#125; = require(&quot;./copy&quot;);yargs.command( [&quot;create&quot;, &quot;c&quot;], &quot;新建一个模板&quot;, function (yargs) &#123; return yargs.option(&quot;name&quot;, &#123; alias: &quot;n&quot;, demand: true, describe: &quot;模板名称&quot;, type: &quot;string&quot;, &#125;); &#125;, function (argv) &#123; inquirerPrompt(argv).then((answers) =&gt; &#123; const &#123; name, type &#125; = answers; const isMkdirExists = checkMkdirExists( path.resolve(process.cwd(), `./src/pages/$&#123;name&#125;/index.js`) ); if (isMkdirExists) &#123; console.log(`$&#123;name&#125;/index.js文件已经存在`); &#125; else &#123; copyTemplate( path.resolve(__dirname, `./template/$&#123;type&#125;/index.tpl`), path.resolve(process.cwd(), `./src/pages/$&#123;name&#125;/index.js`), &#123; name, &#125; ); &#125; &#125;); &#125;).argv; 在 app 文件夹目录下运行 pnpm mortal create -- --name=OrderPage，执行结果如下图所示： 6.1、mustache 简介以上的案例是 mustache 最简单的使用，下面来额外介绍一些常用的使用场景。 首先来熟悉一下 mustache 的语法，下面来介绍一些场景来使用这些语法 &#123;&#123;key&#125;&#125; &#123;&#123;#key&#125;&#125; &#123;&#123;/key&#125;&#125; &#123;&#123;^key&#125;&#125; &#123;&#123;/key&#125;&#125; &#123;&#123;.&#125;&#125; &#123;&#123;&key&#125;&#125; 6.1.1、简单绑定使用 &#123;&#123;key&#125;&#125; 语法，key 要和 Mustache.render 方法中的第二个参数（一个对象）的属性名一致。 例如： 1Mustache.render(&quot;&lt;span&gt;&#123;&#123;name&#125;&#125;&lt;/span&gt;&quot;, &#123; name: &quot;张三&quot; &#125;); 输出： 1&lt;span&gt;张三&lt;/span&gt; 6.1.2、绑定子属性例如： 1Mustache.render(&quot;&lt;span&gt;&#123;&#123;ifno.name&#125;&#125;&lt;/span&gt;&quot;, &#123; ifno: &#123; name: &quot;张三&quot; &#125; &#125;); 输出： 1&lt;span&gt;张三&lt;/span&gt; 6.1.3、循环渲染如果 key 属性值是一个数组，则可以使用 &#123;&#123;#key&#125;&#125; &#123;&#123;/key&#125;&#125; 语法来循环展示。 其中 &#123;&#123;#&#125;&#125; 标记表示从该标记以后的内容全部都要循环展示，&#123;&#123;/&#125;&#125;标记表示循环结束。 例如： 123Mustache.render(&quot;&lt;span&gt;&#123;&#123;#list&#125;&#125;&#123;&#123;name&#125;&#125;&#123;&#123;/list&#125;&#125;&lt;/span&gt;&quot;, &#123; list: [&#123; name: &quot;张三&quot; &#125;, &#123; name: &quot;李四&quot; &#125;, &#123; name: &quot;王五&quot; &#125;],&#125;); 输出： 1&lt;span&gt;张三李四王五&lt;/span&gt; 如果 list 的值是 [&#39;张三&#39;,&#39;李四&#39;,&#39;王五&#39;]，要把 &#123;&#123;name&#125;&#125; 替换成 &#123;&#123;.&#125;&#125; 才可以渲染。 123Mustache.render(&quot;&lt;span&gt;&#123;&#123;#list&#125;&#125;&#123;&#123;.&#125;&#125;&#123;&#123;/list&#125;&#125;&lt;/span&gt;&quot;, &#123; list: [&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;],&#125;); 6.1.4、循环中二次处理数据Mustache.render 方法中的第二个参数是个对象，其属性值可以是一个函数，渲染时候会执行函数输出返回值，函数中可以用 this 获取第二个参数的上下文。 例如： 123456Mustache.render(&quot;&lt;span&gt;&#123;&#123;#list&#125;&#125;&#123;&#123;info&#125;&#125;&#123;&#123;/list&#125;&#125;&lt;/span&gt;&quot;, &#123; list: [&#123; name: &quot;张三&quot; &#125;, &#123; name: &quot;李四&quot; &#125;, &#123; name: &quot;王五&quot; &#125;], info() &#123; return this.name + &quot;,&quot;; &#125;,&#125;); 输出： 1&lt;span&gt;张三,李四,王五,&lt;/span&gt; 6.1.5、条件渲染使用 &#123;&#123;#key&#125;&#125; &#123;&#123;/key&#125;&#125; 语法 和 &#123;&#123;^key&#125;&#125; &#123;&#123;/key&#125;&#125; 语法来实现条件渲染，当 key 为 false、0、[]、&#123;&#125;、null，既是 key == false 为真，&#123;&#123;#key&#125;&#125; &#123;&#123;/key&#125;&#125; 包裹的内容不渲染，&#123;&#123;^key&#125;&#125; &#123;&#123;/key&#125;&#125; 包裹的内容渲染 例如： 123Mustache.render(&quot;&lt;span&gt;&#123;&#123;#show&#125;&#125;显示&#123;&#123;/show&#125;&#125;&#123;&#123;^show&#125;&#125;隐藏&#123;&#123;/show&#125;&#125;&lt;/span&gt;&quot;, &#123; show: false,&#125;); 输出： 1&lt;span&gt;隐藏&lt;/span&gt; 6.1.6、不转义 HTML 标签使用 &#123;&#123;&key&#125;&#125; 语法来实现。 例如： 123Mustache.render(&quot;&lt;span&gt;&#123;&#123;&amp;key&#125;&#125;&lt;/span&gt;&quot;, &#123; key: &quot;&lt;span&gt;标题&lt;/span&gt;&quot;,&#125;); 输出： 1&lt;span&gt;&lt;span&gt;标题&lt;/span&gt;&lt;/span&gt; 7、自动安装依赖模块假设模板是这样的： 123456789101112131415161718192021import React from &quot;react&quot;;import &#123; Button, Form, Input &#125; from &quot;antd&quot;;const App = () =&gt; &#123; const onFinish = (values) =&gt; &#123; console.log(&quot;Success:&quot;, values); &#125;; return ( &lt;Form onFinish=&#123;onFinish&#125; autoComplete=&quot;off&quot;&gt; &lt;Form.Item label=&quot;Username&quot; name=&quot;username&quot;&gt; &lt;Input /&gt; &lt;/Form.Item&gt; &lt;Form.Item&gt; &lt;Button type=&quot;primary&quot; htmlType=&quot;submit&quot;&gt; 提交 &lt;/Button&gt; &lt;/Form.Item&gt; &lt;/Form&gt; );&#125;;export default App; 可以看到模板中使用了 react 和 antd 这两个第三方依赖，假如使用模板的工程中没有安装这两个依赖，我们要实现在生成模板过程中就自动安装这两个依赖。 我们使用 Node 中 child_process 子进程这个模块来实现。 在 child_process 子进程中的最常用的语法是： child_process.exec(command, options, callback) command：命令，比如 pnpm install options：参数 cwd：设置命令运行环境的路径 env：环境变量 timeout：运行执行现在 callback：运行命令结束回调，(error, stdout, stderr) =&gt;&#123; &#125;，执行成功后 error 为 null，执行失败后 error 为 Error 实例，stdout、stderr 为标准输出、标准错误，其格式默认是字符串。 在 bin 文件夹中新建 inquirer.js 文件夹，在里面添加如下代码： 1234567891011121314151617181920212223242526272829const path = require(&quot;path&quot;);const &#123; exec &#125; = require(&quot;child_process&quot;);const LibraryMap = &#123; &quot;Ant Design&quot;: &quot;antd&quot;, iView: &quot;view-ui-plus&quot;, &quot;Ant Design Vue&quot;: &quot;ant-design-vue&quot;, Element: &quot;element-plus&quot;,&#125;;function install(cmdPath, options) &#123; const &#123; frame, library &#125; = options; const command = `pnpm add $&#123;frame&#125; &amp;&amp; pnpm add $&#123;LibraryMap[library]&#125;`; return new Promise(function (resolve, reject) &#123; exec( command, &#123; cwd: path.resolve(cmdPath), &#125;, function (error, stdout, stderr) &#123; console.log(&quot;error&quot;, error); console.log(&quot;stdout&quot;, stdout); console.log(&quot;stderr&quot;, stderr); &#125; ); &#125;);&#125;exports.install = install; 在 install 方法中 exec 的参数 command 是 pnpm 安装依赖命令，安装多个依赖时使用 &amp;&amp; 拼接。参数 cwd 是所安装依赖工程的 package.json 文件路径，我们可以使用 process.cwd() 获取。已经在上文提到过，process.cwd() 是当前Node.js 进程执行时的文件所属目录的绝对路径。 接下来使用，在 bin&#x2F;index.js 修改代码，修改后的代码如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940#!/usr/bin/env nodeconst yargs = require(&quot;yargs&quot;);const path = require(&quot;path&quot;);const &#123; inquirerPrompt &#125; = require(&quot;./inquirer&quot;);const &#123; copyTemplate, checkMkdirExists &#125; = require(&quot;./copy&quot;);const &#123; install &#125; = require(&quot;./manager&quot;);yargs.command( [&quot;create&quot;, &quot;c&quot;], &quot;新建一个模板&quot;, function (yargs) &#123; return yargs.option(&quot;name&quot;, &#123; alias: &quot;n&quot;, demand: true, describe: &quot;模板名称&quot;, type: &quot;string&quot;, &#125;); &#125;, function (argv) &#123; inquirerPrompt(argv).then((answers) =&gt; &#123; const &#123; name, type &#125; = answers; const isMkdirExists = checkMkdirExists( path.resolve(process.cwd(), `./src/pages/$&#123;name&#125;/index.js`) ); if (isMkdirExists) &#123; console.log(`$&#123;name&#125;/index.js文件已经存在`); &#125; else &#123; copyTemplate( path.resolve(__dirname, `./template/$&#123;type&#125;/index.tpl`), path.resolve(process.cwd(), `./src/pages/$&#123;name&#125;/index.js`), &#123; name, &#125; ); install(process.cwd(), answers); &#125; &#125;); &#125;).argv; 当执行完 copyTemplate 方法后，就开始执行 install(process.cwd(), answers) 自动安装模板中所需的依赖。 在 app 文件夹目录下运行 pnpm mortal create -- --name=OrderPage，看能不能自动安装依赖。 等命令执行完成后，观察 examples\\app\\package.json 文件中的 dependencies 值是不是添加了 antd 和 react 依赖。 此外，我们在执行命令中会发现，如下图所示的现象，光标一直在闪烁，好像卡住了，其中是依赖在安装。这里我们要引入一个加载动画，来解决这个不友好的现象。 这里推荐使用开源库ora来实现加载动画。 运行以下命令安装 ora 。 1pnpm add ora@5.4.1 --F mortal-cli 在 bin&#x2F;inquirer.js 修改代码，修改后的代码如下所示： 123456789101112131415161718192021222324252627282930313233343536const path = require(&quot;path&quot;);const &#123; exec &#125; = require(&quot;child_process&quot;);const ora = require(&quot;ora&quot;);const LibraryMap = &#123; &quot;Ant Design&quot;: &quot;antd&quot;, iView: &quot;view-ui-plus&quot;, &quot;Ant Design Vue&quot;: &quot;ant-design-vue&quot;, Element: &quot;element-plus&quot;,&#125;;function install(cmdPath, options) &#123; const &#123; frame, library &#125; = options; const command = `pnpm add $&#123;frame&#125; &amp;&amp; pnpm add $&#123;LibraryMap[library]&#125;`; return new Promise(function (resolve, reject) &#123; const spinner = ora(); spinner.start(`正在安装依赖，请稍等`); exec( command, &#123; cwd: path.resolve(cmdPath), &#125;, function (error) &#123; if (error) &#123; reject(); spinner.fail(`依赖安装失败`); return; &#125; spinner.succeed(`依赖安装成功`); resolve(); &#125; ); &#125;);&#125;exports.install = install; 在 app 文件夹目录下运行 pnpm mortal create -- --name=OrderPage，看一下执行效果。 8、发布和安装在 packages&#x2F;mortal 文件夹目录下运行，运行以下命令安装将脚手架发布到 npm 上。 1pnpm publish --F mortal-cli 发布成功后。我们在一个任意工程中，执行 pnpm add mortal-cli -D 安装 mortal-cli 脚手架依赖成功后，在工程中执行 pnpm mortal create -- --name=OrderPage 命令即可。 结语上面只教大家实现一个最最简单的脚手架。其功能就只有一个模板文件生成。虽然简单，但是这些都是脚手架的入门功，代码已经上传到 GitHub，大家可以下载下来，自己实践一下，光看不练永远学不会。 学会了，可以总结一些平时的业务代码，形成最佳实践，使用脚手架作为载体展现出来，提升自己的职场竞争力。","tags":["monorepo","scaffold"],"categories":["frontend"]},{"title":"Nginx和PHP的配置","path":"/2024/03/01/Nginx和PHP的配置/","content":"原文地址Nginx 和 PHP 的配置 - 知乎 采用 nginx+php 作为 webserver 的架构模式，在现如今运用相当广泛。然而第一步需要实现的是如何让 nginx 正确的调用 php。由于 nginx 调用 php 并不是如同调用一个静态文件那么直接简单，是需要动态执行 php 脚本。所以涉及到了对 nginx.conf 文件的配置。这一步对新手而言需要动点脑筋，对于一般的熟手而言，也有不少同学并没有搞透彻为何要如此这般配置。本文的主要内容为如何在 nginx server 中正确配置 php 调用方法，以及配置的基本原理。 一、nginx 配置文件修改配置文件位置Nginx 的配置文件默认位置为：/etc/nginx/nginx.conf 在我的环境中 nginx.conf 在 /etc/nginx/nginx.conf 使用 vim 打开文件 nginx.conf 1vim /etc/nginx/nginx.conf 配置文件分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384# nginx运行的用户名user nginx;# nginx启动进程,通常设置成和cpu的数量相等，这里为自动worker_processes auto;# errorlog文件位置error_log /var/log/nginx/error.log;# pid文件地址，记录了nginx的pid，方便进程管理pid /run/nginx.pid;# Load dynamic modules. See /usr/share/nginx/README.dynamic.# 用来加载其他动态模块的配置include /usr/share/nginx/modules/*.conf;# 工作模式和连接数上限events &#123; # 每个worker_processes的最大并发链接数 # 并发总数：worker_processes*worker_connections worker_connections 1024;&#125;# 与提供http服务相关的一些配置参数类似的还有mailhttp &#123; # 设置日志的格式 log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; # access_log记录访问的用户、页面、浏览器、ip和其他的访问信息 access_log /var/log/nginx/access.log main; # 这部分下面会单独解释 # 设置nginx是否使用sendfile函数输出文件 sendfile on; # 数据包最大时发包(使用Nagle算法) tcp_nopush on; # 立刻发送数据包(禁用Nagle算法) tcp_nodelay on; # 链接超时时间 keepalive_timeout 65; # 这个我也不清楚... types_hash_max_size 2048; # 引入文件扩展名与文件类型映射表 include /etc/nginx/mime.types; # 默认文件类型 default_type application/octet-stream; # Load modular configuration files from the /etc/nginx/conf.d directory. # See http://nginx.org/en/docs/ngx_core_module.html#include # for more information. include /etc/nginx/conf.d/*.conf; # http服务上支持若干虚拟主机。 # 每个虚拟主机一个对应的server配置项 # 配置项里面包含该虚拟主机相关的配置。 server &#123; # 端口 listen 80 default_server; listen [::]:80 default_server; # 访问的域名 server_name _; # 默认网站根目录（www目录） root /usr/share/nginx/html; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; # 默认请求 location / &#123; &#125; # 错误页(404) error_page 404 /404.html; location = /40x.html &#123; &#125; # 错误页(50X) error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125; &#125;&#125; 要点说明1、关于 error_log 可以设置 log 的类型(记录什么级别的信息)有：debug、info、notice、warn、error、crit 几种 2、关于 sendfile一般的网络传输过程硬盘 &gt;&gt; kernel buffer &gt;&gt; user buffer&gt;&gt; kernel socket buffer &gt;&gt;协议栈使用 sendfile 后硬盘 &gt;&gt; kernel buffer (快速拷贝到 kernelsocket buffer) &gt;&gt;协议栈可以显著提高传输性能。 3、tcp_nopush 和 tcp_nodelaytcp_nopush 只有在启用了 sendfile 时才起作用，在启用 tcp_nopush 后，程序接收到了数据包后不会马上发出，而是等待数据包最大时一次性发出，可以缓解网络拥堵。(Nagle 化)相反 tcp_nodelay 则是立即发出数据包. php fastcgi 配置分析完了配置文件后开始配置环境。 因为只是配置 PHP 的服务器，而且只使用一个端口所以只需要改动 server 部分 在 vim 中点击‘i’进入编辑模式 123456789101112131415161718192021222324252627282930313233343536373839server &#123; listen 80 default_server; listen [::]:80 default_server; # 这里改动了，也可以写你的域名 server_name 192.168.17.26; # 默认网站根目录（www目录） root /var/www/; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / &#123; # 这里改动了 定义首页索引文件的名称 index index.php index.html index.htm; &#125; error_page 404 /404.html; location = /40x.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125; # 这里新加的 # PHP 脚本请求全部转发到 FastCGI处理. 使用FastCGI协议默认配置. # Fastcgi服务器和程序(PHP,Python)沟通的协议. location ~ \\.php$ &#123; # 设置监听端口 fastcgi_pass 127.0.0.1:9000; # 设置nginx的默认首页文件(上面已经设置过了，可以删除) fastcgi_index index.php; # 设置脚本文件请求的路径 fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; # 引入fastcgi的配置文件 include fastcgi_params; &#125; &#125; 修改完成后将 vim 编辑器切换到一般一半模式(Esc),然后输入:wq 保存退出。 之后重启 Nginx 服务 1service nginx restart 以上就配置成功了，但是上面的配置只是 nginx 配置部分，更多的内容需要继续学习。 测试我们可以通过下面的方法判断 Nginx 配置是否成功。 在 Nginx 的网站根目录(&#x2F;var&#x2F;www&#x2F;)下创建一个 php 文件，随便起名我的是 php_info.php 内容如下： 1234&lt;?php // 顺便可以看一下php的扩展全不全 phpinfo(); 进入你的网站看看能不能打开文件你的 ip&#x2F;文件名 例如：192.168.17.26&#x2F;php_info.php ok,我们可以看到配置成功了。 二、nginx+php 运行原理上边我们已经配置成功了，现在我们来看下具体的原理。 首先简单的讲一讲原理，目前主流的 nginx+php 的运行原理如下：1、nginx 的worker进程直接管理每一个请求到 nginx 的网络请求。 2、对于 php 而言，由于在整个网络请求的过程中 php 是一个 cgi 程序的角色，所以采用名为php-fpm的进程管理程序来对这些被请求的 php 程序进行管理。php-fpm 程序也如同 nginx 一样，需要监听端口，并且有 master 和 worker 进程。worker 进程直接管理每一个 php 进程。 3、关于 fastcgi：fastcgi 是一种进程管理器，管理 cgi 进程。市面上有多种实现了 fastcgi 功能的进程管理器，php-fpm 就是其中的一种。再提一点，php-fpm 作为一种 fast-cgi 进程管理服务，会监听端口，一般默认监听9000端口，并且是监听本机，也就是只接收来自本机的端口请求，所以我们通常输入命令 netstat -nlpt|grep php-fpm 会得到：tcp 0 0 127.0.0.1:9000 0.0.0.0:* LISTEN 1057&#x2F;php-fpm这里的 127.0.0.1:9000 就是监听本机 9000 端口的意思。 4、关于 fastcgi 的配置文件，目前 fastcgi 的配置文件一般放在 nginx.conf 同级目录下，配置文件形式，一般有两种：fastcgi.conf 和 fastcgi_params。不同的 nginx 版本会有不同的配置文件，这两个配置文件有一个非常重要的区别：fastcgi_parames 文件中缺少下列配置：fastcgi_param SCRIPT_FILENAME fastcgi_script_name;我们可以打开 fastcgi_parames 文件加上上述行，也可以在要使用配置的地方动态添加。使得该配置生效。 5、当需要处理php请求时，nginx的worker进程会将请求移交给php-fpm的worker进程进行处理，也就是最开头所说的nginx调用了php，其实严格得讲是nginx间接调用php。 了解了上面的这五个简单原理，在 nginx 中配置 php 调用方法就变得易如反掌。 配置文件详解： 12345678910server &#123; listen 8011; server_name test.cn; location ~ \\.php?.*$ &#123; root /share/test; fastcgi_pass 127.0.0.1:9000; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125;&#125; 1、第一个大括号 server{ }：不必多说，代表一个独立的 server，2、listen 8011：代表该 server 监听 8011 端口3、location ~ .php?.*${ }：代表一个能匹配对应 uri 的 location，用于匹配一类 uri，并对所匹配的 uri 请求做自定义的逻辑、配置。这里的 location，匹配了所有带.php 的 uri 请求，例如：http://192.168.244.128:8011&#x2F;test.php&#x2F;asdasd http://192.168.244.128:8011&#x2F;index.php 等4、root &#x2F;share&#x2F;test：请求资源根目录，告诉匹配到该 location 下的 uri 到&#x2F;share&#x2F;teset 文件夹下去寻找同名资源。5、fastcgi_pass 127.0.0.1:9000：这行开始是本文的重点：这行代码的意思是，将进入到该 location 内的 uri 请求看做是 cgi 程序，并将请求发送到 9000 端口，交由 php-fpm 处理。6、fastcgi_param SCRIPT_FILENAME fastcgi_script_name; ：这行配置意思是：动态添加了一行 fastcgi 配置，配置内容为 SCRIPT_FILENAME，告知管理进程，cgi 脚本名称。由于我的 nginx 中只有 fastcgi_params 文件，没有 fastcgi.conf 文件，所以要使 php-fpm 知道 SCRIPT_FILENAME 的具体值，就必须要动态的添加这行配置。7、include fastcgi_params; 引入 fastcgi 配置文件以上就是最简洁版的 nginx 启动 php 脚本的最简配置，当重启 nginx 之后，在&#x2F;share&#x2F;test 目录下创建一个 xx.php 文件，输入保存，然后在浏览器中访问 localhost:8011&#x2F;xx.php 就可以在网页上显示 hello world 了。 三、外网访问内网设置外网 IP：http://58.62.21.107:8382 映射内网服务器 IP 192.168.17.56 的 82 端口，即：192.168.17.56:82,需要在nginx.conf 配置文件中开放 82 端口给 外网访问，即下面的配置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104[root@ceshi www]# cat /etc/nginx/nginx.conf# For more information on configuration, see:# * Official English Documentation: http://nginx.org/en/docs/# * Official Russian Documentation: http://nginx.org/ru/docs/user nginx;worker_processes auto;error_log /var/log/nginx/error.log;pid /run/nginx.pid;# Load dynamic modules. See /usr/share/nginx/README.dynamic.include /usr/share/nginx/modules/*.conf;events &#123; worker_connections 1024;&#125;http &#123; log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; include /etc/nginx/mime.types; default_type application/octet-stream; # Load modular configuration files from the /etc/nginx/conf.d directory. # See http://nginx.org/en/docs/ngx_core_module.html#include # for more information. include /etc/nginx/conf.d/*.conf; server &#123; listen 82 default_server; # 服务器端口，和外网映射的需保持一致 listen [::]:82 default_server; # 服务器端口，和外网映射的需保持一致 server_name 192.168.17.56; root /data/www/; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / &#123; &#125; error_page 404 /404.html; location = /40x.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125; # PHP 脚本请求全部转发到 FastCGI处理. 使用FastCGI协议默认配置. # Fastcgi服务器和程序(PHP,Python)沟通的协议. location ~ \\.php$ &#123; # 设置监听端口 fastcgi_pass 127.0.0.1:9000; # 设置nginx的默认首页文件(上面已经设置过了，可以删除) fastcgi_index index.php; # 设置脚本文件请求的路径 fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; # 引入fastcgi的配置文件 include fastcgi_params; &#125; &#125;# Settings for a TLS enabled server.## server &#123;# listen 443 ssl http2 default_server;# listen [::]:443 ssl http2 default_server;# server_name _;# root /usr/share/nginx/html;## ssl_certificate &quot;/etc/pki/nginx/server.crt&quot;;# ssl_certificate_key &quot;/etc/pki/nginx/private/server.key&quot;;# ssl_session_cache shared:SSL:1m;# ssl_session_timeout 10m;# ssl_ciphers HIGH:!aNULL:!MD5;# ssl_prefer_server_ciphers on;## # Load configuration files for the default server block.# include /etc/nginx/default.d/*.conf;## location / &#123;# &#125;## error_page 404 /404.html;# location = /40x.html &#123;# &#125;## error_page 500 502 503 504 /50x.html;# location = /50x.html &#123;# &#125;# &#125;&#125; 以上内容希望帮助到大家，很多 PHPer 在进阶的时候总会遇到一些问题和瓶颈，业务代码写多了没有方向感，不知道该从那里入手去提升，对此我整理了一些资料，包括但不限于：分布式架构、高可扩展、高性能、高并发、服务器性能调优、TP6，laravel，YII2，Redis，Swoole、Swoft、Kafka、Mysql 优化、shell 脚本、Docker、微服务、Nginx 等多个知识点高级进阶干货需要的可以免费分享给大家，需要请戳这里链接 或者 知乎专栏","tags":["Nginx","PHP"],"categories":["Nginx"]},{"title":"SQL概念及数据库表的基本操作","path":"/2024/03/01/SQL概念及数据库表的基本操作/","content":"原文地址SQL 概念及数据库表的基本操作 - 掘金 介绍SQL之前，先来了解一下关于数据库的一些概念。 什么是数据库 数据库（Database，DB）：是一个有组织的、统一管理的数据集合。简单来说，就是用来存储数据的地方。 数据库管理系统（Database Management System，DBMS）：用来操纵和管理数据库的计算机软件，例如 MySQL、Oracle、SqlServer 等，都是数据库管理系统。 一个数据库系统中可以包含很多数据库，每个数据库中又包含很多表，表的一列称为一个字段，一行称为一条记录。 例如，下面是一个名为persons的表： id name age gender address 1 Alice 24 female Beijing 2 Bob 25 male Shanghai 3 Candy 26 female Beijing 表包含三条记录（每一条对应一个人）和五个列（id、姓名、年龄、性别和地址）。 掌握这些基础概念后，再来看下SQL。 SQL 概要什么是 SQLSQL全称 Structured Query Language，表示结构化查询语言，是一种专门与数据库交互的语言，规定了各种关键字、语法等。 SQL 语句及其种类使用关键字、表名和列名等以一定语法规则组合而成的语句称之为SQL语句，SQL语句可以对数据库赋予不同指令，根据指令的种类，SQL 语句可以分为以下三类： DDL（Data Definition Language，数据定义语言）：用来创建、删除或修改数据库以及数据库中的表等对象。 create：创建数据库和表等对象 drop：删除数据库和表等对象 alter：修改数据库和表等对象的结构 DML（Data Manipulation Language，数据操纵语言）：用来查询或修改表中的记录。 select：查询表中的数据 insert：向表中插入数据 update：更新表中的数据 delete：删除表中的数据 DCL（Data Control Language，数据控制语言）：用来确认或取消对数据库中的数据变更的执行操作，以及对用户操作数据库中的对象的权限进行设定。 commit：提交，即确认对数据库中的数据进行的变更 rollback：回滚，即取消对数据库中的数据进行的变更 grant：赋予用户的操作权限 revoke：取消用户的操作权限 SQL 的基本书写规则 SQL 语句要以分号;结尾 SQL 的关键字不区分大小写，但是表名、字段名、数据等是区分大小写的 字符串或者日期等类型需用单引号括起来，如’xyz’、’2021-10-29’ 单词需要使用空格或者换行符进行分隔 数据库、表、字段的名称可以使用英文、数字以及下划线，一般情况下数据库名、表名和列名等小写 数据类型只列常用： 类型 描述 int、bigint、tinyint 等 整数数字类型 char 定长字符串类型 varchar 可变长度字符串类型 text 文本类型 datetime 日期和时间的组合类型，格式：YYYY-MM-DD HH:MM:SS ··· ··· 数据库的基本操作数据库相关 创建数据库 1CREATE DATABASE &lt;数据库名&gt;; 删除数据库 1DROP DATABASE &lt;数据库名&gt;; 列出数据库 1SHOW DATABASES; 切换数据库 1USE &lt;数据库名&gt;; 数据表相关 创建表 12345678910CREATE TABLE &lt;表名&gt; ( &lt;列名1&gt; &lt;类型&gt; &lt;约束&gt;, &lt;列名2&gt; &lt;类型&gt; &lt;约束&gt;, ... ... ... &lt;表的约束1&gt;, &lt;表的约束2&gt;, ....); 删除表 1DROP TABLE &lt;表名&gt;; 更新表 新增列 1ALTER TABLE &lt;表名&gt; ADD COLUMN &lt;列名&gt; &lt;类型&gt; &lt;约束&gt;; 删除列 1ALTER TABLE &lt;表名&gt; DROP COLUMN &lt;列名&gt;; 修改列 1ALTER TABLE &lt;表名&gt; MODIFY COLUMN &lt;列名&gt; &lt;类型&gt; &lt;约束&gt;; 插入数据 1INSERT INTO &lt;表名&gt; VALUES (值1, 值2,....); 指定所要插入数据的列: 1INSERT INTO &lt;表名&gt;(列1, 列2,...) VALUES (值1, 值2,....); 示例 创建数据库 1CREATE DATABASE test; 显示数据库 1SHOW DATABASES; 切换数据库 1use test; 创建数据表 123456789CREATE TABLE `persons` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(64) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;姓名&#x27;, `age` int(11) COMMENT &#x27;年龄&#x27;, `gender` varchar(11) NOT NULL DEFAULT &#x27;male&#x27; COMMENT &#x27;性别&#x27;, `address` varchar(64) COMMENT &#x27;地址&#x27;, `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;, PRIMARY KEY (`id`) USING BTREE) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;人员信息表&#x27;; 新增列 1ALTER TABLE persons ADD COLUMN mobile varchar(64) COMMENT &#x27;手机号&#x27;; 删除列 1ALTER TABLE persons DROP COLUMN mobile; 修改列 1ALTER TABLE persons MODIFY COLUMN age varchar(11) COMMENT &#x27;年龄&#x27;; 插入数据 1INSERT INTO persons VALUES (1,&#x27;Alice&#x27;,24,&#x27;female&#x27;,&#x27;Beijing&#x27;,&#x27;2021-10-29 12:00:00&#x27;); 1INSERT INTO persons(name,age,gender,address) VALUES (&#x27;Bob&#x27;,25,&#x27;male&#x27;,&#x27;Shanghai&#x27;);","tags":["SQL"],"categories":["SQL"]},{"title":"MySQL高级SQL语句进阶","path":"/2024/03/01/MySQL高级SQL语句进阶/","content":"MySQL 高级（进阶）SQL 语句 原文地址MySQL 高级（进阶）SQL 语句 - 掘金 1. MySQL SQL 语句1.1 常用查询常用查询简单来说就是 增、删、改、查 对 MySQL 数据库的查询，除了基本的查询外，有时候需要对查询的结果集进行处理。 例如只取 10 条数据、对查询结果进行排序或分组等等 1、按关键字排序 PS:类比于 windows 任务管理器 使用 SELECT 语句可以将需要的数据从 MySQL 数据库中查询出来，如果对查询的结果进行排序，可以使用 ORDER BY 语句来对语句实现排序，并最终将排序后的结果返回给用户。这个语句的排序不光可以针对某一个字段，也可以针对多个字段 （1）语法 SELECT column1, column2, … FROM table_name ORDER BY column1, column2, … ASC|DESC ASC 是按照升序进行排序的，是默认的排序方式，即 ASC 可以省略。SELECT 语句中如果没有指定具体的排序方式，则默认按 ASC 方式进行排序。 DESC 是按降序方式进 行排列。当然 ORDER BY 前面也可以使用 WHERE 子句对查询结果进一步过滤。 准备工作： 1234567create database k1;use k1;create table location (Region char(20),Store_Name char(20));insert into location values(&#x27;East&#x27;,&#x27;Boston&#x27;);insert into location values(&#x27;East&#x27;,&#x27;New York&#x27;);insert into location values(&#x27;West&#x27;,&#x27;Los Angeles&#x27;);insert into location values(&#x27;West&#x27;,&#x27;Houston&#x27;); 12345create table store_info (Store_Name char(20),Sales int(10),Date char(10));insert into store_info values(&#x27;Los Angeles&#x27;,&#x27;1500&#x27;,&#x27;2020-12-05&#x27;);insert into store_info values(&#x27;Houston&#x27;,&#x27;250&#x27;,&#x27;2020-12-07&#x27;);insert into store_info values(&#x27;Los Angeles&#x27;,&#x27;300&#x27;,&#x27;2020-12-08&#x27;);insert into store_info values(&#x27;Boston&#x27;,&#x27;700&#x27;,&#x27;2020-12-08&#x27;); 1.2 SELECT显示表格中一个或数个字段的所有数据记录 语法：SELECT “字段” FROM “表名”; 1SELECT Store_Name FROM location; 1SELECT Store_Name FROM Store_Info; 1.3 DISTINCT不显示重复的数据记录 语法：SELECT DISTINCT &quot;字段&quot; FROM &quot;表名&quot;; 1SELECT DISTINCT Store_Name FROM Store_Info; 1.4 AND OR且 或 语法：SELECT &quot;字段&quot; FROM &quot;表名&quot; WHERE &quot;条件1&quot; &#123;[AND|OR] &quot;条件2&quot;&#125;+ ; 1.5 in显示已知的值的数据记录 语法：SELECT &quot;字段&quot; FROM &quot;表名&quot; WHERE &quot;字段&quot; IN (&#39;值1&#39;, &#39;值2&#39;, ...); 1SELECT * FROM store_info WHERE Store_Name IN (&#x27;Los Angeles&#x27;, &#x27;Houston&#x27;); 1.6 BETWEEN显示两个值范围内的数据记录 语法：SELECT &quot;字段&quot; FROM &quot;表名&quot; WHERE &quot;字段&quot; BETWEEN &#39;值1&#39; AND &#39;值2&#39;; 2. 通配符通常与 LIKE 搭配 一起使用 % ：百分号表示零个、一个或多个字符 _ ：下划线表示单个字符 ‘A_Z’：所有以 ‘A’ 起头，另一个任何值的字符，且以 ‘Z’ 为结尾的字符串。例如，’ABZ’ 和 ‘A2Z’ 都符合这一个模式，而 ‘AKKZ’ 并不符合 (因为在 A 和 Z 之间有两个字符，而不是一个字符)。 ‘ABC%’: 所有以 ‘ABC’ 起头的字符串。例如，’ABCD’ 和 ‘ABCABC’ 都符合这个模式。 ‘%XYZ’: 所有以 ‘XYZ’ 结尾的字符串。例如，’WXYZ’ 和 ‘ZZXYZ’ 都符合这个模式。 ‘%AN%’: 所有含有 ‘AN’这个模式的字符串。例如，’LOS ANGELES’ 和 ‘SAN FRANCISCO’ 都符合这个模式。 ‘_AN%’：所有第二个字母为 ‘A’ 和第三个字母为 ‘N’ 的字符串。例如，’SAN FRANCISCO’ 符合这个模式，而 ‘LOS ANGELES’ 则不符合这个模式。 2.1 LIKE匹配一个模式来找出我们要的数据记录 语法：SELECT &quot;字段&quot; FROM &quot;表名&quot; WHERE &quot;字段&quot; LIKE &#123;模式&#125;; 1SELECT * FROM store_info WHERE Store_Name like &#x27;%os%&#x27;; 2.2 ORDER BY按关键字排序 语法：SELECT &quot;字段&quot; FROM &quot;表名&quot; [WHERE &quot;条件&quot;] ORDER BY &quot;字段&quot; [ASC, DESC]; 注意：ASC 是按照升序进行排序的，是默认的排序方式。 DESC 是按降序方式进行排序 1SELECT Store_Name,Sales,Date FROM store_info ORDER BY Sales DESC; 3. 函数3.1 数学函数 abs(x) 返回 x 的绝对值 rand() 返回 0 到 1 的随机数 mod(x,y) 返回 x 除以 y 以后的余数 power(x,y) 返回 x 的 y 次方 round(x) 返回离 x 最近的整数 round(x,y) 保留 x 的 y 位小数四舍五入后的值 sqrt(x) 返回 x 的平方根 truncate(x,y) 返回数字 x 截断为 y 位小数的值 ceil(x) 返回大于或等于 x 的最小整数 floor(x) 返回小于或等于 x 的最大整数 greatest(x1,x2…) 返回集合中最大的值，也可以返回多个字段的最大的值 least(x1,x2…) 返回集合中最小的值，也可以返回多个字段的最小的值 12SELECT abs(-1), rand(), mod(5,3), power(2,3), round(1.89);SELECT round(1.8937,3), truncate(1.235,2), ceil(5.2), floor(2.1), least(1.89,3,6.1,2.1); 3.2 聚合函数 avg() 返回指定列的平均值 count() 返回指定列中非 NULL 值的个数 min() 返回指定列的最小值 max() 返回指定列的最大值 sum(x) 返回指定列的所有值之和 123456789SELECT avg(Sales) FROM store_info;SELECT count(Store_Name) FROM store_info;SELECT count(DISTINCT Store_Name) FROM store_info;SELECT max(Sales) FROM store_info;SELECT min(Sales) FROM store_info;SELECT sum(Sales) FROM store_info; 3.3 字符串函数 trim() 返回去除指定格式的值 concat(x,y) 将提供的参数 x 和 y 拼接成一个字符串 substr(x,y) 获取从字符串 x 中的第 y 个位置开始的字符串，跟 substring()函数作用相同 substr(x,y,z) 获取从字符串 x 中的第 y 个位置开始长度为 z 的字符串 length(x) 返回字符串 x 的长度 replace(x,y,z) 将字符串 z 替代字符串 x 中的字符串 y upper(x) 将字符串 x 的所有字母变成大写字母 lower(x) 将字符串 x 的所有字母变成小写字母 left(x,y) 返回字符串 x 的前 y 个字符 right(x,y) 返回字符串 x 的后 y 个字符 repeat(x,y) 将字符串 x 重复 y 次 space(x) 返回 x 个空格 strcmp(x,y) 比较 x 和 y，返回的值可以为-1,0,1 reverse(x) 将字符串 x 反转 如 sql_mode 开启了 PIPES_AS_CONCAT，”||” 视为字符串的连接操作符而非或运算符，和字符串的拼接函数 Concat 相类似，这和 Oracle 数据库使用方法一样的 123SELECT Region || &#x27; &#x27; || Store_Name FROM location WHERE Store_Name = &#x27;Boston&#x27;;SELECT substr(Store_Name,3) FROM location WHERE Store_Name = &#x27;Los Angeles&#x27;;SELECT substr(Store_Name,2,4) FROM location WHERE Store_Name = &#x27;New York&#x27; SELECT TRIM ([ [位置] [要移除的字符串] FROM ] 字符串); **[位置]：的值可以为 LEADING (起头), TRAILING (结尾), BOTH (起头及结尾)。 ** [要移除的字符串]：从字串的起头、结尾，或起头及结尾移除的字符串。缺省时为空格。 12345SELECT TRIM(LEADING &#x27;Ne&#x27; FROM &#x27;New York&#x27;);SELECT Region,length(Store_Name) FROM location;SELECT REPLACE(Region,&#x27;ast&#x27;,&#x27;astern&#x27;)FROM location; 4. GROUP BY对 GROUP BY 后面的字段的查询结果进行汇总分组，通常是结合聚合函数一起使用的 GROUP BY 有一个原则 凡是在 GROUP BY 后面出现的字段，必须在 SELECT 后面出现； 凡是在 SELECT 后面出现的、且未在聚合函数中出现的字段，必须出现在 GROUP BY 后面 语法：SELECT &quot;字段1&quot;, SUM(&quot;字段2&quot;) FROM &quot;表名&quot; GROUP BY &quot;字段1&quot;; 1SELECT Store_Name, SUM(Sales) FROM store_info GROUP BY Store_Name ORDER BY sales desc; 5. 别名字段別名 表格別名 语法：SELECT &quot;表格別名&quot;.&quot;字段1&quot; [AS] &quot;字段別名&quot; FROM &quot;表格名&quot; [AS] &quot;表格別名&quot;; 1SELECT A.Store_Name Store, SUM(A.Sales) &quot;Total Sales&quot; FROM store_info A GROUP BY A.Store_Name; 6. 子查询子查询也被称作内查询或者嵌套查询，是指在一个查询语句里面还嵌套着另一个查询语 句。子查询语句是先于主查询语句被执行的，其结果作为外层的条件返回给主查询进行下一 步的查询过滤 连接表格，在 WHERE 子句或 HAVING 子句中插入另一个 SQL 语句 语法：SELECT &quot;字段1&quot; FROM &quot;表格1&quot; WHERE &quot;字段2&quot; [比较运算符] #外查询 (SELECT &quot;字段1&quot; FROM &quot;表格2&quot; WHERE &quot;条件&quot;); #内查询 [比较运算符] 可以是符号的运算符，例如 &#x3D;、&gt;、&lt;、&gt;&#x3D;、&lt;&#x3D; ；也可以是文字的运算符，例如 LIKE、IN、BETWEEN 12345SELECT SUM(Sales) FROM store_info WHERE Store_Name IN(SELECT Store_Name FROM location WHERE Region = &#x27;West&#x27;);SELECT SUM(A.Sales) FROM store_info A WHERE A.Store_Name IN(SELECT Store_Name FROM location B WHERE B.Store_Name = A.Store_Name); 7. EXISTS用来测试内查询有没有产生任何结果，类似布尔值是否为真 #如果有的话，系统就会执行外查询中的 SQL 语句。若是没有的话，那整个 SQL 语句就不会产生任何结果。 语法：SELECT &quot;字段1&quot; FROM &quot;表格1&quot; WHERE EXISTS (SELECT \\* FROM &quot;表格2&quot; WHERE &quot;条件&quot;); 1SELECT SUM(Sales) FROM store_info WHERE EXISTS (SELECT * FROM location WHERE Region = &#x27;West&#x27;); 8. 连接查询准备工作 1234567create database k1;use k1;create table location (Region char(20),Store_Name char(20));insert into location values(&#x27;East&#x27;,&#x27;Boston&#x27;);insert into location values(&#x27;East&#x27;,&#x27;New York&#x27;);insert into location values(&#x27;West&#x27;,&#x27;Los Angeles&#x27;);insert into location values(&#x27;West&#x27;,&#x27;Houston&#x27;); 12345create table store_info (Store_Name char(20),Sales int(10),Date char(10));insert into store_info values(&#x27;Los Angeles&#x27;,&#x27;1500&#x27;,&#x27;2020-12-05&#x27;);insert into store_info values(&#x27;Houston&#x27;,&#x27;250&#x27;,&#x27;2020-12-07&#x27;);insert into store_info values(&#x27;Los Angeles&#x27;,&#x27;300&#x27;,&#x27;2020-12-08&#x27;);insert into store_info values(&#x27;Boston&#x27;,&#x27;700&#x27;,&#x27;2020-12-08&#x27;); 1UPDATE store_info SET store_name=&#x27;Washington&#x27; WHERE sales=300; inner join(内连接)：只返回两个表中联结字段相等的行 left join(左连接)：返回包括左表中的所有记录和右表中联结字段相等的记录 right join(右连接)：返回包括右表中的所有记录和左表中联结字段相等的记录 8.1 内连接MySQL 中的内连接就是两张或多张表中同时符合某种条件的数据记录的组合。通常在 FROM 子句中使用关键字 INNER JOIN 来连接多张表，并使用 ON 子句设置连接条件，内连接是系统默认的表连接，所以在 FROM 子句后可以省略 INNER 关键字，只使用 关键字 JOIN。同时有多个表时，也可以连续使用 INNER JOIN 来实现多表的内连接，不过为了更好的性能，建议最好不要超过三个表 (1) 语法 求交集 1SELECT column_name(s)FROM table1 INNER JOIN table2 ON table1.column_name = table2.column_name; 1SELECT * FROM location A INNER JOIN store_info B on A.Store_Name = B.Store_Name ; 内连查询：通过 inner join 的方式将两张表指定的相同字段的记录行输出出来 8.2 左连接左连接也可以被称为左外连接，在 FROM 子句中使用 LEFT JOIN 或者 LEFT OUTER JOIN 关键字来表示。左连接以左侧表为基础表，接收左表的所有行，并用这些行与右侧参 考表中的记录进行匹配，也就是说匹配左表中的所有行以及右表中符合条件的行。 1SELECT * FROM location A LEFT JOIN store_info B on A.Store_Name = B.Store_Name ; 左连接中左表的记录将会全部表示出来，而右表只会显示符合搜索条件的记录，右表记录不足的地方均为 NULL 8.3 右连接右连接也被称为右外连接，在 FROM 子句中使用 RIGHT JOIN 或者 RIGHT OUTER JOIN 关键字来表示。右连接跟左连接正好相反，它是以右表为基础表，用于接收右表中的所有行，并用这些记录与左表中的行进行匹配 1SELECT * FROM location A RIGHT JOIN store_info B on A.Store_Name = B.Store_Name ; 9. UNION —-联集将两个 SQL 语句的结果合并起来，两个 SQL 语句所产生的字段需要是同样的数据记录种类 UNION ：生成结果的数据记录值将没有重复，且按照字段的顺序进行排序 语法：[SELECT 语句 1] UNION [SELECT 语句 2]; 1SELECT Store_Name FROM location UNION SELECT Store_Name FROM store_info; UNION ALL ：将生成结果的数据记录值都列出来，无论有无重复 语法：[SELECT 语句 1] UNION ALL [SELECT 语句 2]; 1SELECT Store_Name FROM location UNION ALL SELECT Store_Name FROM store_info; 9.1 交集值取两个 SQL 语句结果的交集 123SELECT A.Store_Name FROM location A INNER JOIN store_info B ON A.Store_Name = B.Store_Name;SELECT A.Store_Name FROM location A INNER JOIN store_info B USING(Store_Name); 取两个 SQL 语句结果的交集，且没有重复 123456789101112SELECT DISTINCT A.Store_Name FROM location A INNER JOIN store_info B USING(Store_Name);SELECT DISTINCT Store_Name FROM location WHERE (Store_Name) IN (SELECT Store_Name FROM store_info);SELECT DISTINCT A.Store_Name FROM location A LEFT JOIN store_info B USING(Store_Name) WHERE B.Store_Name IS NOT NULL;SELECT A.Store_Name FROM (SELECT B.Store_Name FROM location B INNER JOIN store_info C ON B.Store_Name = C.Store_Name) AGROUP BY A.Store_Name;SELECT A.Store_Name FROM(SELECT DISTINCT Store_Name FROM location UNION ALL SELECT DISTINCT Store_Name FROM store_info) AGROUP BY A.Store_Name HAVING COUNT(*) &gt; 1; 9.2 无交集值显示第一个 SQL 语句的结果，且与第二个 SQL 语句没有交集的结果，且没有重复 1234567SELECT DISTINCT Store_Name FROM location WHERE (Store_Name) NOT IN (SELECT Store_Name FROM store_info);SELECT DISTINCT A.Store_Name FROM location A LEFT JOIN store_info B USING(Store_Name) WHERE B.Store_Name IS NULL;SELECT A.Store_Name FROM(SELECT DISTINCT Store_Name FROM location UNION ALL SELECT DISTINCT Store_Name FROM store_info) AGROUP BY A.Store_Name HAVING COUNT(*) = 1; 10. case是 SQL 用来做为 IF-THEN-ELSE 之类逻辑的关键字 语法： 1234567SELECT CASE (&quot;字段名&quot;) WHEN &quot;条件1&quot; THEN &quot;结果1&quot; WHEN &quot;条件2&quot; THEN &quot;结果2&quot; ... [ELSE &quot;结果N&quot;] ENDFROM &quot;表名&quot;; “条件” 可以是一个数值或是公式。 ELSE 子句则并不是必须的。 123456789SELECT Store_Name, CASE Store_Name WHEN &#x27;Los Angeles&#x27; THEN Sales * 2 WHEN &#x27;Boston&#x27; THEN 2000 ELSE Sales END&quot;New Sales&quot;,DateFROM store_info;#&quot;New Sales&quot; 是用于 CASE 那个字段的字段名。 11. 正则表达式 匹配模式 描述 实例 ^ 匹配文本的开始位置 ‘^bd’ 匹配以 bd 开头的字符串 $ 匹配文本的结束位置 ‘qn$’ 匹配以 qn 结尾的字符串 . 匹配任何单个字符 ‘s.t’ 匹配任何 s 和 t 之间有一个字符的字符串 * 匹配零个或多个在它前面的字符 ‘fo*t’ 匹配 t 前面有任意个 o + 匹配前面的字符 1 次或多次 ‘hom+’ 匹配以 ho 开头，后面至少一个 m 的字符串 字符串 匹配包含指定的字符串 ‘clo’ 匹配含有 clo 的字符串 p1 p2 匹配 p1 或 p2 […] 匹配字符集合中的任意一个字符 ‘[abc]’ 匹配 a 或者 b 或者 c [^…] 匹配不在括号中的任何字符 ‘[^ab]’ 匹配不包含 a 或者 b 的字符串 {n} 匹配前面的字符串 n 次 ‘g{2}’ 匹配含有 2 个 g 的字符串 {n,m} 匹配前面的字符串至少 n 次，至多 m 次 ‘f{1,3}’ 匹配 f 最少 1 次，最多 3 次 语法：SELECT “字段” FROM “表名” WHERE “字段” REGEXP {模式}; 123SELECT * FROM store_info WHERE Store_Name REGEXP &#x27;os&#x27;;SELECT * FROM store_info WHERE Store_Name REGEXP &#x27;^[A-G]&#x27;;SELECT * FROM store_info WHERE Store_Name REGEXP &#x27;Ho|Bo&#x27;; 12. 存储过程存储过程是一组为了完成特定功能的 SQL 语句集合。 存储过程在使用过程中是将常用或者复杂的工作预先使用 SQL 语句写好并用一个指定的名称存储起来，这个过程经编译和优化后存储在数据库服务器中。当需要使用该存储过程时，只需要调用它即可。存储过程在执行上比传统 SQL 速度更快、执行效率更高。 存储过程的优点： 1、执行一次后，会将生成的二进制代码驻留缓冲区，提高执行效率 2、SQL 语句加上控制语句的集合，灵活性高 3、在服务器端存储，客户端调用时，降低网络负载 4、可多次重复被调用，可随时修改，不影响客户端调用 5、可完成所有的数据库操作，也可控制数据库的信息访问权限 12.1 创建存储过程123456DELIMITER $$ #将语句的结束符号从分号;临时改为两个$$(可以是自定义)CREATE PROCEDURE Proc() #创建存储过程，过程名为Proc，不带参数-&gt; BEGIN #过程体以关键字 BEGIN 开始-&gt; select * from Store_Info; #过程体语句-&gt; END $$ #过程体以关键字 END 结束DELIMITER ; #将语句的结束符号恢复为分号 实例 12345678DELIMITER $$ #将语句的结束符号从分号;临时改为两个$$(可以自定义)CREATE PROCEDURE Proc5() #创建存储过程，过程名为Proc5，不带参数-&gt; BEGIN #过程体以关键字 BEGIN 开始-&gt; create table user (id int (10), name char(10),score int (10));-&gt; insert into user values (1, &#x27;cyw&#x27;,70);-&gt; select * from cyw; #过程体语句-&gt; END $$ #过程体以关键字 END 结束DELIMITER ; #将语句的结束符号恢复为分号 12.2 调用存储过程1CALL Proc; 12.3 查看存储过程SHOW CREATE PROCEDURE [数据库.]存储过程名; #查看某个存储过程的具体信息 123SHOW CREATE PROCEDURE Proc;SHOW PROCEDURE STATUS [LIKE &#x27;%Proc%&#x27;] \\G 12.4 存储过程的参数**IN 输入参数：**表示调用者向过程传入值（传入值可以是字面量或变量） **OUT 输出参数：**表示过程向调用者传出值(可以返回多个值)（传出值只能是变量） **INOUT 输入输出参数：**既表示调用者向过程传入值，又表示过程向调用者传出值（值只能是变量） 12345678DELIMITER $$CREATE PROCEDURE Proc6(IN inname CHAR(16))-&gt; BEGIN-&gt; SELECT * FROM store_info WHERE Store_Name = inname;-&gt; END $$DELIMITER ;CALL Proc6(&#x27;Boston&#x27;); 12.5 修改存储过程12345ALTER PROCEDURE &lt;过程名&gt;[&lt;特征&gt;... ]ALTER PROCEDURE GetRole MODIFIES SQL DATA SQL SECURITY INVOKER;MODIFIES sQLDATA:表明子程序包含写数据的语句SECURITY:安全等级invoker:当定义为INVOKER时，只要执行者有执行权限，就可以成功执行。 12.6 删除存储过程存储过程内容的修改方法是通过删除原有存储过程，之后再以相同的名称创建新的存储过程。如果要修改存储过程的名称，可以先删除原存储过程，再以不同的命名创建新的存储过程。 12DROP PROCEDURE IF EXISTS Proc;#仅当存在时删除，不添加 IF EXISTS 时，如果指定的过程不存在，则产生一个错误 13. 条件语句if-then-else ···· end if 12345678910111213141516mysql&gt; delimiter $$mysql&gt;mysql&gt; CREATE PROCEDURE proc8(IN pro int) -&gt; -&gt; begin -&gt; -&gt; declare var int; -&gt; set var=pro*2; -&gt; if var&gt;=10 then -&gt; update t set id=id+1; -&gt; else -&gt; update t set id=id-1; -&gt; end if; -&gt; end $$mysql&gt; delimiter ; 14. 循环语句while ···· end while 12345678910111213mysql&gt; delimiter $$mysql&gt;mysql&gt; create procedure proc9() -&gt; begin -&gt; declare var int(10); -&gt; set var=0; -&gt; while var&lt;6 do -&gt; insert into t values(var); -&gt; set var=var+1; -&gt; end while; -&gt; end $$mysql&gt; delimiter ; 15. 视图表 create view15.1 视图表概述视图，可以被当作是虚拟表或存储查询。 视图跟表格的不同是，表格中有实际储存数据记录，而视图是建立在表格之上的一个架构，它本身并不实际储存数据记录。 临时表在用户退出或同数据库的连接断开后就自动消失了，而视图不会消失。 视图不含有数据，只存储它的定义，它的用途一般可以简化复杂的查询。 比如你要对几个表进行连接查询，而且还要进行统计排序等操作，写 sql 语句会很麻烦的，用视图将几个表联结起来，然后对这个视图进行查询操作，就和对一个表查询一样，很方便。 15.2 视图表能否修改？首先我们需要知道，视图表保存的是 select 语句的定义，所以视图表可不可以修改需要视情况而定。 如果 select 语句查询的字段是没有被处理过的源表字段，则可以通过视图表修改源表数据； 如果 select 语句查询的字段是被 group by 语句或 函数 处理过的字段，则不可以直接修改视图表的数据。 123create view v_store_info as select store_name,sales from store_info;update v_store_info set sales=1000 where store_name=&#x27;Houston&#x27;; 123create view v_sales as select store_name,sum(sales) from store_info group by store_name having sum(sales)&gt;1000;update v_sales set store_name=&#x27;xxxx&#x27; where store_name=&#x27;Los Angeles&#x27;; 15.3 基本语法15.3.1 创建视图表12语法create view &quot;视图表名&quot; as &quot;select 语句&quot;; 12create view v_region_sales as select a.region region,sum(b.sales) sales from location ainner join store_info b on a.store_name = b.store_name group by region; 15.4 查看视图表12语法select * from 视图表名; 1select * from v_region_sales; 15.5 删除视图表12语法drop view 视图表名; 1drop view v_region_sales; 15.6 通过视图表求无交集值将两个表中某个字段的不重复值进行合并 只出现一次（count &#x3D;1 ） ，即无交集 通过 123create view 视图表名 as select distinct 字段 from 左表 union all select distinct 字段 from 右表;select 字段 from 视图表名 group by 字段 having count(字段)=1; 12#先建立视图表create viem v_union as select distinct store_name from location union all select distinct store_name from store_info; 12#再通过视图表求无交集select store_name from v_union group by store_name having count(*)=1;","tags":["SQL"],"categories":["SQL"]},{"title":"PHP基础知识总结","path":"/2024/03/01/PHP基础知识总结/","content":"PHP是什么PHP全称“PHP: Hypertext Preprocessor”，是超文本预处理器的字母缩写 PHP是一种创建动态交互性站点的服务器端脚本语言。 PHP文件可包含HTML、JavaScript代码和PHP代码，PHP代码在服务器上执行，结果以纯HTML形式返回给浏览器。 PHP文件的默认文件扩展名是 “.php” PHP 能做什么PHP具有访问文件系统和数据库的能力，主要用于web开发，生成动态页面内容。早期很多的CMS（内容管理系统）都是基于PHP开发的，比如：WordPress、Discuz、phpcms等。 安装PHP是一种服务器端脚本语言，需要安装PHP服务器环境才能运行PHP脚本。PHP的服务器环境由以下几个部分组成： Web 服务器 PHP 解析器 DBMS 数据库管理系统，比如 MySQL 推荐安装集成开发环境 WAMP 或者 XAMPP 进入交互模式在交互模式下，你可以输入PHP代码并立即看到结果，而不需要创建一个PHP文件。 在命令行中输入 php -a 进入交互模式 交互模式是一个练习和测试PHP代码的环境 1php -a 基本语法PHP基本语法相关的练习，可参考代码库(https://gitee.com/stephenykk/php-starter) 以下示例中的自定义方法定义在common.php中, 内容如下: 123456789101112131415161718192021222324252627282930313233&lt;?phpfunction clog($msg, $tag = &#x27;p&#x27;)&#123; // echo $msg, &quot; &quot;; echo &quot;&lt;$tag&gt;&quot;, $msg, &quot;&lt;/$tag&gt;&quot;;&#125;function newline()&#123; echo &quot;&lt;br/&gt;&quot;;&#125;function clogList($arr)&#123; echo &quot;&lt;ol&gt;&quot;; foreach ($arr as $val) &#123; clog($val, &#x27;li&#x27;); &#125; echo &quot;&lt;/ol&gt;&quot;;&#125;function title($ttl, $level = 2)&#123; $tag = &quot;h$level&quot;; clog($ttl, $tag);&#125;function comment($con)&#123; clog(&#x27;:: &#x27; . $con, tag: &#x27;blockquote&#x27;);&#125;?&gt; 脚本位置PHP脚本可放在文档的任何位置，PHP脚本以 &lt;?php 开始，以 ?&gt; 结束 还支持短标签 &lt;? ... ?&gt;，但是不推荐使用 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;My first PHP page&lt;/h1&gt;&lt;?phpecho &quot;Hello World!&quot;;?&gt;&lt;/body&gt;&lt;/html&gt; 语句结束符 每条PHP语句都必须以分号(;)结束，否则会报错 12345678&lt;h1&gt;My first PHP page&lt;/h1&gt;&lt;?php$a = 10;$b = 20;echo &quot;Hello 10 + 20 = &quot; . ($a + $b);?&gt; 注释方式和大多数程序语言一样，用 // 表示单行注释，/* */ 表示多行注释 12345678910111213&lt;h1&gt;My first PHP page&lt;/h1&gt;&lt;?php//This is a PHP comment line/*This isa PHP commentblock*/?&gt; 输出语句PHP 有四种基本的输出方式： echo 输出一个或多个字符串 print 输出一个字符串 print_r 以易读的格式打印关联数组&#x2F;对象变量 var_dump 打印变量的相关信息 输出字符串的话，用 echo 和 print 都可以，区别在于 echo 可以输出多个字符串，而 print 只能输出一个字符串。 echo 输出的速度比 print 快， echo 没有返回值，print 有返回值 1 1234567891011121314151617181920&lt;?phpecho &quot;Hello World!&quot;;// 可用逗号分隔多个字符串，echo 会将它们连接起来echo &quot;good&quot;, &quot;day&quot; // goodday// 以命令/函数的形式调用 printprint &quot;Hello World!&quot;;print(&#x27;Hello world&#x27;);// print只能传入一个字符串参数。print(&quot;Hello&quot;, &quot;Alice&quot;); // 报错print &quot;hello&quot;, &quot;Alice&quot;; // 报错// print_r() 输出对象/关联数组变量$colors = array(&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;);print_r($colors);// var_dump() 输出变量的相关信息$msg = &quot;hero&quot;;var_dump($msg);?&gt; 输出变量和字符串 1234567891011&lt;?php$msg=&quot;Learn PHP&quot;;// 直接输出变量echo $msg;// 双引号字符串内部可插入变量，单引号不支持变量插值echo &quot;today, let us $txt2&quot;; // 用大括号 显式的指定这是变量echo &quot;My car is a &#123;$cars[0]&#125;&quot;; ?&gt; 变量变量以 $ 符号开始，后面跟着变量的名称, 如: $color, $color = red PHP 没有声明变量的命令， 变量在您第一次赋值给它的时候被创建。 1234&lt;?php$msg = &quot;hero&quot;;echo &quot;hello &quot;, $msg;?&gt; PHP 是一门弱类型语言, 会自动将变量做类型转换。 在强类型的编程语言中，我们必须在使用变量前先声明（定义）变量的类型和名称。 作用域PHP 有四种不同的变量作用域： 局部作用域 全局作用域 静态作用域 参数作用域 局部作用域函数内部为局部作用域，在函数内部声明的变量为局部变量，只能在函数内部访问。 1234567&lt;?phpfunction mySum($n) &#123; $m = 10; // 局部变量 return $n + $m;&#125;?&gt; 全局作用域函数外部为全局作用域，函数外部声明的变量称为全局变量 函数内部访问全局变量，需要加 global 声明 PHP不会自动沿着作用域链去查找变量。 12345678&lt;?php$user = &#x27;Alice&#x27;;function outputUser() &#123; global $user; // global声明 echo $user;&#125;?&gt; 静态作用域静态变量仅在局部作用域中存在，当程序执行离开此作用域时，其值并不丢失。 静态变量在函数调用之间保持其值，类似的特性在其他语言中很少见。 1234567891011121314151617181920212223&lt;?phpfunction countUp() &#123; static $x = 0; $x++; echo &#x27;$x is: &#x27; , $x , &quot; &quot;;&#125;countUp();countUp();countUp();// -------$x=5;$y=10;function myTest()&#123;global $x,$y;$y=$x+$y;&#125;myTest();echo $y; // 输出 15?&gt; 参数作用域参数是通过调用代码将值传递给函数的局部变量, 参数是在参数列表中声明的，作为函数声明的一部分 123456&lt;?phpfunction myTest($x) &#123; $x++; echo $x;&#125;?&gt; 超全局变量PHP 中预定义了不少超级全局变量（superglobals）, 它们在全部作用域中都可直接使用。 $GLOBALS $_SERVER $_REQUEST $_POST $_GET $_COOKIE $_FILES $_ENV $_SESSION $GLOBALSPHP将所有全局变量存储在一个名为 $GLOBALS 的数组中。 这个数组可以在函数内部访问，可直接用来更新全局变量。 超全局变量 $GLOBALS 可直接访问，不需要加 global 声明 123456789101112&lt;?php$x=5;$y=10;function myTest()&#123; $GLOBALS[&#x27;y&#x27;] = $GLOBALS[&#x27;x&#x27;]+$GLOBALS[&#x27;y&#x27;];&#125;myTest();echo $y;?&gt; $_SERVER$_SERVER是一个包含服务端信息的关联数组 123456789101112131415&lt;?phpecho $_SERVER[&#x27;SERVER_NAME&#x27;];echo $_SERVER[&#x27;SERVER_PROTOCOL&#x27;];echo $_SERVER[&#x27;REQUEST_METHOD&#x27;];echo $_SERVER[&#x27;HTTP_HOST&#x27;];echo $_SERVER[&#x27;HTTP_REFERER&#x27;]; echo $_SERVER[&#x27;HTTP_USER_AGENT&#x27;]; // /try/demo_source/demo_global_server.phpecho $_SERVER[&#x27;PHP_SELF&#x27;]; // /try/demo_source/demo_global_server.phpecho $_SERVER[&#x27;SCRIPT_NAME&#x27;]; ?&gt; $_REQUEST$_REQUEST 用于收集 HTML 表单提交的数据。 1234567891011&lt;form method=&quot;post&quot; action=&quot;&lt;?php echo $_SERVER[&#x27;PHP_SELF&#x27;];?&gt;&quot;&gt; Name: &lt;input type=&quot;text&quot; name=&quot;fname&quot;&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;?php $name = $_REQUEST[&#x27;fname&#x27;]; echo $name;?&gt; $_POST$_POST 用于收集POST方式提交的表单数据 12345678910&lt;!--页面post给自己--&gt;&lt;form method=&quot;post&quot; action=&quot;&lt;?php echo $_SERVER[&#x27;PHP_SELF&#x27;];?&gt;&quot;&gt; Name: &lt;input type=&quot;text&quot; name=&quot;fname&quot;&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;?php $name = $_POST[&#x27;fname&#x27;]; echo $name;?&gt; $_GET$_GET 用于收集GET方式提交的表单数据&#x2F;URL中发送的数据 123456&lt;a href=&quot;test_get.php?subject=PHP&amp;web=w3cschool.cc&quot;&gt;Test $GET&lt;/a&gt;&lt;?php echo &quot;Study &quot; . $_GET[&#x27;subject&#x27;] . &quot; at &quot; . $_GET[&#x27;web&#x27;];?&gt; 数据类型PHP的数据类型包括: string, integer, float, boolean, array, object, null var_dump() 可查看变量的数据类型 字符串可以将任何文本放在单引号和双引号中 123456789&lt;?php// 双引号 包含的字符串可插入变量$name = &#x27;Alice&#x27;;$x = &quot;Hello $name!&quot;;// 单引号 包括字符串字面量 $x = &#x27;Hello world!&#x27;; ?&gt; 和其他语言很不同的是，字符串连接用 . 操作符 转义序列在双引号中才有效 12345678&lt;?php// 字符串连接$x = &quot;Hello&quot; . &quot; world!&quot;;// 字符串转义$x = &quot;Hello world! &quot;;?&gt; 字符串函数 12345678&lt;?php//获取字符串长度echo strlen(&quot;Hello world!&quot;); //获取子串位置echo strpos(&quot;Hello world!&quot;,&quot;world&quot;); ?&gt; 整型整型数值有多种进制表示形式，进制转换函数 base_convert() 1234567891011&lt;?php// 十进制$x = 5985;$x = -345; // negative number// 十六进制 0x开头$x = 0x8C;// 八进制 0开头$x = 047;?&gt; 浮点型浮点数即小数，可用科学计数法表示 123456789&lt;?php$x = 10.365;// 科学计数法$x = 2.4e3;$x = 8E-5;?&gt; 布尔型布尔型只有两个值: true 和 false 1234567&lt;?php$isLike = false;if ($color == &quot;blue&quot;) &#123; $isLike = true;&#125;?&gt; 数组一个数组变量可以存储多个值数组是很常用的数据结构，分为：普通数组和关联数组 用序号做索引的叫普通数组，用字符串做索引的叫关联数组 12345678910&lt;?php// 普通数组$cars = array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);print_r($cars);echo $cars[0];// 关联数组$captain = array(&quot;name&quot; =&gt; &quot;Lufy&quot;, &quot;age&quot; =&gt; 18);echo $captain[&quot;name&quot;];?&gt; 数组的使用 123456789101112131415161718192021&lt;?php$cars = array(&quot;Volvo&quot;, &quot;BMW&quot;, &quot;Toyota&quot;); // 访问元素echo &quot;I like &quot; . $cars[0] . &quot;, &quot; . $cars[1]; // 获取长度echo count($cars);// 遍历$len = count($cars);for ($i = 0; $i &lt; $len; $i++) &#123; echo $cars[$i];&#125;// 遍历关联数组$lufy = array(&quot;name&quot; =&gt; &quot;Lufy&quot;, &quot;skill&quot; =&gt; &quot;stretch&quot;, &quot;age&quot; =&gt; 11);foreach ($lufy as $key =&gt; $value) &#123; echo &quot;Key=&quot; . $key . &quot;, Value=&quot; . $value;&#125;?&gt; 数组排序 sort() 对数组进行升序排列 rsort() 对数组进行降序排列 asort() 根据关联数组的值，对数组进行升序排列 arsort() 根据关联数组的值，对数组进行降序排列 ksort() 根据关联数组的键，对数组进行升序排列 krsort() 根据关联数组的键，对数组进行降序排列 123456789101112131415161718192021&lt;?php// sort()$cars = array(&quot;Volvo&quot;, &quot;BMW&quot;, &quot;Toyota&quot;);sort($cars);$len = count($cars);for ($x = 0; $x &lt; $len; $x++) &#123; echo $cars[$x];&#125;// rsort()rsort($cars);//asort() arsort() 关联数组排序 value$friendAges = array(&quot;Peter&quot; =&gt; 33, &quot;Ben&quot; =&gt; 36, &quot;Joe&quot; =&gt; 24);asort($friendAges);arsort($friendAges);//ksort() krsort() 关联数组排序 keyksort($friendAges);krsort($friendAges); 对象先用 class 关键字创建自定义类，然后使用 new 关键字创建对象 PHP用箭头 -&gt; 访问对象的属性和方法 123456789101112131415161718192021222324252627&lt;?phpclass Car&#123; var $color; function Car($color=&quot;green&quot;) &#123; $this-&gt;color = $color; &#125; function getcolor() &#123; return $this-&gt;color; &#125;&#125;function print_vars($obj) &#123; // 遍历关联数组 foreach (get_object_vars($obj) as $prop =&gt; $val) &#123; echo &quot;\\t$prop = $val &quot;; &#125;&#125;$myCar = new Car(&quot;white&quot;);// show myCar propertiesprint_vars($myCar);?&gt; nullnull值表示变量没有值null类型只有一个值，就是 null 1234567&lt;?php$x = &quot;Hello world!&quot;;$x = null;var_dump($x);?&gt; 常量常量是一个简单值的标识符，常量在脚本中不能改变，并且在整个脚本中都可以使用 常量名不需要加 $ 修饰符 定义常量，使用 define() 函数： define(string constant_name, mixed value, case_sensitive = true) 该函数有三个参数: constant_name：必选参数，常量名称，即标志符。 value：必选参数，常量的值。 case_sensitive：可选参数，指定是否大小写敏感，设定为 true 表示不敏感。 123456&lt;?phpdefine(&quot;GREETING&quot;, &quot;Welcome to Hero College!&quot;);echo GREETING;?&gt; 运算符 逻辑运算符： !, &amp;&amp;, ||, and, or, xor 关系运算符： ==, !=, &lt;&gt;, ===, !== === 检查类型和值是否都相等，!== 检查类型和值是否不完全相等 123456789101112131415161718192021&lt;?php//数组运算符 合并: + $x = array(&quot;a&quot; =&gt; &quot;red&quot;, &quot;b&quot; =&gt; &quot;green&quot;);$y = array(&quot;c&quot; =&gt; &quot;blue&quot;, &quot;d&quot; =&gt; &quot;yellow&quot;);$z = $x + $y; // $x 和 $y 数组合并var_dump($z);// 绝对相等: ===$n = 10;$s = &#x27;10&#x27;var_dump($n == $s); // truevar_dump($n === $s); // false// 数组绝对相等，要求对应位置的键值绝对相等(值和类型都相等)$a = array(10, &#x27;20&#x27;)$b = array(&#x27;10&#x27;, 20)var_dump($a == $b); // truevar_dump($a === $b); // false?&gt; 流程控制分支和循环流程的控制语法和JAVA等语言一样 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?php$t = date(&quot;H&quot;);// 单分支if ($t &lt; &quot;20&quot;) &#123; echo &quot;Have a good day!&quot;;&#125;$t = date(&quot;H&quot;);// 双分支if ($t &lt; &quot;20&quot;) &#123; echo &quot;Have a good day!&quot;;&#125; else &#123; echo &quot;Have a good night!&quot;;&#125;$t = date(&quot;H&quot;);// 多分支if ($t &lt; &quot;10&quot;) &#123; echo &quot;good morning!&quot;;&#125; else if ($t &lt; &quot;20&quot;) &#123; echo &quot;good day!&quot;;&#125; else &#123; echo &quot;good night!&quot;;&#125;$favcolor = &quot;red&quot;;// 多分支switch ($favcolor) &#123; case &quot;red&quot;: echo &quot;Your favorite color is red!&quot;; break; case &quot;blue&quot;: echo &quot;Your favorite color is blue!&quot;; break; case &quot;green&quot;: echo &quot;Your favorite color is green!&quot;; break; default: echo &quot;Your favorite color is others&quot;;&#125;// 条件循环$i = 1;while ($i &lt;= 5) &#123; echo &quot;The number is &quot; . $i . &quot;&lt;br&gt;&quot;; $i++;&#125;$i = 1;do &#123; $i++; echo &quot;The number is &quot; . $i . &quot;&lt;br&gt;&quot;;&#125;while ($i &lt;= 5);// 固定次数循环for ($i = 1; $i &lt;= 5; $i++) &#123; echo &quot;The number is &quot; . $i . &quot;&lt;br&gt;&quot;;&#125;// 循环遍历$x = array(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;);foreach ($x as $value) &#123; echo $value . &quot;&lt;br&gt;&quot;;&#125;?&gt; 函数PHP 的真正威力源自于它的函数, 在 PHP 中，提供了超过 1000 个内建的函数。 123456789101112131415161718&lt;?php// 函数传参function outputMessage($fname, $punctuation)&#123; echo $fname . &quot; laugh&quot; . $punctuation . &quot;&lt;br&gt;&quot;;&#125;outputMessage(&quot;Nami&quot;, &quot;!!&quot;);// 函数返回值function add($x, $y)&#123; $total = $x + $y; return $total;&#125;echo &quot;1 + 16 = &quot; . add(1, 16);?&gt; 魔术变量魔术常量的值跟它们在代码中的位置相关，不同位置会返回不同的值 __LINE__ 文件中的当前行号。 __FILE__ 文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名。 __DIR__ 文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录。 __FUNCTION__ 返回该函数被定义时的名字 123456&lt;?phpfunction test() &#123; echo &#x27;函数名为：&#x27; . __FUNCTION__ ;&#125;test();?&gt; __CLASS__ 返回该类被定义时的名字 类名包括其被声明的作用区域（例如 Foo\\Bar）__CLASS__ 对 trait 也起作用。当用在 trait 方法中时，__CLASS__ 是调用 trait 方法的类的名字。 12345678910&lt;?phpclass Car &#123; function printInfo() &#123; echo &#x27;类名为：&#x27; . __CLASS__ . &quot;&lt;br&gt;&quot;; echo &#x27;函数名为：&#x27; . __FUNCTION__ ; &#125;&#125;$t = new Car();$t-&gt;printInfo();?&gt; __TRAIT__ Trait 的名字, 自 PHP 5.4.0 起，PHP 实现了代码复用的一个方法，称为 traits。 Trait 名包括其被声明的作用区域（例如 Foo\\Bar）。 从基类继承的成员sayHello被插入的 SayWorld Trait 中的 sayHello 方法所覆盖。 优先顺序是： 当前类中的方法会覆盖 trait 方法， trait 方法又覆盖了基类中的方法。 123456789101112131415161718192021&lt;?phpclass Base &#123; public function sayHello() &#123; echo &#x27;Hello &#x27;; &#125;&#125;trait SayWorld &#123; public function sayHello() &#123; parent::sayHello(); echo &#x27;World!&#x27;; &#125;&#125;class MyHelloWorld extends Base &#123; use SayWorld;&#125;$o = new MyHelloWorld();$o-&gt;sayHello();?&gt; __METHOD__ 返回方法名&#x2F;函数名 123456&lt;?phpfunction test() &#123; echo &#x27;函数名为：&#x27; . __METHOD__ ;&#125;test();?&gt; __NAMESPACE__ 返回当前命名空间的名称 12345&lt;?phpnamespace MyProject;echo &#x27;命名空间为：&quot;&#x27;, __NAMESPACE__, &#x27;&quot;&#x27;; // 输出 &quot;MyProject&quot;?&gt; 动态语言特征PHP支持动态访问类、函数和常量 类和函数的名称存在变量中，然后用该变量动态调用类和函数，这种极其动态的访问方式很强大，但是不常用 1234567891011121314151617181920212223//example.php&lt;?phpclass MyClass &#123; function __construct() &#123; echo __METHOD__, &quot; &quot;; &#125;&#125;function myFunction()&#123; echo __FUNCTION__, &quot; &quot;;&#125;const MY_FAV = &quot;LEARNING&quot;;$a = &#x27;MyClass&#x27;;$obj = new $a; // MyClass::__construct$b = &#x27;myFunction&#x27;;$b(); // myFunctionecho constant(&#x27;MY_FAV&#x27;), &quot; &quot;; // LEARNING?&gt; 命名空间PHP 命名空间(namespace)是在 PHP 5.3 中加入的，如果你学过 C#和 Java，那命名空间就不算什么新事物。 不过在 PHP 当中还是有着相当重要的意义。 PHP 命名空间可以解决以下两类问题： 用户代码与 PHP 内部的类&#x2F;函数&#x2F;常量之间的名字冲突。 创建别名，提高源代码的可读性。 默认情况下，所有常量、类和函数名都放在全局空间下，就和 PHP 支持命名空间之前一样。如果一个文件中包含命名空间，它必须在其它所有代码之前声明命名空间 声明 MyProject 命名空间 12345&lt; ?phpnamespace MyProject;// ... 代码 ... 也可以在同一个php文件中定义不同的命名空间代码 123456789101112namespace MyProject1;// MyProject1 命名空间中的PHP代码namespace MyProject2;// MyProject2 命名空间中的PHP代码// 另一种语法namespace MyProject3 &#123; // MyProject3 命名空间中的PHP代码&#125;?&gt; 在声明命名空间之前，唯一合法的代码是用于定义源文件编码方式的 declare 语句。所有非 PHP 代码包括空白符都不能出现在命名空间的声明之前。 123456789101112131415&lt;?phpdeclare(encoding=&#x27;UTF-8&#x27;);namespace MyProject &#123; const CONNECT_OK = 1; class Connection &#123; /* ... */ &#125; function connect() &#123; /* ... */ &#125;&#125;// namespace不带名称，则表示全局命名空间namespace &#123; session_start(); $a = MyProject\\connect(); echo MyProject\\Connection::start();&#125;?&gt; 以下代码会出现语法错误： 12345&lt;html&gt;&lt;?phpnamespace MyProject; // 命名空间前出现了“&lt;html&gt;” 会致命错误?&gt; 子命名空间类似父文件夹包含子文件夹，命名空间下还可以划分子命名空间。子命名空间同样可以包含类、函数和常量等。 12345678910&lt;?phpnamespace MyProject\\Sub\\Level;const CONNECT_OK = 1;class Connection &#123; /* ... */ &#125;function Connect() &#123; /* ... */ &#125;?&gt; 命名空间的使用PHP命名空间里的类可以通过三种方式引用：非限定名称，限定名称，完全限定名称。 非限定名称 非限定名称即不包含前缀的类名称。 用非限定名称访问类和类的静态方法 123$a = new Foo(); Foo::staticmethod();?&gt; 如果当前命名空间是 MyBlog, 则 Foo 将被解析为 MyBlog\\Foo。非限定名称的引用默认在当前命名空间查找，找不到的话就会到全局命名空间找 不完全限定名称不完全限定名称，即包含相对前缀的类名称。 123456789101112$a = new BlogCommon\\Foo(); BlogCommon\\Foo::staticmethod();?&gt;``` 如果当前的命名空间是 `MyBlog` 则 `Foo` 会被解析为 `MyBlog\\BlogCommon\\Foo`。带相对命名空间前缀的引用，自动在开头添加调用代码所处的命名空间 (*类似相对路径*)3. 完全限定名称 包含了全局前缀操作符的名称```php$a = new \\MyBlog\\Foo();\\MyBlog\\Foo::staticmethod();?&gt; Foo 总是被解析为 \\MyBlog\\Foo。带绝对命名空间前缀的引用,引用路径已明确，不会添加任何前缀。(类似绝对路径) 命名空间综合示例假设现在有两个文件：lufy.php 和 onePiece.php，它们分别属于两个不同的命名空间 OnePiece\\Lufy 和 OnePiece lufy.php 代码如下 12345678910111213&lt;?phpnamespace OnePiece\\Lufy;const FAV = &#x27;Eating&#x27;;function sayHi() &#123; echo &quot;hello everyone&quot;;&#125;class Ability &#123; static function learn($name) &#123; echo &quot;Lufy is learning ability $name!&quot;; &#125;&#125;?&gt; onePiece.php 代码如下 123456789101112131415161718192021222324252627282930313233343536&lt;?phpnamespace OnePiece;include &#x27;lufy.php&#x27;;const FAV = &#x27;Opening Party&#x27;;function sayHi() &#123; echo &quot;hi, everyone! we are a team!&quot;;&#125;class Ability &#123; static function learn($name) &#123; echo &quot;Zoro and others are learning ability $name!&quot;; &#125;&#125;// 非限定名称// 解析为 \\OnePiece\\sayHisayHi();// 解析为 \\OnePiece\\Ability::learnAbility::learn(&#x27;php&#x27;); // 不完全限定名称// 解析为 \\OnePiece\\Lufy\\sayHiLufy\\sayHi(); // 解析为类 \\OnePiece\\Lufy\\Ability, 以及类的方法 learnLufy\\Ability::learn(&#x27;php&#x27;); // 完全限定名称\\OnePiece\\Lufy\\sayHi(); \\OnePiece\\Lufy\\Ability::learn(&#x27;php&#x27;);?&gt; 命名空间内访问全局空间在命名空间内部访问全局类、函数和常量, 用 \\ 前缀即可： 1234567891011&lt;?phpnamespace Foo;function strlen() &#123;&#125;const INI_ALL = 3;class Exception &#123;&#125;$a = \\strlen(&#x27;hi&#x27;); // 调用全局函数strlen$b = \\INI_ALL; // 访问全局常量 INI_ALL$c = new \\Exception(&#x27;error&#x27;); // 实例化全局类 Exception?&gt; 动态访问命名空间动态访问命名空间下的类、函数和常量 1234567891011121314151617181920212223&lt;?phpnamespace OnePiece;class MyClass &#123; function __construct() &#123; echo __METHOD__, &quot; &quot;; &#125;&#125;function myFunction() &#123; echo __FUNCTION__, &quot; &quot;;&#125;const MY_CODE = &quot;TIDY&quot;;$a = &#x27;OnePiece\\MyClass&#x27;;$obj = new $a(); // OnePiece\\MyClass::__construct$b = &#x27;OnePiece\\myFunction&#x27;;$b(); // OnePiece\\myFunctionecho constant(&#x27;OnePiece\\MY_CODE&#x27;), &quot; &quot;; // TIDY?&gt; 命名空间魔术变量命名空间魔术变量 __NAMESPACE__的值是当前命名空间名称，在全局命名空间中的，它的值为空字符串 12345&lt;?phpnamespace MyProject;echo &#x27;&quot;&#x27;, __NAMESPACE__, &#x27;&quot;&#x27;; // 输出 &quot;MyProject&quot;?&gt; 使用__NAMESPACE__动态访问类，并创建实例。 123456789&lt;?phpnamespace MyProject;function get($classname)&#123; $a = __NAMESPACE__ . &#x27;\\\\&#x27; . $classname; return new $a;&#125;?&gt; namespace关键字关键字 namespace 的作用有两个 声明一个命名空间 用来显式访问当前命名空间或子命名空间中的元素。它等价于类中的 self 操作符。 1234567891011121314151617181920&lt;?phpnamespace OnePiece;function sayHi() &#123; echo &quot;Hi, everybody~~&quot;;&#125;class Ability &#123; static function learn($name) &#123; echo &quot;I can learn &quot;, $name, &quot; &quot;; &#125;&#125;const LIKE_COLOR = &#x27;SKY-BLUE&#x27;;namespace\\sayHi(); namespace\\Ability::learn(&#x27;PHP&#x27;); echo namespace\\LIKE_COLOR; ?&gt; 命名空间别名PHP支持为命名空间和命名空间内部类定义别名 注意：PHP不支持为导入命名空间内的函数或常量定义别名。 使用 use 关键字定义别名 captain-lufy.php代码如下: 1234567891011121314151617181920212223242526272829303132&lt;?phpnamespace Cartoon\\OnePiece\\Lufy;include &#x27;inc/header.php&#x27;;function sayHi()&#123; clog(&quot;hi, I am lufy&quot;);&#125;class Hobby&#123; var $likings; function add($name) &#123; $this-&gt;likings[] = $name; &#125; function show() &#123; print_r($this-&gt;likings); &#125;&#125;// $lufyHobby = new Hobby();// $lufyHobby-&gt;add(&#x27;eating&#x27;);// $lufyHobby-&gt;add(&#x27;sleeping&#x27;);// $lufyHobby-&gt;show();include &#x27;inc/footer.php&#x27;; use-namespace.php用于测试命名空间别名，代码如下 12345678910111213141516171819&lt;?phpinclude &#x27;captain-lufy.php&#x27;;// 直接用完整命名空间路径引用里面的方法Cartoon\\OnePiece\\Lufy\\sayHi();// 同 use Cartoon\\OnePiece\\Lufy as Lufy;use Cartoon\\OnePiece\\Lufy;Lufy\\sayHi();use Cartoon\\OnePiece\\Lufy as Lu;Lu\\sayHi();// 可以给命名空间内的类起别名use Cartoon\\OnePiece\\Lufy\\Hobby as Hob;$hob = new Hob();$hob-&gt;add(&#x27;running&#x27;);$hob-&gt;show(); 一行中包含多个 use 语句 123456&lt;?phpuse My\\Full\\Classname as MyClass, My\\Full\\NSname;$obj = new MyClass; // 实例化 My\\Full\\Classname 对象NSname\\subns\\func(); // 调用函数 My\\Full\\NSname\\subns\\func?&gt; 导入操作是在编译执行的，但动态的类名称、函数名称或常量名称则不是。 1234567&lt;?phpuse My\\Full\\Classname as Another, My\\Full\\NSname;$obj = new Another; // 实例化一个 My\\Full\\Classname 对象$a = &#x27;Another&#x27;;$obj = new $a; // 实例化一个 Another 对象?&gt; 另外，导入操作只影响非限定名称和不完全限定名称。完全限定名称由于是确定的，故不受导入的影响。 12345678&lt;?phpuse My\\Full\\Classname as Another, My\\Full\\NSname;$obj = new Another; // instantiates object of class My\\Full\\Classname$obj = new \\Another; // instantiates object of class Another$obj = new Another\\thing; // instantiates object of class My\\Full\\Classname\\thing$obj = new \\Another\\thing; // instantiates object of class Another\\thing?&gt; 命名空间查找在一个命名空间中，当 PHP 遇到一个非限定的类、函数或常量名称时，它使用不同的优先策略来解析该名称。 类名总是解析到当前命名空间(找不到就会报错)。因此在访问系统内部或不包含在命名空间中的类名称时，必须使用完全限定名称 函数和常量来说，如果当前命名空间中不存在该函数或常量，PHP 会退而使用全局空间中的函数或常量。 123456789&lt;?phpnamespace A\\B\\C;class Exception extends \\Exception &#123;&#125;$a = new Exception(&#x27;hi&#x27;); // $a 是类 A\\B\\C\\Exception 的一个对象$b = new \\Exception(&#x27;hi&#x27;); // $b 是类 Exception 的一个对象$c = new ArrayObject; // 致命错误, 找不到 A\\B\\C\\ArrayObject 类?&gt; 全局命名空间如果没有定义任何命名空间，所有的类与函数的定义都是在全局空间，与 PHP 引入命名空间概念前一样。在名称前加上前缀 \\ 表示该名称是全局空间中的名称。 123456789&lt;?phpnamespace A\\B\\C;/* 这个函数是 A\\B\\C\\fopen */function fopen() &#123; $f = \\fopen(...); // 调用全局的fopen函数 return $f;&#125;?&gt; 文件处理打开文件打开文件用函数fopen() 12&lt;?php$file = fopen($fname, mode) //文件的名称, 打开模式 文件打开模式 r 只读。在文件的开头开始。 r+ 读&#x2F;写。在文件的开头开始。 w 只写。打开并清空文件的内容；如果文件不存在，则创建新文件。 w+ 读&#x2F;写。打开并清空文件的内容；如果文件不存在，则创建新文件。 a 追加。打开并向文件末尾进行写操作，如果文件不存在，则创建新文件。 a+ 读&#x2F;追加。通过向文件末尾写内容，来保持文件内容。 x 只写。创建新文件。如果文件已存在，则返回 FALSE 和一个错误。 x+ 读&#x2F;写。创建新文件。如果文件已存在，则返回 FALSE 和一个错误。 如果 fopen() 函数无法打开指定文件，则返回 0 (false)。 123456789101112131415&lt;?php//打开文件$file = fopen(&quot;welcome.txt&quot;, &quot;r&quot;) or exit(&quot;Unable to open file!&quot;);// Output a line of the file until the end is reached//是否到达文件末尾while(!feof($file))&#123;echo fgets($file). &quot;&lt;br&gt;&quot;; //逐行读取文件//echo fgetc($file); //逐字符读取&#125;//关闭文件fclose($file);?&gt; 文件系统相关的函数 basename() 返回路径中的文件名部分。 dirname() 返回路径中的目录名称部分。 realpath() 返回绝对路径名。 pathinfo() 返回关于文件路径的信息。 copy() 复制文件。 delete() 参见 unlink() 或 unset() rename() 重命名文件或目录。 mkdir() 创建目录。 rmdir() 删除空的目录。 unlink() 删除文件。 is_dir() 判断文件是否是一个目录。 is_file() 判断文件是否是常规的文件。 fstat() 返回关于一个打开的文件的信息。 fclose() 关闭打开的文件。 feof() 测试文件指针是否到了文件末尾。 fgetc() 从打开的文件中返回字符。 fgets() 从打开的文件中返回一行。 fgetss() 从打开的文件中返回一行，并过滤掉 HTML 和 PHP 标签。 file() 把文件读入一个数组中。 file_exists() 检查文件或目录是否存在。 file_get_contents() 把文件读入字符串。~~获取文件内容 file_put_contents() 把字符串写入文件。~~写入文件内容 fgetcsv() 从打开的文件中解析一行，校验 CSV 字段。 fputcsv() 把行格式化为 CSV 并写入一个打开的文件中。 filesize() 返回文件大小。 filetype() 返回文件类型。 fopen() 打开一个文件或 URL。 fread() 读取打开的文件。 readfile() 读取一个文件，并写入到输出缓冲。 fputs() fwrite() 的别名。 ftruncate() 把打开文件截断到指定的长度。 fwrite() 写入打开的文件。 fscanf() 根据指定的格式对输入进行解析。 fseek() 在打开的文件中定位。 ftell() 返回在打开文件中的当前位置。 rewind() 倒回文件指针的位置。 glob() 返回一个包含匹配指定模式的文件名&#x2F;目录的数组。 move_uploaded_file() 把上传的文件移动到新位置。 stat() 返回关于文件的信息。 JSON处理 json_encode() 对变量进行 JSON 编码 json_decode() 对 JSON 格式的字符串进行解码，转换为 PHP 变量 1234&lt;?php $arr = array(&#x27;a&#x27; =&gt; 1, &#x27;b&#x27; =&gt; 2, &#x27;c&#x27; =&gt; 3, &#x27;d&#x27; =&gt; 4, &#x27;e&#x27; =&gt; 5); echo json_encode($arr);?&gt; json字符串解码为php关联数组 12345&lt;?php $json = &#x27;&#123;&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3,&quot;d&quot;:4,&quot;e&quot;:5&#125;&#x27;; var_dump(json_decode($json)); var_dump(json_decode($json, true));?&gt; 面向对象PHP面向对象的基本用法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?phpinclude &quot;./inc/header.php&quot;;class Animal&#123; var $name; public function hi() &#123; echo &#x27;hi, &#x27;, $this-&gt;name, &quot; &quot;; &#125; public static function ho() &#123; // 单引号内的特殊序列不会被转义 eg: &#x27; &#x27; echo &#x27;ho func called&#x27;, &quot; &quot;; &#125; function move() &#123; echo &quot;animal is running&quot;; &#125;&#125;title(&#x27;面向对象&#x27;);comment(&#x27;访问属性和方法&#x27;);$dog = new Animal();$dog-&gt;name = &#x27;husky&#x27;;$dog-&gt;hi();comment(&#x27;可添加任意属性&#x27;);$dog-&gt;like = &#x27;running&#x27;;clog($dog-&gt;like);$prop = &#x27;name&#x27;;$arr = array(&#x27;name&#x27;, &#x27;like&#x27;);function getProp()&#123; global $arr; return $arr[1];&#125;comment(&#x27;访问动态属性(属性由变量或方法返回值决定)&#x27;);clog(getProp() . &#x27;&lt;==&#x27;);clog($dog-&gt;$prop);clog($dog-&gt;&#123;$prop&#125;);clog($dog-&gt;&#123;$arr[1]&#125;);clog($dog-&gt;&#123;getProp()&#125;);comment(&#x27;打印声明的类&#x27;);print_r(get_declared_classes());//var_dump(Animal); // error//print_r(Animal);comment(&#x27;打印类的方法&#x27;);print_r(get_class_methods($dog));comment(&#x27;打印对象&#x27;);print_r($dog);comment(&#x27;访问静态方法&#x27;);Animal::ho();comment(&#x27;查看对象有哪些属性 (即自省)&#x27;);print_r(get_object_vars($dog));comment(&#x27;三元运算符&#x27;);clog(&#x27;1&#x27; == 1 ? &#x27;yes&#x27; : &#x27;n&#x27;);clog(&#x27;1&#x27; == 10 ? &#x27;y&#x27; : &#x27;n&#x27;);include &#x27;inc/footer.php&#x27;; 模块化php可以通过 include , require, require_once等语句引入其他php模块。 header.php的代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;PHP Learning&lt;/title&gt; &lt;style&gt; body &#123; padding: 20px; font-weight: 200; &#125; h1, h2, h3, h4 &#123; font-weight: 500; text-align: center; &#125; blockquote &#123; margin: 0; margin-top: 30px; background: #eee; padding: 10px; border-radius: 4px; font-weight: 500; color: cadetblue; &#125; ul, ol &#123; margin: 30px 0; padding: 10px 30px; background: #f3fafa; &#125; li &#123; margin: 10px; font-size: 20px; font-style: italic; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;?php require_once &#x27;common.php&#x27;; ?&gt; module.php用于测试导入其他php模块 1234567891011&lt;?phpinclude &#x27;inc/header.php&#x27;;// require(&#x27;captain-lufy.php&#x27;);require &#x27;captain-lufy.php&#x27;;use Cartoon\\OnePiece\\Lufy;Lufy\\sayHi();include &#x27;inc/footer.php&#x27;; 总结本文从初学者的角度对PHP进行讲解，没有详细介绍比较常用的数组和面向对象等部分。如果本文的内容基本都掌握，看懂基础的PHP代码应该不成问题。 PHP曾经很流行，现在有些免费的虚拟机(如: infinityfree)多数提供的是PHP集成环境，可以让我们托管一些简单的个人应用，因而对PHP进行学习了解还是有点必要的。","tags":["PHP"],"categories":["PHP"]},{"title":"2023再看React状态管理库","path":"/2024/02/28/2023再看React状态管理库/","content":"原文地址2023 再看 React 状态管理库 - 掘金 什么是状态管理？状态状态是表示组件当前状况的 JS 对象。在 React 中，可以使用 useState 或者 this.state 维护组件内部状态，通过 props 传递给子组件使用。 为了避免状态传递过程中出现混乱，React 引入了“单向数据流”的理念。主要思想是组件不会改变接收的props数据，只会监听数据的变化，当数据发生变化时他们会使用接收到的新值，而不是修改已有的值。当组件的更新机制触发后，他们只是使用新值进行重新渲染。 组件通信父子组件可以直接使用 props 和 callback 方式；深层次组件则要通过“状态提升”和 props 层层传递。 常见模式React 状态管理的常见模式有： 状态提升：兄弟组件间是没法直接共享状态的，可以通过将状态提升到最近的祖先组件中，所有兄弟组件就可以通过 props 一级级传递获取状态； 状态组合：某些状态可能只在应用程序的特定子树中需要。最好将状态存储在尽可能接近实际需要的位置，这有助于优化渲染行为； 属性透传：将父组件的状态以 props 形式一级级传递给嵌套子组件； Provider：React Context 通过 Provider 包裹组件，被包裹的所有嵌套子组件都可以不用通过属性透传而是通过 context 直接获取状态。 层层传递的 value onChange 会对一个优质代码库带来的毁灭性影响，粗暴地把数据塞在 redux 中也并不能让一个应用得到很好的拓展性和可维护性。 要解决的问题状态管理库要解决的问题： 从组件树的「任何地方」读取存储的状态 写入存储状态的能力 提供「优化渲染」的机制 提供「优化内存使用」的机制 与「并发模式的兼容性」 数据的「持久化」 「上下文丢失」问题 「props 失效」问题 「孤儿」问题 心智模型状态更新有两种心智模型： 不可变状态模型 可变状态模型 主要好处是可以使用原生 JS 方法； 基于 Proxy 的状态管理的一个缺点是状态不可预测，难以 debug。 因为 React 没有官方的状态管理方案，React 生态中状态管理库，百花齐放，演进出很多设计思想和心智模式。如何选择状态管理库就变得十分令人抓狂。 React Context在多级嵌套组件场景下，使用“属性下钻”方式进行组件通信是一件成本极高的事情。为了解决这个问题，React 官方提供 Context 用于避免一级级属性传递。 Context 的问题Context的缺点Context 存在的问题也是老生常谈。在 react 里，context 是个反模式的东西，不同于 redux 等的细粒度响应式更新，context 的值一旦变化，所有依赖该 context 的组件全部都会 force update，因为 context API 并不能细粒度地分析某个组件依赖了 context 里的哪个属性，并且它可以穿透 React.memo 和 shouldComponentUpdate 的对比，把所有涉及的组件强制刷新。 React 官方文档在 When to Use Context一节中写道： Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言。 注意系统中跟业务相关会频繁变动的数据在共享时，应谨慎使用 context 如果决定使用 context，可以在一些场景中，将多个子组件依赖的不同 context 属性提升到一个父组件中，由父组件订阅 context 并以 prop 的方式下发，这样可以使用子组件的 memo、shouldComponentUpdate 生效。 此外，官方文档还提到了另外一个坑，使用的时候也应该注意。 优点 作为 React 内置的 hook，不需要引入第三方库； 书写还算方便。 缺点 Context 只能存储单一值，当数据量大起来时，你可能需要使用 createContext 创建大量 context； 直接使用的话，会有一定的性能问题：每一次对 state 的某个值变更，都会导致其他使用该 state 的组件 re-render，即使没有使用该值。 你可以通过 useMemo 来解决这个问题，但是就需要一定的成本来定制一个通用的解决方案； 无法处理异步请求。对于异步的逻辑，Context API 并没有提供任何 API，需要自己做封装； 无法处理数据间的联动。Context API 并没有提供 API 来生成派生状态，同样也需要自行去封装一些方法来实现。 React 外部状态管理库概览React 的外部状态管理库一直以来是 React 生态中非常内卷的一个领域。目前比较常见的状态管理库有 Redux（包括基于 Redux 的 Dva、Icestore）、Mobx、Zustand、Recoil、Jotai、Valtio、Hox 等。 从 npm trends 看各个状态管理库近一年的下载量趋势： 我们可以看到 Redux 作为 React 状态管理的老大哥，下载量上依然遥遥领先其他库。Mobx 作为往年热度仅次于 Redux 的状态管理库，位置正逐步有被 zustand 超越的趋势。recoil&#x2F;jotai&#x2F;valtio 作为这两年热门的新兴库热度也在逐步上升。hox 则处于不温不火的尴尬地位。 将以上状态管理库按心智模型、诞生时间、star 数，绘制气泡图。以 React v16.8 版本为分水岭，状态管理库可分为 Class 时代和 Hooks 时代。Class 时代中 Redux 和 Mobx 都是非常优秀的状态库。随着 Hooks 时代的到来，状态管理的心智模型也逐步发生着演变。整体呈现从中心化到去中心化，从单一状态到原子状态，从 Provider 到拥抱 Hooks 等演变趋势。 下面，我们对上述状态管理库进行逐一对比介绍。 Class 时代ReduxRedux 的灵感来源于 Flux 架构和函数式编程原理，状态更新可预测、可跟踪，提倡使用「单一存储」。这通常会「导致将所有的东西存储在一个大的单体存储中」。将 UI 和远程实体状态之间的所有东西都放在一个地方管理，这变得非常难以管理。对性能造成了不小的压力。 单向数据流他的工作流程大致如下： 用户在 view 层触发某个事件，通过 dispatch 发送了 action 和 payload action 和 payload 被传入 reducer 函数，返回一个新的 state store 拿到 reducer 返回的 state 并做更新，同时通知 view 层进行 re-render 由此可看出 Redux 遵循“单向数据流”和“不可变状态模型”的设计思想。这使得 Redux 的状态变化是可预测、可调式的。 三大原则此外，Redux 还遵循三大原则： 单一数据源 整个应用的 全局 state被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store中。 state 是只读的 唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。 纯函数修改 通过 reducer 修改状态，reducer 是纯函数，它接收之前的 state 和 action，并返回新的 state。记住，一定要返回一个新的对象，而不是修改之前的 state。 如何处理异步redux 没有规定如何处理异步数据流，最原始的方式就是使用 Action Creators，也就是在制造 action 之前进行各种的异步操作，你可以把要复用的操作抽离出来。 当然这样并不优雅，在实际项目中我们通常使用类似 redux-thunk、redux-saga 这些中间件来支持处理异步。 如何处理数据间联动react-redux 的 useSelector 获取状态后，你可以编写一些逻辑来处理派生状态。如果派生状态需要复用，记得给抽离出来。 优点 繁荣的社区，像不支持异步这种问题是由成熟的中间件可以解决的，你遇到的问题多多少少可以在社区找到答案; 可扩展性高，中间件模式让你可以随心所欲的武装你的 dispatch; 单一数据源且是树形结构，这让 redux 支持回溯，在调试上也更方便; 有成熟的开发调试工具 redux devtools。 缺点 陡峭的学习曲线。将副作用扔给中间件来处理，导致社区一堆中间件，学习成本陡然增加。比如处理异步请求的 Redux-saga、计算衍生状态的 reselect； 大量的模版代码。使用 redux，开发者要编写大量和业务逻辑无关的模板代码，这给开发和后期维护都带来了额外的成本； 大状态量情况下，性能较差。state 更新会影响所有组件。每个 action 都会调用所有 reducer； reducer 要返回新的对象，如果更新的值层级较深，更新成本也很高； 更多的内存占用，由于采用单一数据源，所有状态存储在一个 state 中，当某些状态不再需要使用时，也不会被垃圾回收释放内存； 当然，redux 也在致力于解决上述缺点。比如，redux toolkit就旨在让开发者使用标准方式编写 redux 逻辑。主要解决 redux 的 3 个问题： 配置 redux store 过于麻烦； 必须手动额外添加很多包才能正常使用 redux； redux 需要太多模板代码。 不过，即使有 redux toolkit 的加持，redux 的学习成本依旧不低。 Dvadva 首先是一个基于 redux和 redux-saga的数据流方案，然后为了简化开发体验，dva 还额外内置了 react-router和 fetch，所以也可以理解为一个轻量级的应用框架。 Dva 的特点： 易学易用，仅有 6 个 api，对 redux 用户尤其友好，配合 umi 使用后更是降低为 0 API elm 概念，通过 reducers, effects 和 subscriptions 组织 model 插件机制，比如 dva-loading可以自动处理 loading 状态，不用一遍遍地写 showLoading 和 hideLoading 支持 HMR，基于 babel-plugin-dva-hmr实现 components、routes 和 models 的 HMR Dva 大幅降低了 Redux 的上手成本，过去也在社区拥有了拥趸，github star 数 16.1k。不过，从 2019.11 开始就没有新的版本发布，看起来已经处于不维护状态。 icestoreicestore 是 IceJs内置状态管理库。icestore 是面向 React 应用的、简单友好的状态管理方案。 它包含以下核心特征： 简单、熟悉的 API：不需要额外的学习成本，只需要了解 React Hooks，对 Redux 用户友好。 集成异步处理：记录异步操作时的执行状态，简化视图中对于等待或错误的处理逻辑。 支持组件 Class 写法：友好的兼容策略可以让老项目享受轻量状态管理的乐趣。 良好的 TypeScript 支持：提供完整的 TypeScript 类型定义，在 VS Code 中能获得完整的类型检查和推断。 icestore 的灵感来自于 rematch和 constate。整体实现和 rematch 基本一致。rematch 是一个没有模板代码的 redux 最佳实践。icestore 整体配置简单，解决了 redux 学习成本高、大量模板代码等问题，同时又很好的支持了异步处理、TypeScript 和 SSR。 IceJS 自己给出的能力对照表： O: 支持 X: 不支持 +: 需要额外地进行能力扩展 功能&#x2F;库 redux constate zustand react-tracked icestore 框架 Any React React React React 简单性 ★★ ★★★★ ★★★ ★★★ ★★★★ 更少的模板代码 ★ ★★ ★★★ ★★★ ★★★★ 可配置性 ★★ ★★★ ★★★ ★★★ ★★★★★ 共享状态 O O O O O 复用状态 O O O O O 状态联动 + + + + O Class 组件支持 O + + + O Function 组件支持 O O O O O 异步更新的状态 + X X X O SSR O O X O O 持久化 + X X X + 懒加载模型 + + + + O 中心化 + X X X O 中间件或插件机制 O X O X O 开发者工具 O X O X O Mobx设计思想MobX 的主要思想是用「函数响应式编程」和「可变状态模型」使得状态管理变得简单和可扩展。 MobX 背后的哲学很简单: 任何源自应用状态的东西都应该自动地获得。其中包括 UI、数据序列化、服务器通讯，等等。 React 和 MobX 是一对强力组合。React 通过提供机制把应用状态转换为可渲染组件树并对其进行渲染。而 MobX 提供机制来存储和更新应用状态供 React 使用。 对于应用开发中的常见问题，React 和 MobX 都提供了最优和独特的解决方案。React 提供了优化 UI 渲染的机制， 这种机制就是通过使用虚拟 DOM 来减少昂贵的 DOM 变化的数量。MobX 提供了优化应用状态与 React 组件同步的机制，这种机制就是使用响应式虚拟依赖状态图表，它只有在真正需要的时候才更新并且永远保持是最新的。 心智模型Mobx 的心智模型和 react 很像，它区分了应用程序的三个概念： State(状态) Actions(动作) Derivations(派生) 首先创建可观察的状态（Observable State），通过 Action 更新 State，然后自动更新所有的派生（Derivations）。派生包括 Computed value（类似 useMemo 或 useSelector）、副作用函数(类似 useEffect)和 UI（render）。 Mobx 虽然心智模型像 react，但是实现却是完完全全的 vue：mutable + proxy（为了兼容性，proxy 实际上使用 Object.defineProperty 实现）。 使用反 react 的数据流模式，注定会有成本： Mobx 的响应式脱离了 react 自身的生命周期，就不得不显式声明其派生的作用时机和范围。比如副作用触发需要在 useEffect 里再跑一个 autorun&#x2F;reaction，要给 DOM render 包一层 useObserver&#x2F;Observer，都加大了开发成本。 Mobx 会在组件挂载时收集依赖，和 state 建立联系，这个方式在即将到来的 react 18 的并发模式（Concurrent Mode）中，可能无法平滑地迁移。为此，react 专门开发了create-subscription方法用于在组件中订阅外部源，但是实际的应用效果还未可知。 尤大本人也盖过章：React + MobX 本质上就是一个更繁琐的 Vue。 Mobx vs ReduxMobx 和 Redux 的对比，实际上可以归结为 面向对象 vs 函数式和 Mutable vs Immutable。 相比于 redux 的广播遍历 dispatch，然后遍历判断引用来决定组件是否更新，mobx 基于 proxy 可以精确收集依赖、局部更新组件（类似 vue），理论上会有更好的性能，但 redux 认为这可能不是一个问题（Won’t calling “all my reducers” for each action be slow?） Mobx 因为数据只有一份引用，没有回溯能力，不像 redux 每次更新都相当于打了一个快照，调试时搭配redux-logger这样的中间件，可以很直观地看到数据流变化历史。 Mobx 的学习成本更低，没有全家桶。 Mobx 在更新 state 中深层嵌套属性时更方便，直接赋值就好了，redux 则需要更新所有途经层级的引用（当然搭配immer也不麻烦）。 优点 简单易用，没有模板代码； 精准更新，性能更好； 缺点 难以调试。由于采用可变状态模型，状态不可预测和追溯，难以 debug； 太过灵活，更容易导致 bug； 响应式是基于 Proxy 实现的，希望传递的是一个数组，拿到的却是一个 Proxy。排查问题时有点痛苦。 Hooks 时代Hooks 是 React 16.8 新增的特性，使得我们可以在函数组件中使用 state 以及其他 React 特性。 Hooks 的引入主要是为了解决 React Class 组件的以下问题： 在组件之间复用状态逻辑很难 Class 组件会将视图和状态逻辑糅杂在一起，如果想复用组件中的状态逻辑，需要使用 render props 和高阶组件，但是这类方案需要重新组织组件结构，会形成组件的嵌套地狱，代码逻辑也会变得难以理解。 复杂组件的理解成本很高 Class 组件的状态逻辑会充斥在各个生命周期中，完全不相关的代码出现在同一个生命周期函数中，逻辑难以理解，容易引发 bug，且在多数情况下，很难将组件拆分成更小的粒度。 Hooks 是一种开发理念和组织理念的革新，有 3 个特性： primitive。元数据化，将混沌的 state 打散为一个个元数据； decentralization。去中心化，Class 时代的理念是“顶层下发”，Hooks 带来了强烈的“组件自治”理念； algebraic effects。代数效应，剥离组件中的副作用，让开发者更专注业务逻辑。 代数效应是函数式编程中的一个概念，用于将副作用从函数调用中分离。 自下而上模式的崛起我们可以看到以前的状态管理解决方案，如 Redux，设计理念是状态 「自上而下」流动。它「倾向于在组件树的顶端吸走所有的状态」。状态被维护在组件树的高处，下面的组件通过选择器拉取他们需要的状态。 在新的组件构建理念中，一种「自下而上」的观点对构建具有组合模式的应用具有很好的指导作用。 而 hook 就是这种理念的践行者，即把可组合的部件放在一起形成一个更大的整体。 通过 hook，我们可以从具有巨大全局存储的「单体状态管理」转变为向自下而上的 「微状态管理」，通过 hook 消费更小的状态片。 像接下来要介绍的 Recoil 和 Jotai 这样的流行库以其 「原子状态」的概念体现了这种自下而上的理念。「原子是一个最小但完整的状态单位」。它们是小块的状态，可以连接在一起形成新的衍生状态。最终形成了一个应用状态图。 这个模型允许你自下而上地建立起「状态图」。并通过仅使图中已更新的原子失效来优化渲染。 这与拥有一个大的单体状态球形成鲜明对比，你可以「订阅并试图避免不必要的渲染」。 接下来我们要介绍 5 个 Hooks 时代的状态库，分别是 recoil、zustand、jotai、valtio、hox。比较有趣的是其中 3 个都是 Daishi Kato开发的，采用了不同的设计思想，但是都在短期内取得不错的社区热度，这 3 个库分别是 zustand、jotai、valtio，这三个词其实是“状态”在 3 种语言中的不同发音。 zustand 🇩🇪 德语 “状态”，jotai 🇯🇵 日语 “状态”、valtio 🇫🇮 芬兰语 “状态”。 Recoil简介Recoil 是在 React Europe 2020 Conference 上 facebook 官方推出的专为 react 打造的状态管理库，动机是解决 react 状态共享模式的局限性： 以往只能将 state 提升到公共祖先来实现状态共享，并且一旦这么做了，基本就无法将组件树的顶层（state 必须存在的地方）与叶子组件 (使用 state 的地方) 进行代码分割 Context 只能存储单一值，无法存储多个各自拥有消费者的值的集合 设计思想Recoil 的状态集是一个有向图 (directed graph)，正交且天然连结于 React 组件树。状态的变化从该图的顶点（atom）开始，流经纯函数 (selector) 再传入组件。 Recoil 定义了一个有向图 (directed graph)，正交同时又天然连结于你的 React 树上。状态的变化从该图的顶点（我们称之为 atom）开始，流经纯函数 (我们称之为 selector) 再传入组件。基于这样的实现： 我们可以定义无需模板代码的 API，共享的状态拥有与 React 本地 state 一样简单的 get&#x2F;set 接口 (当然如果需要，也可以使用 reducer 等进行封装)； 我们有了与 Concurrent 模式及其他 React 新特性兼容的可能性； 状态的定义是渐进式和分布式的，这使代码分割成为可能； 无需修改对应的组件，就能将它们本地的 state 用派生数据替换； 无需修改对应的组件，就能将派生数据在同步与异步间切换； 我们能将导航视为头等概念，甚至可以将状态的转变编码进链接中； 可以很轻松地以可回溯的方式持久化整个应用的状态，持久化的状态不会因为应用的改变而丢失。 正交：相互独立，相互间不可替代，并且可以组合起来实现其它功能 Recoil 每一次状态变更都会生成一个不可变的快照，利用这个特性，可以快速实现应用导航相关的功能，例如状态回溯、跳转等。 核心方法Recoil 中定义状态的两个核心方法： atom: 定义原子状态，即组件的某个状态最小集， selector: 定义派生状态，其实就是 computed value 消费状态的方法有 useRecoilState、useRecoilValue、useSetRecoilState 等，用法和 react 的 useState 类似，几乎没有上手成本。另外值得注意的是，recoil 目前只支持 FC 的 hook 用法，Class 组件想用的话可以通过 HOC 的方式获取状态并注入组件。 优点 状态原子化（atom），自由组合和订阅；并且状态定义是渐进式和分布式的，使代码分割成为可能； 没有模板代码，天然是 hook 模式，让 react 尽量保持原来的样子； 兼容并发模式（Concurrent Mode）； 提供对状态流的快照（snapshot）支持，可以轻松回溯应用状态，甚至将 snopshot 编码放进 url，让任何人打开应用都能进入到同样的状态； 能力对照表 方案 学习成本 编码成本 TS 友好 SSR Code Split 并发模式兼容 可调试性 生态繁荣 Redux 高 高 一般 支持 不支持 支持 好 高 Mobx 中 中 好 支持 支持 未知 差 中 Recoil 低 低 好 实践较少 支持 支持 好 低 Zustand简介zustand 是一个轻量级状态管理库，和 redux 一样都是基于不可变状态模型和单向数据流的，状态对象 state 不可被修改，只能被替换。渲染优化要手动通过 selectors 进行。 Zustand vs Redux zustand 和 redux 是非常像的，都基于不可变状态模型，都基于单向数据流。 不过，redux 需要应用被 Context Provider 包裹，zustand 则不需要。 二者更新数据的方式不同，redux 基于 reducers，更新状态的 reducers 是严格的方法，这就使得状态更加可预测。zustand 不使用 reducers 而是通过更灵活的方法来更新状态。 特点zustand 的特点： 轻量级； 中心化，单一 store； 不可变状态模型； 不固执。很少限制，非常开放。 Jotai简介jotai 是一个小型全局状态管理库，它模仿了 useState、useReducer。jotai 有个叫做 atom 的概念，用于表示小的状态片段。和 zustand 不同的是，他是一个组件级别的状态管理库。和 zustand 相同的是同样都基于不可变状态模型。 jotai 是 Context 和订阅机制的结合，是面向 React 的一种全局状态管理库。如果你的需求是一个没有额外重复渲染的 Context，那 jotai 是个不错的选择。 特点jotai 有两个特点： 语法简单 jotai 的状态不是全局状态 atom 可以在 React 组件的生命周期里创建和销毁。这通过多个 Context 是无法实现的，因为使用 Context 增加一个新的 state 意味着增加一个新的 Provider 组件，如果新增一个组件，它所有的子组件都会被重新挂载，会失去所有状态。 衍生 atom atom 可以像积木一样被组合，生成新的 atom，从而实现复杂逻辑。 jotai 通过 atom 之间的依赖来实现自动渲染优化。 推荐场景：组件为中心的应用。 Recoil vs Jotaijotai 深受 recoil 启发，设计理念基本相同。但有以下不同： 最大的不同是是否需要键字符串，开发 jotai 的一大动力就是要省略键字符串。因为键属性必须是唯一的，键命名是一项艰巨的任务； 另一个不同是 jotai 不需要使用 Provider 包裹组件，这对开发者来说可以大幅降低开发成本和心理负担。 Zustand vs JotaiZustand 和 Jotai 之间有两个主要不同： Zustand 是单一 store，Jotai 由原子 atom 组合而成； Zustand 的 store 存储在 React 外部，Jotai 的 store 存储在 React 内部。 Valtio简介基于可变状态模型，利用 Proxy 获取一个和 React 集成在一起的不可变快照。 利用 Proxy 自动进行重新渲染优化，这个过程使用了状态使用跟踪技术。通过状态使用跟踪，可以检测到状态的哪部分被使用，让组件实现按使用重新渲染。同时，开发者也可以编写更少的代码。 Valtio vs Zustandzustand 基于不可变状态模型，valtio 基于可变状态模型。 valtio 通过属性访问自动进行渲染优化，zustand 推荐使用 selectors 手动进行渲染优化。 Valtio vs Mobx渲染优化上，valtio 使用 hook，mobx 使用高阶组件。 Hox从状态管理到状态共享redux、zustand、recoil 这些状态管理库，它们虽然在一定程度上也可以帮我们解决数据共享的问题，但它们最本质的能力还是对数据的操作。它们被称做也确实应该被称做”状态管理”工具。 而 Hox 想解决的问题，不是如何组织和操作数据，不是数据流的分层、异步、细粒度，我们希望 Hox 只聚焦于一个痛点：在多个组件间共享状态。 如果你也意识到了，层层传递的 value onChange 会对一个优质代码库带来的毁灭性影响，粗暴地把数据塞在 redux 中也并不能让一个应用得到很好的拓展性和可维护性，那么 Hox 或许会是一个适合你的”状态共享”方案，它简单、轻量、可靠，适合无论大小的几乎所有项目。 优势 直接复用已有的 React 知识，几乎没有学习成本，你怎么写 React 组件，就可以怎么写 Store 为灵活重构而设计，在 Store 和组件中使用同一套 DSL 可以让你几乎 0 成本的将组件的局部状态转化为一个组件间共享的状态 同时支持局部状态和全局状态，在灵活和简单之间做到了很好的平衡 优秀的性能和 TypeScript 支持 总结简单场景使用原生的 useState、useReducer、useContext 就能满足；还可以用 Hox这样小而美的库将 hook 的状态直接拓展成持久化状态，几乎没有额外的心智负担。 复杂场景的应用，redux、mobx 都是经受过千锤百炼的库，社区生态也很完备。 Redux 高度模板化、分层化，职责划分清晰，塑造了其状态在可回溯、可维护性方面的优势；搭配 thunk、saga 这些中间件几乎是无所不能。 Mobx 的优势是写法简单和高性能，但状态的可维护性不如 redux，在并发模式中的兼容性也有待观察。 随着 hook 和有官方背景的 recoil 的出现，状态管理似乎在朝原子化、组件化的方向发展，这也符合 react 的组件化哲学。Redux 的暴力遍历和分发或许已经是逆潮流的解法。 没有最好的状态管理库，只有最合适的状态管理库。 详细状态库能力对照表： Class 时代 Hooks 时代 传统流派 响应式流派 原子状态流派 传统流派 响应式流派 原子状态流派 redux dvajs icestore（ice 内置） mobx recoil zustand Valtio Jotai hox STAR 数 59k 16.1k 387 26k 18.1k 24.5k 5.9k 11.3k 1.3k 诞生时间 2011 2016.12 2019.3 2015.3 2019 2018 2020.11 2020.3 2019.1 特性 全局一棵状态树，利用 context，通过 action 触发变动，reducer 纯函数修改 store，最后导致 props 变动，进而组件重新渲染 深度整合 redux、redux-saga，便于 redux 用户快速切换 类 dvajs，创造 icestore 的灵感来自于 rematch 和 constate。 基于 ES6 proxy ，使用观察者&#x2F;可观察模式的，当你修改一个值时，任何使用该值的组件都会自动重新渲染。 原子化管理状态，进行精确渲染。使用 Recoil 会为你创建一个数据流向图，从 atom（共享状态）到 selector（纯函数），再流向 React 组件。Atom 是组件可以订阅的 state 单位。selector 可以同步或异步改变此 state。 基于观察者&#x2F;可观察模式，内部对通过 state 绑定的组件，添加到了订阅者队列，store 中的属性相当于一个被观察者，当属性状态变更后，通知所有订阅了该数属性的组件进行更新 利用 Proxy 自动进行重新渲染优化，这个过程使用了状态使用跟踪技术。通过状态使用跟踪，可以检测到状态的哪部分被使用，让组件实现按使用重新渲染。同时，开发者也可以编写更少的代码。 jotai 是一个小型全局状态管理库，它模仿了 useState、useReducer。jotai 有个叫做 atom 的概念，用于表示小的状态片段。和 zustand 不同的是，他是一个组件级别的状态管理库。和 zustand 相同的是同样都基于不可变状态模型。 类似于自定义 hook，利用 useState 能力，state 状态变化触发组件重新渲染 学习成本 很高 低 低 中 低 低 低 低 低 使用成本 很高，模板代码多 低，仅有 6 个 API 低 中 低 低 低 低 低 Typescript 友好 友好 不友好，没有清晰的依赖关系，类型支持很差 友好 友好 友好 友好 友好 友好 友好 状态拆分 react&#x2F;toolkit createSlice 支持 支持 支持 支持 支持 支持 支持 支持 性能 中等 中等 中等 好 好 中等 好 好 好 异步支持 不友好 友好 友好 友好 友好 友好 友好 友好 友好 React concurrent 模式支持 支持 支持 支持 支持 支持 支持 支持 易于调试 是 是 是 否 是 是 否 是 devtools 有 有 有 无 无 有 无 无 无 SSR 支持 支持 支持 支持，但可能不健全 支持，但可能不健全 支持，但可能不健全 支持，但可能不健全 不支持 参考资料 Do React Hooks Replace Redux? React 状态管理工具：我是这样选择的 You Might Not Need Redux 各流派 React 状态管理对比和原理实现 盘点 React 常见的状态管理方式 2022 年，我们再来谈谈 React 状态管理 DvaJS 支付宝前端应用架构的发展和选择 HoxJS Redux vs Zustand React 状态管理新浪潮 React-全局状态管理的群魔乱舞 各流派 React 状态管理对比和原理实现 - mdnice 墨滴 自述 · Redux Recoil - Facebook 官方 React 状态管理器 [译] React 状态管理的前世，今生和未来 - 开发者头条 2021 年的 React 状态管理 - 掘金 状态管理方案发展概览 State Management: Overview | React Common Tools and Practices Blogged Answers: Why React Context is Not a “State Management” Tool (and Why It Doesn’t Replace Redux) zustand vs redux hox - 下一代 React 状态管理器 MobX vs Redux: Evaluating Two Popular Libraries For State Management | SPEC INDIA React 状态管理的新浪潮 Redux 的性能问题 mobx vs redux zustand vs jotai vs valtio","tags":["React"],"categories":["React"]},{"title":"[React进阶]API全面解读与基础实践","path":"/2024/02/28/[React进阶]API全面解读与基础实践/","content":"原文地址「React 进阶」 React 全部 api 解读+基础实践大全(夯实基础 2 万字总结) - 掘金 很多同学用react开发的时候，真正用到的React的api少之又少，基本停留在Component,React.memo等层面,实际react源码中，暴露出来的方法并不少，只是我们平时很少用。但是React暴露出这么多api并非没有用，想要玩转react,就要明白这些API究竟是干什么的，应用场景是什么，今天就让我们从react 到 react-dom,一次性把react生产环境的暴露api复习个遍(涵盖 90%+)。 我们把react,API，分为组件类，工具类，**hooks**，再加上 react-dom ，一共四大方向，分别加以探讨。 为了能让屏幕前的你，更理解api,我是绞尽脑汁,本文的每一个api基本都会出一个demo演示效果,弥补一下天书般的react文档 😂😂😂，还有就是我对api基本概念的理解。创作不易，希望屏幕前的你能给笔者赏个赞，以此鼓励我继续创作前端硬文。 老规矩，我们带着疑问开始今天的阅读(自测掌握程度)？ 1 react暴露的api有哪些，该如何使用？ 2 react提供了哪些自测性能的手段？ 3 ref既然不能用在函数组件中，那么父组件如何控制函数子组件内的state和方法？ 4 createElement和cloneElement有什么区别，应用场景是什么？ 5 react内置的children遍历方法，和数组方法,有什么区别？ 6 react怎么将子元素渲染到父元素之外的指定容器中？ … 我相信读完这篇文章，这些问题全都会迎刃而解？ 组件类组件类，详细分的话有三种类，第一类说白了就是我平时用于继承的基类组件Component,PureComponent,还有就是react提供的内置的组件，比如Fragment,StrictMode,另一部分就是高阶组件forwardRef,memo等。 ComponentComponent是class组件的根基。\b 类组件一切始于Component。对于React.Component使用，我们没有什么好讲的。我们这里重点研究一下react对Component做了些什么。 react/src/ReactBaseClasses.js 123456function Component(props, context, updater) &#123; this.props = props; this.context = context; this.refs = emptyObject; this.updater = updater || ReactNoopUpdateQueue;&#125; 这就是Component函数，其中updater对象上保存着更新组件的方法。 我们声明的类组件是什么时候以何种形式被实例化的呢？ react-reconciler/src/ReactFiberClassComponent.js constructClassInstance 12345678910111213function constructClassInstance(workInProgress, ctor, props) &#123; const instance = new ctor(props, context); instance.updater = &#123; isMounted, enqueueSetState() &#123; /* setState 触发这里面的逻辑 */ &#125;, enqueueReplaceState() &#123;&#125;, enqueueForceUpdate() &#123; /* forceUpdate 触发这里的逻辑 */ &#125;, &#125;;&#125; 对于Component， react 处理逻辑还是很简单的，实例化我们类组件，然后赋值updater对象，负责组件的更新。然后在组件各个阶段，执行类组件的render函数，和对应的生命周期函数就可以了。 PureComponentPureComponent和 Component用法，差不多一样，唯一不同的是，纯组件PureComponent会浅比较，props和state是否相同，来决定是否重新渲染组件。所以一般用于性能调优，减少render次数。 什么叫做浅比较，我这里举个列子： 12345678910111213141516171819202122232425262728class Index extends React.PureComponent &#123; constructor(props) &#123; super(props); this.state = &#123; data: &#123; name: &quot;alien&quot;, age: 28, &#125;, &#125;; &#125; handerClick = () =&gt; &#123; const &#123; data &#125; = this.state; data.age++; this.setState(&#123; data &#125;); &#125;; render() &#123; const &#123; data &#125; = this.state; return ( &lt;div className=&quot;box&quot;&gt; &lt;div className=&quot;show&quot;&gt; &lt;div&gt; 你的姓名是: &#123;data.name&#125; &lt;/div&gt; &lt;div&gt; 年龄： &#123;data.age&#125;&lt;/div&gt; &lt;button onClick=&#123;this.handerClick&#125;&gt;age++&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125; 点击按钮，没有任何反应，因为PureComponent会比较两次data对象，都指向同一个data,没有发生改变，所以不更新视图。 解决这个问题很简单，只需要在handerClick事件中这么写： 1this.setState(&#123; data: &#123; ...data &#125; &#125;); 浅拷贝就能根本解决问题。 memoReact.memo和PureComponent作用类似，可以用作性能优化，React.memo 是高阶组件，函数组件和类组件都可以使用， 和区别PureComponent是 React.memo只能对props的情况确定是否渲染，而PureComponent是针对props和state。 React.memo 接受两个参数，第一个参数原始组件本身，第二个参数，可以根据一次更新中props是否相同决定原始组件是否重新渲染。是一个返回布尔值，true 证明组件无须重新渲染，false证明组件需要重新渲染，这个和类组件中的shouldComponentUpdate()正好相反 。 React.memo: 第二个参数 返回 true 组件不渲染 ， 返回 false 组件重新渲染。 shouldComponentUpdate: 返回 true 组件渲染 ， 返回 false 组件不渲染。 接下来我们做一个场景，控制组件在仅此一个props数字变量，一定范围渲染。 例子 🌰： 控制 props 中的 number ： 1 只有 number 更改，组件渲染。 2 只有 number 小于 5 ，组件渲染。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960function TextMemo(props) &#123; console.log(&quot;子组件渲染&quot;); if (props) return &lt;div&gt;hello,world&lt;/div&gt;;&#125;const controlIsRender = (pre, next) =&gt; &#123; if (pre.number === next.number) &#123; // number 不改变 ，不渲染组件 return true; &#125; else if (pre.number !== next.number &amp;&amp; next.number &gt; 5) &#123; // number 改变 ，但值大于5 ， 不渲染组件 return true; &#125; else &#123; // 否则渲染组件 return false; &#125;&#125;;const NewTexMemo = memo(TextMemo, controlIsRender);class Index extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; number: 1, num: 1, &#125;; &#125; render() &#123; const &#123; num, number &#125; = this.state; return ( &lt;div&gt; &lt;div&gt; 改变num：当前值 &#123;num&#125; &lt;button onClick=&#123;() =&gt; this.setState(&#123; num: num + 1 &#125;)&#125;&gt; num++ &lt;/button&gt; &lt;button onClick=&#123;() =&gt; this.setState(&#123; num: num - 1 &#125;)&#125;&gt; num-- &lt;/button&gt; &lt;/div&gt; &lt;div&gt; 改变number： 当前值 &#123;number&#125; &lt;button onClick=&#123;() =&gt; this.setState(&#123; number: number + 1 &#125;)&#125; &gt; &#123;&quot; &quot;&#125; number ++ &lt;/button&gt; &lt;button onClick=&#123;() =&gt; this.setState(&#123; number: number - 1 &#125;)&#125; &gt; &#123;&quot; &quot;&#125; number --&#123;&quot; &quot;&#125; &lt;/button&gt; &lt;/div&gt; &lt;NewTexMemo num=&#123;num&#125; number=&#123;number&#125; /&gt; &lt;/div&gt; ); &#125;&#125; 效果： 完美达到了效果，React.memo一定程度上，可以等价于组件外部使用shouldComponentUpdate ，用于拦截新老props，确定组件是否更新。 forwardRef官网对forwardRef的概念和用法很笼统，也没有给定一个具体的案例。很多同学不知道 forwardRef具体怎么用，下面我结合具体例子给大家讲解forwardRef应用场景。 1 转发引入 Ref 这个场景实际很简单，比如父组件想获取孙组件，某一个dom元素。这种隔代ref获取引用，就需要forwardRef来助力。 12345678910111213141516171819202122232425262728293031323334353637383940414243function Son(props) &#123; const &#123; grandRef &#125; = props; return ( &lt;div&gt; &lt;div&gt; i am alien &lt;/div&gt; &lt;span ref=&#123;grandRef&#125;&gt;这个是想要获取元素&lt;/span&gt; &lt;/div&gt; );&#125;class Father extends React.Component &#123; constructor(props) &#123; super(props); &#125; render() &#123; return ( &lt;div&gt; &lt;Son grandRef=&#123;this.props.grandRef&#125; /&gt; &lt;/div&gt; ); &#125;&#125;const NewFather = React.forwardRef((props, ref) =&gt; ( &lt;Father grandRef=&#123;ref&#125; &#123;...props&#125; /&gt;));class GrandFather extends React.Component &#123; constructor(props) &#123; super(props); &#125; node = null; componentDidMount() &#123; console.log(this.node); &#125; render() &#123; return ( &lt;div&gt; &lt;NewFather ref=&#123;(node) =&gt; (this.node = node)&#125; /&gt; &lt;/div&gt; ); &#125;&#125; 效果 react不允许ref通过props传递，因为组件上已经有 ref 这个属性,在组件调和过程中，已经被特殊处理，forwardRef出现就是解决这个问题，把ref转发到自定义的forwardRef定义的属性上，让ref，可以通过props传递。 2 高阶组件转发 Ref 一文吃透hoc文章中讲到，由于属性代理的hoc，被包裹一层，所以如果是类组件，是通过ref拿不到原始组件的实例的，不过我们可以通过forWardRef转发ref。 1234567891011121314151617181920212223242526272829303132function HOC(Component) &#123; class Wrap extends React.Component &#123; render() &#123; const &#123; forwardedRef, ...otherprops &#125; = this.props; return &lt;Component ref=&#123;forwardedRef&#125; &#123;...otherprops&#125; /&gt;; &#125; &#125; return React.forwardRef((props, ref) =&gt; ( &lt;Wrap forwardedRef=&#123;ref&#125; &#123;...props&#125; /&gt; ));&#125;class Index extends React.Component &#123; componentDidMount() &#123; console.log(666); &#125; render() &#123; return &lt;div&gt;hello,world&lt;/div&gt;; &#125;&#125;const HocIndex = HOC(Index, true);export default () =&gt; &#123; const node = useRef(null); useEffect(() =&gt; &#123; /* 就可以跨层级，捕获到 Index 组件的实例了 */ console.log(node.current.componentDidMount); &#125;, []); return ( &lt;div&gt; &lt;HocIndex ref=&#123;node&#125; /&gt; &lt;/div&gt; );&#125;; 如上，解决了高阶组件引入Ref的问题。 lazy React.lazy 和 Suspense 技术还不支持服务端渲染。如果你想要在使用服务端渲染的应用中使用，我们推荐 Loadable Components 这个库 React.lazy和Suspense配合一起用，能够有动态加载组件的效果。React.lazy 接受一个函数，这个函数需要动态调用 import()。它必须返回一个 Promise ，该 Promise 需要 resolve 一个 default export 的 React 组件。 我们模拟一个动态加载的场景。 父组件 12345678910111213141516171819202122232425262728import Test from &quot;./comTest&quot;;const LazyComponent = React.lazy( () =&gt; new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#123; default: () =&gt; &lt;Test /&gt;, &#125;); &#125;, 2000); &#125;));class index extends React.Component &#123; render() &#123; return ( &lt;div className=&quot;context_box&quot; style=&#123;&#123; marginTop: &quot;50px&quot; &#125;&#125;&gt; &lt;React.Suspense fallback=&#123; &lt;div className=&quot;icon&quot;&gt; &lt;SyncOutlined spin /&gt; &lt;/div&gt; &#125; &gt; &lt;LazyComponent /&gt; &lt;/React.Suspense&gt; &lt;/div&gt; ); &#125;&#125; 我们用setTimeout来模拟import异步引入效果。 Test 123456789101112131415class Test extends React.Component &#123; constructor(props) &#123; super(props); &#125; componentDidMount() &#123; console.log(&quot;--componentDidMount--&quot;); &#125; render() &#123; return ( &lt;div&gt; &lt;img src=&#123;alien&#125; className=&quot;alien&quot; /&gt; &lt;/div&gt; ); &#125;&#125; 效果 Suspense何为Suspense, Suspense 让组件“等待”某个异步操作，直到该异步操作结束即可渲染。 用于数据获取的 Suspense 是一个新特性，你可以使用 &lt;Suspense&gt; 以声明的方式来“等待”任何内容，包括数据。本文重点介绍它在数据获取的用例，它也可以用于等待图像、脚本或其他异步的操作。 上面讲到高阶组件lazy时候，已经用 lazy + Suspense模式，构建了异步渲染组件。我们看一下官网文档中的案例： 1234const ProfilePage = React.lazy(() =&gt; import(&quot;./ProfilePage&quot;)); // 懒加载&lt;Suspense fallback=&#123;&lt;Spinner /&gt;&#125;&gt; &lt;ProfilePage /&gt;&lt;/Suspense&gt;; Fragmentreact不允许一个组件返回多个节点元素，比如说如下情况 12345render()&#123; return &lt;li&gt; 🍎🍎🍎 &lt;/li&gt; &lt;li&gt; 🍌🍌🍌 &lt;/li&gt; &lt;li&gt; 🍇🍇🍇 &lt;/li&gt;&#125; 如果我们想解决这个情况，很简单，只需要在外层套一个容器元素。 1234567render()&#123; return &lt;div&gt; &lt;li&gt; 🍎🍎🍎 &lt;/li&gt; &lt;li&gt; 🍌🍌🍌 &lt;/li&gt; &lt;li&gt; 🍇🍇🍇 &lt;/li&gt; &lt;/div&gt;&#125; 但是我们不期望，增加额外的dom节点，所以react提供Fragment碎片概念，能够让一个组件返回多个元素。 所以我们可以这么写 12345&lt;React.Fragment&gt; &lt;li&gt; 🍎🍎🍎 &lt;/li&gt; &lt;li&gt; 🍌🍌🍌 &lt;/li&gt; &lt;li&gt; 🍇🍇🍇 &lt;/li&gt;&lt;/React.Fragment&gt; 还可以简写成： 12345&lt;&gt; &lt;li&gt; 🍎🍎🍎 &lt;/li&gt; &lt;li&gt; 🍌🍌🍌 &lt;/li&gt; &lt;li&gt; 🍇🍇🍇 &lt;/li&gt;&lt;/&gt; 和Fragment区别是，Fragment可以支持key属性。&lt;&gt;&lt;/&gt;不支持key属性。 温馨提示。我们通过map遍历后的元素，react底层会处理，默认在外部嵌套一个&lt;Fragment&gt;。 比如： 123&#123; [1, 2, 3].map((item) =&gt; &lt;span key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/span&gt;);&#125; react底层处理之后，等价于： 12345&lt;Fragment&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt;&lt;/Fragment&gt; ProfilerProfiler这个api一般用于开发阶段，性能检测，检测一次react组件渲染用时，性能开销。 Profiler 需要两个参数： 第一个参数：是 id，用于表识唯一性的Profiler。 第二个参数：onRender回调函数，用于渲染完成，接受渲染参数。 实践： 1234567891011121314151617const index = () =&gt; &#123; const callback = (...arg) =&gt; console.log(arg); return ( &lt;div&gt; &lt;div&gt; &lt;Profiler id=&quot;root&quot; onRender=&#123;callback&#125;&gt; &lt;Router&gt; &lt;Meuns /&gt; &lt;KeepaliveRouterSwitch withoutRoute&gt; &#123;renderRoutes(menusList)&#125; &lt;/KeepaliveRouterSwitch&gt; &lt;/Router&gt; &lt;/Profiler&gt; &lt;/div&gt; &lt;/div&gt; );&#125;; 结果 onRender 0 -id: root -&gt; Profiler 树的 id 。 1 -phase: mount -&gt; mount 挂载 ， update 渲染了。 2 -actualDuration: 6.685000262223184 -&gt; 更新 committed 花费的渲染时间。 3 -baseDuration: 4.430000321008265 -&gt; 渲染整颗子树需要的时间 4 -startTime : 689.7299999836832 -&gt; 本次更新开始渲染的时间 5 -commitTime : 698.5799999674782 -&gt; 本次更新 committed 的时间 6 -interactions: set&#123;&#125; -&gt; 本次更新的 interactions 的集合 尽管 Profiler 是一个轻量级组件，我们依然应该在需要时才去使用它。对一个应用来说，每添加一些都会给 CPU 和内存带来一些负担。 StrictModeStrictMode见名知意，严格模式，用于检测react项目中的潜在的问题，。与 Fragment 一样， StrictMode 不会渲染任何可见的 UI 。它为其后代元素触发额外的检查和警告。 严格模式检查仅在开发模式下运行；它们不会影响生产构建。 StrictMode目前有助于： ① 识别不安全的生命周期。 ② 关于使用过时字符串 ref API 的警告 ③ 关于使用废弃的 findDOMNode 方法的警告 ④ 检测意外的副作用 ⑤ 检测过时的 context API 实践:识别不安全的生命周期 对于不安全的生命周期，指的是UNSAFE_componentWillMount，UNSAFE_componentWillReceiveProps , UNSAFE_componentWillUpdate 外层开启严格模式： 12345678&lt;React.StrictMode&gt; &lt;Router&gt; &lt;Meuns /&gt; &lt;KeepaliveRouterSwitch withoutRoute&gt; &#123;renderRoutes(menusList)&#125; &lt;/KeepaliveRouterSwitch&gt; &lt;/Router&gt;&lt;/React.StrictMode&gt; 我们在内层组件中，使用不安全的生命周期: 123456class Index extends React.Component &#123; UNSAFE_componentWillReceiveProps() &#123;&#125; render() &#123; return &lt;div className=&quot;box&quot; /&gt;; &#125;&#125; 效果： 工具类接下来我们一起来探究一下react工具类函数的用法。 createElement一提到createElement，就不由得和JSX联系一起。我们写的jsx，最终会被 babel，用createElement编译成react元素形式。我写一个组件，我们看一下会被编译成什么样子， 如果我们在render里面这么写： 123456789render()&#123; return &lt;div className=&quot;box&quot; &gt; &lt;div className=&quot;item&quot; &gt;生命周期&lt;/div&gt; &lt;Text mes=&quot;hello,world&quot; /&gt; &lt;React.Fragment&gt; Flagment &lt;/React.Fragment&gt; &#123; /* */ &#125; text文本 &lt;/div&gt;&#125; 会被编译成这样： 1234567render() &#123; return React.createElement(&quot;div&quot;, &#123; className: &quot;box&quot; &#125;, React.createElement(&quot;div&quot;, &#123; className: &quot;item&quot; &#125;, &quot;\\u751F\\u547D\\u5468\\u671F&quot;), React.createElement(Text, &#123; mes: &quot;hello,world&quot; &#125;), React.createElement(React.Fragment, null, &quot; Flagment &quot;), &quot;text\\u6587\\u672C&quot;); &#125; 当然我们可以不用jsx模式，而是直接通过createElement进行开发。 createElement模型: 1React.createElement(type, [props], [...children]); createElement参数： **第一个参数:**如果是组件类型，会传入组件，如果是dom元素类型，传入div或者span之类的字符串。 第二个参数::第二个参数为一个对象，在dom类型中为属性，在组件类型中为props。 **其他参数:**，依次为children，根据顺序排列。 createElement 做了些什么？ 经过createElement处理，最终会形成 $$typeof = Symbol(react.element)对象。对象上保存了该react.element的信息。 cloneElement可能有的同学还傻傻的分不清楚cloneElement和createElement区别和作用。 createElement把我们写的jsx，变成element对象; 而cloneElement的作用是以 element 元素为样板克隆并返回新的 React 元素。返回元素的 props 是将新的 props 与原始元素的 props 浅层合并后的结果。 那么cloneElement感觉在我们实际业务组件中，可能没什么用，但是在一些开源项目，或者是公共插槽组件中用处还是蛮大的，比如说，我们可以在组件中，劫持children element，然后通过cloneElement克隆element，混入props。经典的案例就是 react-router中的Swtich组件，通过这种方式，来匹配唯一的 Route并加以渲染。 我们设置一个场景，在组件中，去劫持children，然后给children赋能一些额外的props: 123456789101112131415161718192021function FatherComponent(&#123; children &#125;) &#123; const newChildren = React.cloneElement(children, &#123; age: 18 &#125;); return &lt;div&gt; &#123;newChildren&#125; &lt;/div&gt;;&#125;function SonComponent(props) &#123; console.log(props); return &lt;div&gt;hello,world&lt;/div&gt;;&#125;class Index extends React.Component &#123; render() &#123; return ( &lt;div className=&quot;box&quot;&gt; &lt;FatherComponent&gt; &lt;SonComponent name=&quot;alien&quot; /&gt; &lt;/FatherComponent&gt; &lt;/div&gt; ); &#125;&#125; 打印： 完美达到了效果！ createContextcreateContext用于创建一个Context对象，createContext对象中，包括用于传递 Context 对象值 value的Provider，和接受value变化订阅的Consumer。 1const MyContext = React.createContext(defaultValue); createContext接受一个参数defaultValue，如果Consumer上一级一直没有Provider,则会应用defaultValue作为value。只有当组件所处的树中没有匹配到 Provider 时，其 defaultValue 参数才会生效。 我们来模拟一个 Context.Provider和Context.Consumer的例子： 1234567891011121314151617181920212223242526272829303132function ComponentB() &#123; /* 用 Consumer 订阅， 来自 Provider 中 value 的改变 */ return ( &lt;MyContext.Consumer&gt; &#123;(value) =&gt; &lt;ComponentA &#123;...value&#125; /&gt;&#125; &lt;/MyContext.Consumer&gt; );&#125;function ComponentA(props) &#123; const &#123; name, mes &#125; = props; return ( &lt;div&gt; &lt;div&gt; 姓名： &#123;name&#125; &lt;/div&gt; &lt;div&gt; 想对大家说： &#123;mes&#125; &lt;/div&gt; &lt;/div&gt; );&#125;function index() &#123; const [value] = React.useState(&#123; name: &quot;alien&quot;, mes: &quot;let us learn React &quot;, &#125;); return ( &lt;div style=&#123;&#123; marginTop: &quot;50px&quot; &#125;&#125;&gt; &lt;MyContext.Provider value=&#123;value&#125;&gt; &lt;ComponentB /&gt; &lt;/MyContext.Provider&gt; &lt;/div&gt; );&#125; 打印结果： Provider和Consumer的良好的特性，可以做数据的存和取，Consumer一方面传递value,另一方面可以订阅value的改变。 Provider还有一个特性可以层层传递value，这种特性在react-redux中表现的淋漓尽致。 createFactory1React.createFactory(type); 返回用于生成指定类型 React 元素的函数。类型参数既可以是标签名字符串（像是 ‘div‘ 或 ‘span‘），也可以是 React 组件 类型 （ class 组件或函数组件），或是 React fragment 类型。 使用： 12345678const Text = React.createFactory(() =&gt; &lt;div&gt;hello,world&lt;/div&gt;);function Index() &#123; return ( &lt;div style=&#123;&#123; marginTop: &quot;50px&quot; &#125;&#125;&gt; &lt;Text /&gt; &lt;/div&gt; );&#125; 效果 报出警告，这个api将要被废弃，我们这里就不多讲了，如果想要达到同样的效果，请用React.createElement createRefcreateRef可以创建一个 ref 元素，附加在react元素上。 用法： 123456789101112class Index extends React.Component &#123; constructor(props) &#123; super(props); this.node = React.createRef(); &#125; componentDidMount() &#123; console.log(this.node); &#125; render() &#123; return &lt;div ref=&#123;this.node&#125;&gt; my name is alien &lt;/div&gt;; &#125;&#125; 个人觉得createRef这个方法，很鸡肋，我们完全可以class类组件中这么写，来捕获ref。 123456789class Index extends React.Component &#123; node = null; componentDidMount() &#123; console.log(this.node); &#125; render() &#123; return &lt;div ref=&#123;(node) =&gt; this.node&#125;&gt; my name is alien &lt;/div&gt;; &#125;&#125; 或者在function组件中这么写： 1234567function Index() &#123; const node = React.useRef(null); useEffect(() =&gt; &#123; console.log(node.current); &#125;, []); return &lt;div ref=&#123;node&#125;&gt; my name is alien &lt;/div&gt;;&#125; isValidElement这个方法可以用来检测是否为react element元素,接受待验证对象，返回true或者false。这个 api 可能对于业务组件的开发，作用不大，因为对于组件内部状态，都是已知的，我们根本就不需要去验证，是否是react element 元素。 但是，对于一起公共组件或是开源库，isValidElement就很有作用了。 实践 我们做一个场景，验证容器组件的所有子组件，过滤到非react element类型。 没有用isValidElement验证之前： 1234567891011121314151617181920const Text = () =&gt; &lt;div&gt;hello,world&lt;/div&gt;;class WarpComponent extends React.Component &#123; constructor(props) &#123; super(props); &#125; render() &#123; return this.props.children; &#125;&#125;function Index() &#123; return ( &lt;div style=&#123;&#123; marginTop: &quot;50px&quot; &#125;&#125;&gt; &lt;WarpComponent&gt; &lt;Text /&gt; &lt;div&gt; my name is alien &lt;/div&gt; Let&#x27;s learn react together! &lt;/WarpComponent&gt; &lt;/div&gt; );&#125; 过滤之前的效果 我们用isValidElement进行react element验证: 1234567891011class WarpComponent extends React.Component &#123; constructor(props) &#123; super(props); this.newChidren = this.props.children.filter((item) =&gt; React.isValidElement(item) ); &#125; render() &#123; return this.newChidren; &#125;&#125; 过滤之后效果 过滤掉了非react element 的 Let&#39;s learn react together!。 Children.map接下来的五个api都是和react.Chidren相关的，我们来分别介绍一下，我们先来看看官网的描述，React.Children 提供了用于处理 this.props.children 不透明数据结构的实用方法。 有的同学会问遍历 children用数组方法,map ，forEach 不就可以了吗？ 请我们注意一下不透明数据结构,什么叫做不透明结构? 我们先看一下透明的结构： 123456789101112131415161718192021class Text extends React.Component &#123; render() &#123; return &lt;div&gt;hello,world&lt;/div&gt;; &#125;&#125;function WarpComponent(props) &#123; console.log(props.children); return props.children;&#125;function Index() &#123; return ( &lt;div style=&#123;&#123; marginTop: &quot;50px&quot; &#125;&#125;&gt; &lt;WarpComponent&gt; &lt;Text /&gt; &lt;Text /&gt; &lt;Text /&gt; &lt;span&gt;hello,world&lt;/span&gt; &lt;/WarpComponent&gt; &lt;/div&gt; );&#125; 打印 但是我们把Index结构改变一下： 123456789101112function Index() &#123; return ( &lt;div style=&#123;&#123; marginTop: &quot;50px&quot; &#125;&#125;&gt; &lt;WarpComponent&gt; &#123;new Array(3).fill(0).map(() =&gt; ( &lt;Text /&gt; ))&#125; &lt;span&gt;hello,world&lt;/span&gt; &lt;/WarpComponent&gt; &lt;/div&gt; );&#125; 打印 这个数据结构，我们不能正常的遍历了，即使遍历也不能遍历，每一个子元素。此时就需要 react.Chidren 来帮忙了。 但是我们把WarpComponent组件用react.Chidren处理children: 12345function WarpComponent(props) &#123; const newChildren = React.Children.map(props.children, (item) =&gt; item); console.log(newChildren); return newChildren;&#125; 此时就能正常遍历了，达到了预期效果。 注意 如果 children 是一个 Fragment 对象，它将被视为单一子节点的情况处理，而不会被遍历。 Children.forEachChildren.forEach和Children.map 用法类似，Children.map可以返回新的数组，Children.forEach仅停留在遍历阶段。 我们将上面的WarpComponent方法，用Children.forEach改一下。 1234function WarpComponent(props) &#123; React.Children.forEach(props.children, (item) =&gt; console.log(item)); return props.children;&#125; Children.countchildren 中的组件总数量，等同于通过 map 或 forEach 调用回调函数的次数。对于更复杂的结果，Children.count可以返回同一级别子组件的数量。 我们还是把上述例子进行改造： 1234567891011121314151617181920212223function WarpComponent(props) &#123; const childrenCount = React.Children.count(props.children); console.log(childrenCount, &quot;childrenCount&quot;); return props.children;&#125;function Index() &#123; return ( &lt;div style=&#123;&#123; marginTop: &quot;50px&quot; &#125;&#125;&gt; &lt;WarpComponent&gt; &#123;new Array(3) .fill(0) .map((item, index) =&gt; new Array(2) .fill(1) .map((item, index1) =&gt; ( &lt;Text key=&#123;index + index1&#125; /&gt; )) )&#125; &lt;span&gt;hello,world&lt;/span&gt; &lt;/WarpComponent&gt; &lt;/div&gt; );&#125; 效果: Children.toArrayChildren.toArray返回，props.children扁平化后结果。 1234567891011121314151617181920212223function WarpComponent(props) &#123; const newChidrenArray = React.Children.toArray(props.children); console.log(newChidrenArray, &quot;newChidrenArray&quot;); return newChidrenArray;&#125;function Index() &#123; return ( &lt;div style=&#123;&#123; marginTop: &quot;50px&quot; &#125;&#125;&gt; &lt;WarpComponent&gt; &#123;new Array(3) .fill(0) .map((item, index) =&gt; new Array(2) .fill(1) .map((item, index1) =&gt; ( &lt;Text key=&#123;index + index1&#125; /&gt; )) )&#125; &lt;span&gt;hello,world&lt;/span&gt; &lt;/WarpComponent&gt; &lt;/div&gt; );&#125; 效果： newChidrenArray ,就是扁平化的数组结构。React.Children.toArray() 在拉平展开子节点列表时，更改 key 值以保留嵌套数组的语义。也就是说， toArray 会为返回数组中的每个 key 添加前缀，以使得每个元素 key 的范围都限定在此函数入参数组的对象内。 Children.only验证 children 是否只有一个子节点（一个 React 元素），如果有则返回它，否则此方法会抛出错误。 不唯一 12345678910111213141516function WarpComponent(props) &#123; console.log(React.Children.only(props.children)); return props.children;&#125;function Index() &#123; return ( &lt;div style=&#123;&#123; marginTop: &quot;50px&quot; &#125;&#125;&gt; &lt;WarpComponent&gt; &#123;new Array(3).fill(0).map((item, index) =&gt; ( &lt;Text key=&#123;index&#125; /&gt; ))&#125; &lt;span&gt;hello,world&lt;/span&gt; &lt;/WarpComponent&gt; &lt;/div&gt; );&#125; 效果 唯一 12345678910111213function WarpComponent(props) &#123; console.log(React.Children.only(props.children)); return props.children;&#125;function Index() &#123; return ( &lt;div style=&#123;&#123; marginTop: &quot;50px&quot; &#125;&#125;&gt; &lt;WarpComponent&gt; &lt;Text /&gt; &lt;/WarpComponent&gt; &lt;/div&gt; );&#125; 效果 React.Children.only() 不接受 React.Children.map() 的返回值，因为它是一个数组而并不是 React 元素。 react-hooks对于react-hooks,我已经写了三部曲，介绍了react-hooks使用，自定义hooks，以及react-hooks原理，感兴趣的同学可以去看看，文章末尾有链接，对于常用的api，我这里参考了react-hooks如何使用那篇文章。并做了相应精简化和一些内容的补充。 useStateuseState可以弥补函数组件没有state的缺陷。useState可以接受一个初识值，也可以是一个函数action，action返回值作为新的state。返回一个数组，第一个值为state读取值，第二个值为改变state的dispatchAction函数。 我们看一个例子： 123456789101112131415161718const DemoState = (props) =&gt; &#123; /* number为此时state读取值 ，setNumber为派发更新的函数 */ let [number, setNumber] = useState(0); /* 0为初始值 */ return ( &lt;div&gt; &lt;span&gt;&#123;number&#125;&lt;/span&gt; &lt;button onClick=&#123;() =&gt; &#123; setNumber(number + 1); /* 写法一 */ setNumber((number) =&gt; number + 1); /* 写法二 */ console.log(number); /* 这里的number是不能够即时改变的 */ &#125;&#125; &gt; num++ &lt;/button&gt; &lt;/div&gt; );&#125;; useEffectuseEffect可以弥补函数组件没有生命周期的缺点。我们可以在useEffect第一个参数回调函数中，做一些请求数据，事件监听等操作，第二个参数作为dep依赖项，当依赖项发生变化，重新执行第一个函数。 useEffect 可以用作数据交互。 12345678910111213141516171819202122232425262728293031323334353637/* 模拟数据交互 */function getUserInfo(a) &#123; return new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#123; name: a, age: 16, &#125;); &#125;, 500); &#125;);&#125;const DemoEffect = (&#123; a &#125;) =&gt; &#123; const [userMessage, setUserMessage]: any = useState(&#123;&#125;); const div = useRef(); const [number, setNumber] = useState(0); /* 模拟事件监听处理函数 */ const handleResize = () =&gt; &#123;&#125;; /* useEffect使用 ，这里如果不加限制 ，会是函数重复执行，陷入死循环*/ useEffect(() =&gt; &#123; /* 请求数据 */ getUserInfo(a).then((res) =&gt; &#123; setUserMessage(res); &#125;); /* 操作dom */ console.log(div.current); /* div */ /* 事件监听等 */ window.addEventListener(&quot;resize&quot;, handleResize); /* 只有当props-&gt;a和state-&gt;number改变的时候 ,useEffect副作用函数重新执行 ，如果此时数组为空[]，证明函数只有在初始化的时候执行一次相当于componentDidMount */ &#125;, [a, number]); return ( &lt;div ref=&#123;div&#125;&gt; &lt;span&gt;&#123;userMessage.name&#125;&lt;/span&gt; &lt;span&gt;&#123;userMessage.age&#125;&lt;/span&gt; &lt;div onClick=&#123;() =&gt; setNumber(1)&#125;&gt;&#123;number&#125;&lt;/div&gt; &lt;/div&gt; );&#125;; useEffect 可以用作事件监听，还有一些基于dom的操作。,别忘了在useEffect第一个参数回调函数，返一个函数用于清除事件监听等操作。 12345678910111213141516const DemoEffect = (&#123; a &#125;) =&gt; &#123; /* 模拟事件监听处理函数 */ const handleResize = () =&gt; &#123;&#125;; useEffect(() =&gt; &#123; /* 定时器 延时器等 */ const timer = setInterval(() =&gt; console.log(666), 1000); /* 事件监听 */ window.addEventListener(&quot;resize&quot;, handleResize); /* 此函数用于清除副作用 */ return function () &#123; clearInterval(timer); window.removeEventListener(&quot;resize&quot;, handleResize); &#125;; &#125;, [a]); return &lt;div&gt;&lt;/div&gt;;&#125;; useMemouseMemo接受两个参数，第一个参数是一个函数，返回值用于产生保存值。 第二个参数是一个数组，作为dep依赖项，数组里面的依赖项发生变化，重新执行第一个函数，产生新的值。 应用场景： 1 缓存一些值，避免重新执行上下文 1234const number = useMemo(() =&gt; &#123; /** ....大量的逻辑运算 **/ return number;&#125;, [props.number]); // 只有 props.number 改变的时候，重新计算number的值。 2 减少不必要的dom循环 123456789101112131415/* 用 useMemo包裹的list可以限定当且仅当list改变的时候才更新此list，这样就可以避免selectList重新循环 */&#123; useMemo( () =&gt; ( &lt;div&gt; &#123;selectList.map((i, v) =&gt; ( &lt;span className=&#123;style.listSpan&#125; key=&#123;v&#125;&gt; &#123;i.patentName&#125; &lt;/span&gt; ))&#125; &lt;/div&gt; ), [selectList] );&#125; 3 减少子组件渲染 12345/* 只有当props中，list列表改变的时候，子组件才渲染 */const goodListChild = useMemo( () =&gt; &lt;GoodList list=&#123;props.list&#125; /&gt;, [props.list]); useCallbackuseMemo 和 useCallback 接收的参数都是一样，都是在其依赖项发生变化后才执行，都是返回缓存的值，区别在于 useMemo 返回的是函数运行的结果， useCallback 返回的是函数。 返回的callback可以作为props回调函数传递给子组件。 123456789101112131415161718192021222324252627/* 用react.memo */const DemoChildren = React.memo((props) =&gt; &#123; /* 只有初始化的时候打印了 子组件更新 */ console.log(&quot;子组件更新&quot;); useEffect(() =&gt; &#123; props.getInfo(&quot;子组件&quot;); &#125;, []); return &lt;div&gt;子组件&lt;/div&gt;;&#125;);const DemoUseCallback = (&#123; id &#125;) =&gt; &#123; const [number, setNumber] = useState(1); /* 此时usecallback的第一参数 (sonName)=&gt;&#123; console.log(sonName) &#125; 经过处理赋值给 getInfo */ const getInfo = useCallback( (sonName) =&gt; &#123; console.log(sonName); &#125;, [id] ); return ( &lt;div&gt; &#123;/* 点击按钮触发父组件更新 ，但是子组件没有更新 */&#125; &lt;button onClick=&#123;() =&gt; setNumber(number + 1)&#125;&gt;增加&lt;/button&gt; &lt;DemoChildren getInfo=&#123;getInfo&#125; /&gt; &lt;/div&gt; );&#125;; useRefuseRef的作用： 一 是可以用来获取dom元素，或者class组件实例 。 二 react-hooks原理文章中讲过，创建useRef时候，会创建一个原始对象，只要函数组件不被销毁，原始对象就会一直存在，那么我们可以利用这个特性，来通过useRef保存一些数据。 1234567891011121314const DemoUseRef = () =&gt; &#123; const dom = useRef(null); const handerSubmit = () =&gt; &#123; /* &lt;div &gt;表单组件&lt;/div&gt; dom 节点 */ console.log(dom.current); &#125;; return ( &lt;div&gt; &#123;/* ref 标记当前dom节点 */&#125; &lt;div ref=&#123;dom&#125;&gt;表单组件&lt;/div&gt; &lt;button onClick=&#123;() =&gt; handerSubmit()&#125;&gt;提交&lt;/button&gt; &lt;/div&gt; );&#125;; useLayoutEffectuseEffect执行顺序: 组件更新挂载完成 -&gt; 浏览器 dom 绘制完成 -&gt; 执行 useEffect 回调。 useLayoutEffect 执行顺序: 组件更新挂载完成 -&gt; 执行 useLayoutEffect 回调-&gt; 浏览器dom绘制完成。 所以说 useLayoutEffect 代码可能会阻塞浏览器的绘制 。我们写的 effect和 useLayoutEffect，react在底层会被分别打上PassiveEffect，HookLayout，在commit阶段区分出，在什么时机执行。 12345678910111213const DemoUseLayoutEffect = () =&gt; &#123; const target = useRef(); useLayoutEffect(() =&gt; &#123; /*我们需要在dom绘制之前，移动dom到制定位置*/ const &#123; x, y &#125; = getPositon(); /* 获取要移动的 x,y坐标 */ animate(target.current, &#123; x, y &#125;); &#125;, []); return ( &lt;div&gt; &lt;span ref=&#123;target&#125; className=&quot;animate&quot;&gt;&lt;/span&gt; &lt;/div&gt; );&#125;; useReducer在react-hooks原理那篇文章中讲解到，useState底层就是一个简单版的useReducer useReducer 接受的第一个参数是一个函数，我们可以认为它就是一个 reducer , reducer 的参数就是常规 reducer 里面的 state 和 action ,返回改变后的 state , useReducer 第二个参数为 state 的初始值 返回一个数组，数组的第一项就是更新之后 state 的值 ，第二个参数是派发更新的 dispatch 函数。 我们来看一下useReducer如何使用： 1234567891011121314151617181920212223242526272829303132333435const DemoUseReducer = () =&gt; &#123; /* number为更新后的state值, dispatchNumbner 为当前的派发函数 */ const [number, dispatchNumbner] = useReducer((state, action) =&gt; &#123; const &#123; payload, name &#125; = action; /* return的值为新的state */ switch (name) &#123; case &quot;add&quot;: return state + 1; case &quot;sub&quot;: return state - 1; case &quot;reset&quot;: return payload; &#125; return state; &#125;, 0); return ( &lt;div&gt; 当前值：&#123;number&#125; &#123;/* 派发更新 */&#125; &lt;button onClick=&#123;() =&gt; dispatchNumbner(&#123; name: &quot;add&quot; &#125;)&#125;&gt; 增加 &lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatchNumbner(&#123; name: &quot;sub&quot; &#125;)&#125;&gt; 减少 &lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatchNumbner(&#123; name: &quot;reset&quot;, payload: 666 &#125;)&#125; &gt; 赋值 &lt;/button&gt; &#123;/* 把dispatch 和 state 传递给子组件 */&#125; &lt;MyChildren dispatch=&#123;dispatchNumbner&#125; State=&#123;&#123; number &#125;&#125; /&gt; &lt;/div&gt; );&#125;; useContext我们可以使用 useContext ，来获取父级组件传递过来的 context 值，这个当前值就是最近的父级组件 Provider 设置的 value 值，useContext 参数一般是由 createContext 方式引入 ,也可以父级上下文 context 传递 ( 参数为 context )。useContext 可以代替 context.Consumer 来获取 Provider 中保存的 value 值 1234567891011121314151617181920212223242526/* 用useContext方式 */const DemoContext = () =&gt; &#123; const value: any = useContext(Context); /* my name is alien */ return &lt;div&gt; my name is &#123;value.name&#125;&lt;/div&gt;;&#125;;/* 用Context.Consumer 方式 */const DemoContext1 = () =&gt; &#123; return ( &lt;Context.Consumer&gt; &#123;/* my name is alien */&#125; &#123;(value) =&gt; &lt;div&gt; my name is &#123;value.name&#125;&lt;/div&gt;&#125; &lt;/Context.Consumer&gt; );&#125;;export default () =&gt; &#123; return ( &lt;div&gt; &lt;Context.Provider value=&#123;&#123; name: &quot;alien&quot;, age: 18 &#125;&#125;&gt; &lt;DemoContext /&gt; &lt;DemoContext1 /&gt; &lt;/Context.Provider&gt; &lt;/div&gt; );&#125;; useImperativeHandleuseImperativeHandle 可以配合 forwardRef 自定义暴露给父组件的实例值。这个很有用，我们知道，对于子组件，如果是class类组件，我们可以通过ref获取类组件的实例，但是在子组件是函数组件的情况，如果我们不能直接通过ref的，那么此时useImperativeHandle和 forwardRef配合就能达到效果。 useImperativeHandle接受三个参数： 第一个参数 ref: 接受 forWardRef 传递过来的 ref。 第二个参数 createHandle ：处理函数，返回值作为暴露给父组件的ref对象。 第三个参数 deps:依赖项 deps，依赖项更改形成新的ref对象。 我们来模拟给场景，用useImperativeHandle，使得父组件能让子组件中的input自动赋值并聚焦。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function Son(props, ref) &#123; console.log(props); const inputRef = useRef(null); const [inputValue, setInputValue] = useState(&quot;&quot;); useImperativeHandle( ref, () =&gt; &#123; const handleRefs = &#123; /* 声明方法用于聚焦input框 */ onFocus() &#123; inputRef.current.focus(); &#125;, /* 声明方法用于改变input的值 */ onChangeValue(value) &#123; setInputValue(value); &#125;, &#125;; return handleRefs; &#125;, [] ); return ( &lt;div&gt; &lt;input placeholder=&quot;请输入内容&quot; ref=&#123;inputRef&#125; value=&#123;inputValue&#125; /&gt; &lt;/div&gt; );&#125;const ForwarSon = forwardRef(Son);class Index extends React.Component &#123; inputRef = null; handerClick() &#123; const &#123; onFocus, onChangeValue &#125; = this.cur; onFocus(); onChangeValue(&quot;let us learn React!&quot;); &#125; render() &#123; return ( &lt;div style=&#123;&#123; marginTop: &quot;50px&quot; &#125;&#125;&gt; &lt;ForwarSon ref=&#123;(node) =&gt; (this.inputRef = node)&#125; /&gt; &lt;button onClick=&#123;this.handerClick.bind(this)&#125;&gt; 操控子组件 &lt;/button&gt; &lt;/div&gt; ); &#125;&#125; 效果: useDebugValueuseDebugValue 可用于在 React 开发者工具中显示自定义 hook 的标签。这个hooks目的就是检查自定义hooks 123456789function useFriendStatus(friendID) &#123; const [isOnline, setIsOnline] = useState(null); // ... // 在开发者工具中的这个 Hook 旁边显示标签 // e.g. &quot;FriendStatus: Online&quot; useDebugValue(isOnline ? &quot;Online&quot; : &quot;Offline&quot;); return isOnline;&#125; 我们不推荐你向每个自定义 Hook 添加 debug 值。当它作为共享库的一部分时才最有价值。在某些情况下，格式化值的显示可能是一项开销很大的操作。除非需要检查 Hook，否则没有必要这么做。因此，useDebugValue 接受一个格式化函数作为可选的第二个参数。该函数只有在 Hook 被检查时才会被调用。它接受 debug 值作为参数，并且会返回一个格式化的显示值。 useTransitionuseTransition允许延时由state改变而带来的视图渲染。避免不必要的渲染。它还允许组件将速度较慢的数据获取更新推迟到随后渲染，以便能够立即渲染更重要的更新。 12const TIMEOUT_MS = &#123; timeoutMs: 2000 &#125;;const [startTransition, isPending] = useTransition(TIMEOUT_MS); useTransition 接受一个对象， timeoutMs代码需要延时的时间。 返回一个数组。第一个参数： 是一个接受回调的函数。我们用它来告诉 React 需要推迟的 state 。 第二个参数： 一个布尔值。表示是否正在等待，过度状态的完成(延时state的更新)。 下面我们引入官网的列子，来了解useTransition的使用。 12345678910111213141516171819202122232425const SUSPENSE_CONFIG = &#123; timeoutMs: 2000 &#125;;function App() &#123; const [resource, setResource] = useState(initialResource); const [startTransition, isPending] = useTransition(SUSPENSE_CONFIG); return ( &lt;&gt; &lt;button disabled=&#123;isPending&#125; onClick=&#123;() =&gt; &#123; startTransition(() =&gt; &#123; const nextUserId = getNextId(resource.userId); setResource(fetchProfileData(nextUserId)); &#125;); &#125;&#125; &gt; Next &lt;/button&gt; &#123;isPending ? &quot; 加载中...&quot; : null&#125; &lt;Suspense fallback=&#123;&lt;Spinner /&gt;&#125;&gt; &lt;ProfilePage resource=&#123;resource&#125; /&gt; &lt;/Suspense&gt; &lt;/&gt; );&#125; 在这段代码中，我们使用 startTransition 包装了我们的数据获取。这使我们可以立即开始获取用户资料的数据，同时推迟下一个用户资料页面以及其关联的 Spinner 的渲染 2 秒钟（ timeoutMs 中显示的时间）。 这个api目前处于实验阶段，没有被完全开放出来。 react-dom接下来，我们来一起研究react-dom中比较重要的api。 renderrender 是我们最常用的react-dom的 api，用于渲染一个react元素，一般react项目我们都用它，渲染根部容器app。 1ReactDOM.render(element, container[, callback]) 使用 1ReactDOM.render(&lt;App /&gt;, document.getElementById(&quot;app&quot;)); ReactDOM.render会控制container容器节点里的内容，但是不会修改容器节点本身。 hydrate服务端渲染用hydrate。用法与 render() 相同，但它用于在 ReactDOMServer 渲染的容器中对 HTML 的内容进行 hydrate 操作。 1ReactDOM.hydrate(element, container[, callback]) createPortalPortal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。createPortal 可以把当前组件或 element 元素的子节点，渲染到组件之外的其他地方。 那么具体应用到什么场景呢？ 比如一些全局的弹窗组件model,&lt;Model/&gt;组件一般都写在我们的组件内部，倒是真正挂载的dom，都是在外层容器，比如body上。此时就很适合createPortalAPI。 createPortal接受两个参数： 1ReactDOM.createPortal(child, container); 第一个： child 是任何可渲染的 React 子元素 第二个： container是一个 DOM 元素。 接下来我们实践一下： 12345678910111213141516171819202122232425function WrapComponent(&#123; children &#125;) &#123; const domRef = useRef(null); const [PortalComponent, setPortalComponent] = useState(null); React.useEffect(() =&gt; &#123; setPortalComponent(ReactDOM.createPortal(children, domRef.current)); &#125;, []); return ( &lt;div&gt; &lt;div className=&quot;container&quot; ref=&#123;domRef&#125;&gt;&lt;/div&gt; &#123;PortalComponent&#125; &lt;/div&gt; );&#125;class Index extends React.Component &#123; render() &#123; return ( &lt;div style=&#123;&#123; marginTop: &quot;50px&quot; &#125;&#125;&gt; &lt;WrapComponent&gt; &lt;div&gt;hello,world&lt;/div&gt; &lt;/WrapComponent&gt; &lt;/div&gt; ); &#125;&#125; 效果 我们可以看到，我们children实际在container 之外挂载的，但是已经被createPortal渲染到container中。 unstable_batchedUpdates在react-legacy模式下，对于事件，react事件有批量更新来处理功能,但是这一些非常规的事件中，批量更新功能会被打破。所以我们可以用react-dom中提供的unstable_batchedUpdates 来进行批量更新。 一次点击实现的批量更新 1234567891011121314151617181920212223class Index extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; numer: 1, &#125;; &#125; handerClick = () =&gt; &#123; this.setState(&#123; numer: this.state.numer + 1 &#125;); console.log(this.state.numer); this.setState(&#123; numer: this.state.numer + 1 &#125;); console.log(this.state.numer); this.setState(&#123; numer: this.state.numer + 1 &#125;); console.log(this.state.numer); &#125;; render() &#123; return ( &lt;div style=&#123;&#123; marginTop: &quot;50px&quot; &#125;&#125;&gt; &lt;button onClick=&#123;this.handerClick&#125;&gt;click me&lt;/button&gt; &lt;/div&gt; ); &#125;&#125; 效果 渲染次数一次。 批量更新条件被打破 12345678910handerClick = () =&gt; &#123; Promise.resolve().then(() =&gt; &#123; this.setState(&#123; numer: this.state.numer + 1 &#125;); console.log(this.state.numer); this.setState(&#123; numer: this.state.numer + 1 &#125;); console.log(this.state.numer); this.setState(&#123; numer: this.state.numer + 1 &#125;); console.log(this.state.numer); &#125;);&#125;; 效果 渲染次数三次。 unstable_batchedUpdate 助力 123456789101112handerClick = () =&gt; &#123; Promise.resolve().then(() =&gt; &#123; ReactDOM.unstable_batchedUpdates(() =&gt; &#123; this.setState(&#123; numer: this.state.numer + 1 &#125;); console.log(this.state.numer); this.setState(&#123; numer: this.state.numer + 1 &#125;); console.log(this.state.numer); this.setState(&#123; numer: this.state.numer + 1 &#125;); console.log(this.state.numer); &#125;); &#125;);&#125;; 渲染次数一次,完美解决批量更新问题。 flushSyncflushSync 可以将回调函数中的更新任务，放在一个较高的优先级中。我们知道react设定了很多不同优先级的更新任务。如果一次更新任务在flushSync回调函数内部，那么将获得一个较高优先级的更新。比如 1234ReactDOM.flushSync(() =&gt; &#123; /* 此次更新将设置一个较高优先级的更新 */ this.setState(&#123; name: &quot;alien&quot; &#125;);&#125;); 为了让大家理解flushSync，我这里做一个demo奉上， 12345678910111213141516171819202122232425/* flushSync */import ReactDOM from &quot;react-dom&quot;;class Index extends React.Component &#123; state = &#123; number: 0 &#125;; handerClick = () =&gt; &#123; setTimeout(() =&gt; &#123; this.setState(&#123; number: 1 &#125;); &#125;); this.setState(&#123; number: 2 &#125;); ReactDOM.flushSync(() =&gt; &#123; this.setState(&#123; number: 3 &#125;); &#125;); this.setState(&#123; number: 4 &#125;); &#125;; render() &#123; const &#123; number &#125; = this.state; console.log(number); // 打印什么？？ return ( &lt;div&gt; &lt;div&gt;&#123;number&#125;&lt;/div&gt; &lt;button onClick=&#123;this.handerClick&#125;&gt;测试flushSync&lt;/button&gt; &lt;/div&gt; ); &#125;&#125; 先不看答案，点击一下按钮，打印什么呢？ 我们来点击一下看看 打印 0 3 4 1 ，相信不难理解为什么这么打印了。 首先 flushSync this.setState(&#123; number: 3 &#125;)设定了一个高优先级的更新，所以 3 先被打印 2 4 被批量更新为 4 相信这个demo让我们更深入了解了flushSync。 findDOMNodefindDOMNode用于访问组件DOM元素节点，react推荐使用ref模式，不期望使用findDOMNode。 1ReactDOM.findDOMNode(component); 注意的是： 1 findDOMNode只能用在已经挂载的组件上。 2 如果组件渲染内容为 null 或者是 false，那么 findDOMNode返回值也是 null。 3 findDOMNode 不能用于函数组件。 接下来让我们看一下，findDOMNode具体怎么使用的： 12345678910111213class Index extends React.Component &#123; handerFindDom = () =&gt; &#123; console.log(ReactDOM.findDOMNode(this)); &#125;; render() &#123; return ( &lt;div style=&#123;&#123; marginTop: &quot;100px&quot; &#125;&#125;&gt; &lt;div&gt;hello,world&lt;/div&gt; &lt;button onClick=&#123;this.handerFindDom&#125;&gt;获取容器dom&lt;/button&gt; &lt;/div&gt; ); &#125;&#125; 效果： 我们完全可以将外层容器用ref来标记，获取捕获原生的dom节点。 unmountComponentAtNode从 DOM 中卸载组件，会将其事件处理器和 state 一并清除。 如果指定容器上没有对应已挂载的组件，这个函数什么也不会做。如果组件被移除将会返回 true ，如果没有组件可被移除将会返回 false 。 我们来简单举例看看unmountComponentAtNode如何使用？ 123456789101112131415161718192021222324252627282930function Text() &#123; return &lt;div&gt;hello,world&lt;/div&gt;;&#125;class Index extends React.Component &#123; node = null; constructor(props) &#123; super(props); this.state = &#123; numer: 1, &#125;; &#125; componentDidMount() &#123; /* 组件初始化的时候，创建一个 container 容器 */ ReactDOM.render(&lt;Text /&gt;, this.node); &#125; handerClick = () =&gt; &#123; /* 点击卸载容器 */ const state = ReactDOM.unmountComponentAtNode(this.node); console.log(state); &#125;; render() &#123; return ( &lt;div style=&#123;&#123; marginTop: &quot;50px&quot; &#125;&#125;&gt; &lt;div ref=&#123;(node) =&gt; (this.node = node)&#125;&gt;&lt;/div&gt; &lt;button onClick=&#123;this.handerClick&#125;&gt;click me&lt;/button&gt; &lt;/div&gt; ); &#125;&#125; 效果 总结本文通过react组件层面，工具层面，hooks层面，react-dom了解了api的用法，希望看完的同学，能够对着文章中的demo自己敲一遍，到头来会发现自己成长不少。 最后, 送人玫瑰，手留余香，觉得有收获的朋友可以给笔者点赞，关注一波 ，陆续更新前端超硬核文章。 提前透漏：接下来会出一部揭秘react事件系统的文章。 感兴趣的同学请关注公众号 前端Sharing 持续推送优质好文 往期 react 文章文章中，对于其他没有讲到的react-hooks，建议大家看react-hooks三部曲。 react-hooks 三部曲 第一部： react-hooks 如何使用 150+ 赞 👍 第二部：玩转 react-hooks,自定义 hooks 设计模式及其实战 240+ 👍 赞 第三部：「react 进阶」一文吃透 react-hooks 原理 820 react 进阶系列 「react 进阶」年终送给 react 开发者的八条优化建议 918+ 赞 👍 「react 进阶」一文吃透 React 高阶组件(HOC) 330+ 赞 👍 react 源码系列 「源码解析 」这一次彻底弄懂 react-router 路由原理 132+ 赞 👍 「源码解析」一文吃透 react-redux 源码（useMemo 经典源码级案例） 143+ 赞 👍 开源项目系列 「react 缓存页面」从需求到开源（我是怎么样让产品小姐姐刮目相看的） 300+ 赞 👍 「前端工程化」从 0-1 搭建 react，ts 脚手架（1.2w 字超详细教程） 330+ 赞 👍 参考文档react 中文文档","tags":["React"],"categories":["React"]},{"title":"Linux基础教程","path":"/2024/02/26/Linux基础教程/","content":"简介Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。 Linux 的发行版Linux 的发行版简单说就是 linux 内核和应用软件的打包 目前市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、TurboLinux、BluePoint、RedFlag、Xterm、SlackWare 等。 系统启动过程 内核引导BIOS 自检，由设置的启动设备启动，操作系统接管硬件，读 /boot 目录的内核文件 运行 init 进程读取配置 /etc/inittab 运行级别许多程序需要开机启动。它们在 Windows 叫做”服务”（service），在 Linux 就叫做”守护进程”（daemon）。不同的场合需要启动不同的程序，所以就有了运行级别 init进程的一大任务，就是根据运行级别去执行对应的开机启动的程序 Linux 系统有 7 个运行级别(runlevel)： 运行级别0： 系统停机状态，系统默认运行级别不能设为0，否则不能正常启动 运行级别1： 单用户工作状态，root权限，用于系统维护，禁止远程登陆 运行级别2： 多用户状态(没有NFS) 运行级别3： 完全的多用户状态(有NFS)，登陆后进入控制台命令行模式 运行级别4： 系统未使用，保留 运行级别5： X11控制台，登陆后进入图形GUI模式 运行级别6： 系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动 使用运行级别关机和重启12sudo init 0 # 关机sudo init 6 # 重启 系统初始化真正的 rc 启动脚本，放在 init.d 目录，它们有类似的用法，一般都能接受 start, stop, restart, status等参数&#x2F;etc&#x2F;rc5.d 中的 rc 脚本，通常都是 K 或 S 开头的链接文件，S 开头则用start参数运行, K 开头的则用stop参数运行 建立终端rc 脚本执行完后，init 会接着打开 6 个终端, 以便用户登录 用户登录用户有三种登录方式: 命令行登录 ssh 登录 图形界面登录 运行级别为 5，登录后进入 KDE Gnome 等窗口管理器 终端切换ctrl+alt+F1-F6 切换终端 1-6, ctrl+alt+F7返回图形界面 linux 关机正确的关机流程: sync &gt; shutdown &gt; reboot &gt; halt关机指令 shutdown, man shutdown 查看帮助 12345678910shutdown -h 1 &#x27;machine will shutdown in 1 minute&#x27; # -h haltshutdown now # 马上关机shutdown -r now # 马上重启 同 rebootshutdown -r +5 # 5分钟后重启shutdown -h 20:24 # 某时间点关机shutdown -h now # 马上关机 同 haltshutdown -c # 取消定时关机poweroff # 关机init 0 # 关机init 6 # 重启 shutdown和halt的区别halt 执行时,杀死应用进程, 执行 sync 系统调用,文件系统写操作完成后就会停止内核，要手动关闭电源; shutdown 会停止应用进程 卸载文件系统 然后关闭电源 linux 系统目录结构 /binbin 是 binary 的缩写，该目录存放最常用的命令 /boot存放启动 linux 时用到的核心文件 /devdev 是 device 的缩写, 存放外部设备 linux 中访问设备的方式和访问文件相同 /etc存放系统的配置文件 /home用户的主目录，每个用户都有自己的主目录 通常和用户名同名 /lib存放系统的动态链接共享库, 类似于 windows 中的 dll 文件,几乎所有应用程序都需要这些共享库 /lost+found一般为空，非法关机后，会存放一些文件 /media把识别的媒体设备挂载到该目录 /mnt用户挂载的其他文件系统 /opt存放额外安装的软件 /proc该目录是虚拟目录，是系统内存的映射，可以从中获取系统信息, 可直接修改里面的某些文件 /root超级管理员的主目录 /sbin存放系统管理相关的程序 selinuxRedhat&#x2F;CentOS 特有的，安全相关的文件 /srv存放服务启动后需提取的数据 /sys内核设备树的直观反映，创建内核对象时，会在这里新增对应的文件 /tmp存放临时文件 usr非常重要的目录，用户的程序和文件都放这里，类似 windows 的 program files 文件夹 usr/bin普通用户使用的程序 /usr/sbin超级管理员使用的程序 /usr/src存放源码的目录 /var存放经常被修改的文件，如 日志 /run临时文件系统，存储系统启动以来的信息。系统重启时，会清空 忘记密码的解决办法: 单用户模式 或 rescue 模式 linux 远程登录window 下远程登录客户端有 secureCRT, Putty, SSH Secure Shell, Xshell等 linux 文件基本属性123ls -al # 长列表格式 显示所有文件 包括 . ..ls -R # 递归地显示子目录内容ll # 同 ls -l 文件类型|属主权限|属组权限|其他用户的权限 文件类型: d 文件夹 - 文件 l 链接文件 b 二进制文件&#x2F;可执行文件&#x2F;接口设备 c 字符文件&#x2F;串行端口设备 文件归属 文件属主 文件所有者 文件属组 所有者的同组用户 其他用户 文件所有者,文件所有组和其他用户的权限。 对于 root 用户来说，一般情况下，文件的权限对其不起作用。 123456789101112131415161718192021222324252627282930cat /etc/group | sort # 查看用户组 (sort表示按字母排序) group_name:passwd:GID:user_list (passwd 为 x 表示加密)cat /etc/passwd | sort # 查看用户信息 user_name:passwd:uid:gid:group_name:home_dir:default_shellcat /etc/gshadow # 用户组的密码文件 group_name:passwd 密码是加密的cat /etc/shadow # 用户的密码文件 user_name:passwdwhoami # 查看当前登录用户groups &lt;user&gt; # 查看当前登录用户/指定用户 属于哪些组 如 groups rootls /etc/sudoers.d #sudo用户列表# 不同用户有不同权限 若没有x权限不能打开目录sudo adduser test # 创建用户test# sudo deluser test --remove-home 删除用户和用户的主目录cd /optmkdir myfolderll # 查看chown pan myfolder # 修改所有者为panchmod g-x,o-x myfolder # 同组和其他组的用户 取消执行权限su test # 切换到test用户cd myfolder # test用户没有myfolder的执行权限 所以打不开文件夹alias # 查看别名su - &lt;user&gt; # 切换用户 工作目录也切换到目标用户的home目录su &lt;user&gt; # 只切换用户tar -cvzf demo.tgz demoDir # 压缩文件夹tar -zxvf demo.tar.gz -C /home/pan # 解压到指定路径下(该路径需要真实存在)tar -tvf demo.tar # 查看压缩包内容 更改文件属性chgrp 更改文件属组 12# chgrp [-R] 属组名 文件名chgrp pan tmpdir chown 更改文件所有者，也可同时属组 123# chown [–R] 属主名 文件名# chown [-R] 属主名:属组名 文件名chown test:test tmpdir chmod 更改文件权限Linux 文件属性有两种设置方法，一种是数字，一种是符号。 符号: a &#x3D; all u &#x3D; user 所有者 g &#x3D; group o &#x3D; other 12345678chmod -R 700 hello # 用数字指定权限 相对方便chmod -R u+x hello # 属主+x权限chmod -R o-x hello # 其他用户-x权限chomd -R g+w hello # 属组+w权限chmod -R a+w hello # 所有用户+w权限chmod -R u=rxw hello # 设置所有者的权限chmod -R u=rxw,g=r,o=w hello # 设置三种用户的权限 (注意逗号分隔) linux 文件和目录管理Linux 的目录结构为树状结构，最顶级的目录为根目录 &#x2F; 绝对路径 从根目录开始 /home/pan, /media/pan 相对路径 ./pan or ../pan 目录管理命令 ls 列出目录内容 cd 切换目录 pwd 显示当前目录 mkdir 创建目录 rmdir 删除空目录 rm 删除文件或目录 cp 复制文件或目录 cp -r folder folder2 复制目录要加 -r mv 移动文件或目录, 也可以用来重命名文件或目录 man ls 查看帮助文档 列出目录 123ls -a # 全部文件，连同.开头的隐藏文件ls -d # 显示目录自身，而不是目录的内容ls -l # 长格式显示文件内容，包含文件的权限、大小和修改时间等 切换目录 123456cd /root/hellocd ./foocd ~ # 用户的主目录cd # 不带参数 同上 则返回用户主目录cd - # 返回之前的目录cd .. # 上级目录 显示当前目录 123456789pwdpwd -P # 显示真实路径，而非链接文件的路径# 例子cd ~ln -s Music mp3 # 创建软链接 mp3cd mp3pwd -P 创建目录 12345678mkdir dirnamemkdir -m 711 dirname # 配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～mkdir -p path/to/you/want # 创建多层目录cd path/to/you/wanttouch hellorm -rf path/to/you/wan/*rmdir -p path/to/you/want # rmdir 不能删除非空目录 所以要先用 rm 磁盘管理 df 列出磁盘使用量df [-ahHikmT] [目录或文件名] -a：列出所有的文件系统，包括系统特有的 &#x2F;proc 等文件系统; -k：以 KBytes 的容量显示各文件系统; -m：以 MBytes 的容量显示各文件系统; -h：以人们较易阅读的 GBytes，MBytes，KBytes 等格式自行显示; -H：以 M &#x3D; 1000K 取代 M &#x3D; 1024K 的进位方式; -T：显示文件系统类型，连同该分区的文件系统名称（例如 ext3）也列出; -i：不用硬盘容量，而以 inode 的数量来显示 du 查看文件&#x2F;目录的使用空间du [-ahskm] [文件或目录] -a：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。 -h：以人们较易读的容量格式（G &#x2F; M）显示; -s：列出总量而已，而不列出每个各别的目录占用容量; -S：不包括子目录下的总计(当前目录下文件的总大小)，与-s 有点差别。 -k：以 KBytes 列出容量显示; -m：以 MBytes 列出容量显示; 直接输入 du 没有加任何选项时，则 du 会分析当前所在目录的文件与目录所占用的硬盘空间。 fdisk 分区工具fdisk -l 【设备] 显示指定设备&#x2F;当前目录所在设备的分区信息fdisk /dev/sda1 对指定设备分区, (q 退出，w 保存) mkfs 分区格式化mkfs -t 文件系统类型 设备， 例如： mkfs -t mkfs.ext4 &#x2F;dev&#x2F;sda2 fsck 文件系统检查若系统掉电或磁盘发生问题，可用 fsck 进行检查, 详细用法见 fsck -h 磁盘挂载(mount)或卸载(umount)mount -L label -t 文件系统类型 挂载点 umount -fn 设备文件名或挂载点 定时任务crontab 命令(cron table)，它是 cron 的配置文件，也可以叫它作业列表，我们可以在以下文件夹内找到相关配置文件。 &#x2F;var&#x2F;spool&#x2F;cron&#x2F; 目录下存放的是每个用户包括 root 的 crontab 任务，每个任务以创建者的名字命名 &#x2F;etc&#x2F;crontab 这个文件负责调度各种管理和维护任务。 &#x2F;etc&#x2F;cron.d&#x2F; 这个目录用来存放任何要执行的 crontab 文件或脚本。 我们还可以把脚本放在&#x2F;etc&#x2F;cron.hourly、&#x2F;etc&#x2F;cron.daily、&#x2F;etc&#x2F;cron.weekly、&#x2F;etc&#x2F;cron.monthly 目录中，让它每小时&#x2F;天&#x2F;星期、月执行一次。 123456789101112131415161718192021222324252627282930313233343536373839crontab [-u username] # 省略用户 表示操作当前用户的crontab -e (编辑工作表) -l (列出工作表里的命令) -r (删除工作作)crontab -e # 编辑定时任务# 语法分 时 日 月 周 cmd# 例子# 每1分钟执行一次myCommand# 默认不支持秒级别执行频率* * * * * myCommand# 每小时的第3和第15分钟执行3,15 * * * * myCommand# 在上午8点到11点的第3和第15分钟执行3,15 8-11 * * * myCommand# 每隔两天的上午8点到11点的第3和第15分钟执行# * == */1 执行30次 每天1次 , 而 */2 代表 12次，每2天执行1次3,15 8-11 */2 * * myCommand# 每周一上午8点到11点的第3和第15分钟执行3,15 8-11 * * 1 myCommand# 每晚的21:30重启smb30 21 * * * /etc/init.d/smb restart# 每月1、10、22日的4 : 45重启smb45 4 1,10,22 * * /etc/init.d/smb restart# 每周六、周日的1 : 10重启smb10 1 * * 6,0 /etc/init.d/smb restart# 每天18 : 00至23 : 00之间每隔30分钟重启smb0,30 18-23 * * * /etc/init.d/smb restart# 每星期六的晚上11 : 00 pm重启smb0 23 * * 6 /etc/init.d/smb restart# 每一小时重启smb* */1 * * * /etc/init.d/smb restart# 晚上11点到早上7点之间，每隔一小时重启smb* 23-7/1 * * * /etc/init.d/smb restart 常用命令12345678type curl # 查看命令的类型 *可以用来确认有没有这个命令*type echotype ifconfigwhich mongo # 查看应用安装在哪里whereis mongo linux 后台运行和关闭、查看后台任务","tags":["Linux"],"categories":["Linux"]},{"title":"SQL零基础入门图文教程","path":"/2024/02/26/SQL零基础入门图文教程/","content":"原文地址❤️ SQL 零基础入门图文教程！ - 掘金 📚 前言SQL 语言有 40 多年的历史，从它被应用至今几乎无处不在。我们消费的每一笔支付记录，收集的每一条用户信息，发出去的每一条消息，都会使用数据库或与其相关的产品来存储，而操纵数据库的语言正是 SQL ！ SQL 对于现在的互联网公司生产研发等岗位几乎是一个必备技能，如果不会 SQL 的话，可能什么都做不了。你可以把 SQL 当做是一种工具，利用它可以帮助你完成你的工作，创造价值。 文章结尾有 SQL 小测验哦！看看你能得几分？ 🌴 SQL 介绍🌼 什么是 SQLSQL 是用于访问和处理数据库的标准的计算机语言。 SQL 指结构化查询语言 SQL 使我们有能力访问数据库 SQL 是一种 ANSI 的标准计算机语言 SQL 可与数据库程序协同工作，比如 MS Access、DB2、Informix、MS SQL Server、Oracle、Sybase 以及其他数据库系统。但是由于各种各样的数据库出现，导致很多不同版本的 SQL 语言，为了与 ANSI 标准相兼容，它们必须以相似的方式共同地来支持一些主要的关键词（比如 SELECT、UPDATE、DELETE、INSERT、WHERE 等等），这些就是我们要学习的 SQL 基础。 🌀 SQL 的类型可以把 SQL 分为两个部分：数据操作语言 (DML) 和 数据定义语言 (DDL)。 数据查询语言（DQL: Data Query Language） 数据操纵语言（DML：Data Manipulation Language） 🌵 学习 SQL 的作用SQL 是一门 ANSI 的标准计算机语言，用来访问和操作数据库系统。SQL 语句用于取回和更新数据库中的数据。 SQL 面向数据库执行查询 SQL 可从数据库取回数据 SQL 可在数据库中插入新的记录 SQL 可更新数据库中的数据 SQL 可从数据库删除记录 SQL 可创建新数据库 SQL 可在数据库中创建新表 SQL 可在数据库中创建存储过程 SQL 可在数据库中创建视图 SQL 可以设置表、存储过程和视图的权限 🍄 数据库是什么顾名思义，你可以理解为数据库是用来存放数据的一个容器。 打个比方，每个人家里都会有冰箱，冰箱是用来干什么的？冰箱是用来存放食物的地方。 同样的，数据库是存放数据的地方。正是因为有了数据库后，我们可以直接查找数据。例如你每天使用余额宝查看自己的账户收益，就是从数据库读取数据后给你的。 最常见的数据库类型是关系型数据库管理系统（RDBMS）： RDBMS 是 SQL 的基础，同样也是所有现代数据库系统的基础，比如 MS SQL Server, IBM DB2, Oracle, MySQL 以及 Microsoft Access 等等。 RDBMS 中的数据存储在被称为表（tables）的数据库对象中。表 是相关的数据项的集合，它由列和行组成。 由于本文主要讲解 SQL 基础，因此对数据库不做过多解释，只需要大概了解即可。咱们直接开始学习 SQL！ 🐥 SQL 基础语言学习在了解 SQL 基础语句使用之前，我们先讲一下 表 是什么？ 一个数据库通常包含一个或多个表。每个表由一个名字标识（例如“客户”或者“订单”）。表包含带有数据的记录(行)。 下面的例子是一个名为 “Persons” 的表： Id LastName FirstName Address City 1 Adams John Oxford Street London 2 Bush George Fifth Avenue New York 3 Carter Thomas Changan Street Beijing 上面的表包含三条记录（每一条对应一个人）和五个列（Id、姓、名、地址和城市）。 有表才能查询，那么如何创建这样一个表？ 🐤 CREATE TABLE – 创建表CREATE TABLE 语句用于创建数据库中的表。 语法： 1234567CREATE TABLE 表名称(列名称1 数据类型,列名称2 数据类型,列名称3 数据类型,....); 数据类型（data_type）规定了列可容纳何种数据类型。下面的表格包含了 SQL 中最常用的数据类型： 数据类型 描述 integer(size),int(size),smallint(size),tinyint(size) 仅容纳整数、在括号内规定数字的最大位数 decimal(size,d),numeric(size,d) 容纳带有小数的数字、”size” 规定数字的最大位数、”d” 规定小数点右侧的最大位数 char(size) 容纳固定长度的字符串（可容纳字母、数字以及特殊字符）、在括号中规定字符串的长度 varchar(size) 容纳可变长度的字符串（可容纳字母、数字以及特殊的字符）、在括号中规定字符串的最大长度 date(yyyymmdd) 容纳日期 实例： 本例演示如何创建名为 “Persons” 的表。 该表包含 5 个列，列名分别是：”Id_P”、”LastName”、”FirstName”、”Address” 以及 “City”： 12345678CREATE TABLE Persons(Id_P int,LastName varchar(255),FirstName varchar(255),Address varchar(255),City varchar(255)); Id_P 列的数据类型是 int，包含整数。其余 4 列的数据类型是 varchar，最大长度为 255 个字符。 空的 “Persons” 表类似这样： 可使用 INSERT INTO 语句向空表写入数据。 🐑 INSERT – 插入数据INSERT INTO 语句用于向表格中插入新的行。 语法： 1INSERT INTO 表名称 VALUES (值1, 值2,....); 我们也可以指定所要插入数据的列： 1INSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....); 实例： 本例演示 “Persons” 表插入记录的两种方式： 1、插入新的行 1INSERT INTO Persons VALUES (1, &#x27;Gates&#x27;, &#x27;Bill&#x27;, &#x27;Xuanwumen 10&#x27;, &#x27;Beijing&#x27;); 2、在指定的列中插入数据 1INSERT INTO Persons (LastName, Address) VALUES (&#x27;Wilson&#x27;, &#x27;Champs-Elysees&#x27;); 插入成功后，数据如下： 这个数据插入之后，是通过 SELECT 语句进行查询出来的，别急马上讲！ 🐼 SELECT – 查询数据SELECT 语句用于从表中选取数据，结果被存储在一个结果表中（称为结果集）。 语法： 1SELECT * FROM 表名称; 我们也可以指定所要查询数据的列： 1SELECT 列名称 FROM 表名称; 📢 注意： SQL 语句对大小写不敏感，SELECT 等效于 select。 实例： SQL SELECT * 实例： 1SELECT * FROM Persons; 📢 注意： 星号（*）是选取所有列的快捷方式。 如需获取名为 “LastName” 和 “FirstName” 的列的内容（从名为 “Persons” 的数据库表），请使用类似这样的 SELECT 语句： 1SELECT LastName,FirstName FROM Persons; 🐫 DISTINCT – 去除重复值如果一张表中有多行重复数据，如何去重显示呢？可以了解下 DISTINCT 。 语法： 1SELECT DISTINCT 列名称 FROM 表名称; 实例： 如果要从 “LASTNAME” 列中选取所有的值，我们需要使用 SELECT 语句： 1SELECT LASTNAME FROM Persons; 可以发现，在结果集中，Wilson 被列出了多次。 如需从 “LASTNAME” 列中仅选取唯一不同的值，我们需要使用 SELECT DISTINCT 语句： 1SELECT DISTINCT LASTNAME FROM Persons; 通过上述查询，结果集中只显示了一列 Wilson，显然已经去除了重复列。 🐸 WHERE – 条件过滤如果需要从表中选取指定的数据，可将 WHERE 子句添加到 SELECT 语句。 语法： 1SELECT 列名称 FROM 表名称 WHERE 列 运算符 值; 下面的运算符可在 WHERE 子句中使用： 操作符 描述 = 等于 &lt;&gt; 不等于 大于 &lt; 小于 &gt;&#x3D; 大于等于 &lt;&#x3D; 小于等于 BETWEEN 在某个范围内 LIKE 搜索某种模式 📢 注意： 在某些版本的 SQL 中，操作符 &lt;&gt; 可以写为 !&#x3D;。 实例： 如果只希望选取居住在城市 “Beijing” 中的人，我们需要向 SELECT 语句添加 WHERE 子句： 1SELECT * FROM Persons WHERE City=&#x27;Beijing&#x27;; 📢 注意： SQL 使用单引号来环绕文本值（大部分数据库系统也接受双引号）。如果是数值，请不要使用引号。 🐹 AND &amp; OR – 运算符AND 和 OR 可在 WHERE 子语句中把两个或多个条件结合起来。 如果第一个条件和第二个条件都成立，则 AND 运算符显示一条记录。 如果第一个条件和第二个条件中只要有一个成立，则 OR 运算符显示一条记录。 语法： AND 运算符实例： 1SELECT * FROM 表名称 WHERE 列 运算符 值 AND 列 运算符 值; OR 运算符实例： 1SELECT * FROM 表名称 WHERE 列 运算符 值 OR 列 运算符 值; 实例： 由于 Persons 表数据太少，因此增加几条记录： 12345INSERT INTO Persons VALUES (2, &#x27;Adams&#x27;, &#x27;John&#x27;, &#x27;Oxford Street&#x27;, &#x27;London&#x27;);INSERT INTO Persons VALUES (3, &#x27;Bush&#x27;, &#x27;George&#x27;, &#x27;Fifth Avenue&#x27;, &#x27;New York&#x27;);INSERT INTO Persons VALUES (4, &#x27;Carter&#x27;, &#x27;Thomas&#x27;, &#x27;Changan Street&#x27;, &#x27;Beijing&#x27;);INSERT INTO Persons VALUES (5, &#x27;Carter&#x27;, &#x27;William&#x27;, &#x27;Xuanwumen 10&#x27;, &#x27;Beijing&#x27;);SELECT * FROM Persons; AND 运算符实例： 使用 AND 来显示所有姓为 “Carter” 并且名为 “Thomas” 的人： 1SELECT * FROM Persons WHERE FirstName=&#x27;Thomas&#x27; AND LastName=&#x27;Carter&#x27;; OR 运算符实例： 使用 OR 来显示所有姓为 “Carter” 或者名为 “Thomas” 的人： 1SELECT * FROM Persons WHERE firstname=&#x27;Thomas&#x27; OR lastname=&#x27;Carter&#x27;; 结合 AND 和 OR 运算符： 我们也可以把 AND 和 OR 结合起来（使用圆括号来组成复杂的表达式）: 1SELECT * FROM Persons WHERE (FirstName=&#x27;Thomas&#x27; OR FirstName=&#x27;William&#x27;) AND LastName=&#x27;Carter&#x27;; 🐰 ORDER BY – 排序ORDER BY 语句用于根据指定的列对结果集进行排序，默认按照升序对记录进行排序，如果您希望按照降序对记录进行排序，可以使用 DESC 关键字。 语法： 1SELECT * FROM 表名称 ORDER BY 列1,列2 DESC; 默认排序为 ASC 升序，DESC 代表降序。 实例： 以字母顺序显示 LASTNAME 名称： 1SELECT * FROM Persons ORDER BY LASTNAME; 空值（NULL）默认排序在有值行之后。 以数字顺序显示ID_P，并以字母顺序显示 LASTNAME 名称： 1SELECT * FROM Persons ORDER BY ID_P,LASTNAME; 以数字降序显示ID_P： 1SELECT * FROM Persons ORDER BY ID_P DESC; 📢 注意： 在第一列中有相同的值时，第二列是以升序排列的。如果第一列中有些值为 null 时，情况也是这样的。 🐱 UPDATE – 更新数据Update 语句用于修改表中的数据。 语法： 1UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值; 实例： 更新某一行中的一个列： 目前 Persons 表有很多字段为 null 的数据，可以通过 UPDATE 为 LASTNAME 是 “Wilson” 的人添加 FIRSTNAME： 1UPDATE Persons SET FirstName = &#x27;Fred&#x27; WHERE LastName = &#x27;Wilson&#x27;; 更新某一行中的若干列： 1UPDATE Persons SET ID_P = 6,city= &#x27;London&#x27; WHERE LastName = &#x27;Wilson&#x27;; 🐨 DELETE – 删除数据DELETE 语句用于删除表中的行。 语法： 1DELETE FROM 表名称 WHERE 列名称 = 值; 实例： 删除某行： 删除 Persons 表中 LastName 为 “Fred Wilson” 的行： 1DELETE FROM Persons WHERE LastName = &#x27;Wilson&#x27;; 删除所有行： 可以在不删除表的情况下删除所有的行。这意味着表的结构、属性和索引都是完整的： 1DELETE FROM table_name; 🐵 TRUNCATE TABLE – 清除表数据如果我们仅仅需要除去表内的数据，但并不删除表本身，那么我们该如何做呢？ 可以使用 TRUNCATE TABLE 命令（仅仅删除表格中的数据）： 语法： 1TRUNCATE TABLE 表名称; 实例： 本例演示如何删除名为 “Persons” 的表。 1TRUNCATE TABLE persons; 🐯 DROP TABLE – 删除表DROP TABLE 语句用于删除表（表的结构、属性以及索引也会被删除）。 语法： 1DROP TABLE 表名称; 实例： 本例演示如何删除名为 “Persons” 的表。 1drop table persons; 从上图可以看出，第一次执行删除时，成功删除了表 persons，第二次执行删除时，报错找不到表 persons，说明表已经被删除了。 🚀 SQL 高级言语学习🚢 LIKE – 查找类似值LIKE 操作符用于在 WHERE 子句中搜索列中的指定模式。 语法： 1SELECT 列名/(*) FROM 表名称 WHERE 列名称 LIKE 值; 实例： Persons 表插入数据： 123456INSERT INTO Persons VALUES (1, &#x27;Gates&#x27;, &#x27;Bill&#x27;, &#x27;Xuanwumen 10&#x27;, &#x27;Beijing&#x27;);INSERT INTO Persons VALUES (2, &#x27;Adams&#x27;, &#x27;John&#x27;, &#x27;Oxford Street&#x27;, &#x27;London&#x27;);INSERT INTO Persons VALUES (3, &#x27;Bush&#x27;, &#x27;George&#x27;, &#x27;Fifth Avenue&#x27;, &#x27;New York&#x27;);INSERT INTO Persons VALUES (4, &#x27;Carter&#x27;, &#x27;Thomas&#x27;, &#x27;Changan Street&#x27;, &#x27;Beijing&#x27;);INSERT INTO Persons VALUES (5, &#x27;Carter&#x27;, &#x27;William&#x27;, &#x27;Xuanwumen 10&#x27;, &#x27;Beijing&#x27;);select * from persons; 1、现在，我们希望从上面的 “Persons” 表中选取居住在以 “N” 开头的城市里的人： 1SELECT * FROM Persons WHERE City LIKE &#x27;N%&#x27;; 2、接下来，我们希望从 “Persons” 表中选取居住在以 “g” 结尾的城市里的人： 1SELECT * FROM Persons WHERE City LIKE &#x27;%g&#x27;; 3、接下来，我们希望从 “Persons” 表中选取居住在包含 “lon” 的城市里的人： 1SELECT * FROM Persons WHERE City LIKE &#x27;%on%&#x27;; 4、通过使用 NOT 关键字，我们可以从 “Persons” 表中选取居住在不包含 “lon” 的城市里的人： 1SELECT * FROM Persons WHERE City NOT LIKE &#x27;%on%&#x27;; 📢 注意： “%” 可用于定义通配符（模式中缺少的字母）。 🚤 IN – 锁定多个值IN 操作符允许我们在 WHERE 子句中规定多个值。 语法： 1SELECT 列名/(*) FROM 表名称 WHERE 列名称 IN (值1,值2,值3); 实例： 现在，我们希望从 Persons 表中选取姓氏为 Adams 和 Carter 的人： 1SELECT * FROM Persons WHERE LastName IN (&#x27;Adams&#x27;,&#x27;Carter&#x27;); ⛵️ BETWEEN – 选取区间数据操作符 BETWEEN … AND 会选取介于两个值之间的数据范围。这些值可以是数值、文本或者日期。 语法： 1SELECT 列名/(*) FROM 表名称 WHERE 列名称 BETWEEN 值1 AND 值2; 实例： 1、查询以字母顺序显示介于 “Adams”（包括）和 “Carter”（不包括）之间的人： 1SELECT * FROM Persons WHERE LastName BETWEEN &#x27;Adams&#x27; AND &#x27;Carter&#x27;; 2、查询上述结果相反的结果，可以使用 NOT： 1SELECT * FROM Persons WHERE LastName NOT BETWEEN &#x27;Adams&#x27; AND &#x27;Carter&#x27;; 📢 注意： 不同的数据库对 BETWEEN…AND 操作符的处理方式是有差异的。 某些数据库会列出介于 “Adams” 和 “Carter” 之间的人，但不包括 “Adams” 和 “Carter” ；某些数据库会列出介于 “Adams” 和 “Carter” 之间并包括 “Adams” 和 “Carter” 的人；而另一些数据库会列出介于 “Adams” 和 “Carter” 之间的人，包括 “Adams” ，但不包括 “Carter” 。 所以，请检查你的数据库是如何处理 BETWEEN….AND 操作符的！ 🚂 AS – 别名通过使用 SQL，可以为列名称和表名称指定别名（Alias），别名使查询程序更易阅读和书写。 语法： 表别名： 1SELECT 列名称/(*) FROM 表名称 AS 别名; 列别名： 1SELECT 列名称 as 别名 FROM 表名称; 实例： 使用表名称别名： 123SELECT p.LastName, p.FirstNameFROM Persons pWHERE p.LastName=&#x27;Adams&#x27; AND p.FirstName=&#x27;John&#x27;; 使用列名别名： 1SELECT LastName &quot;Family&quot;, FirstName &quot;Name&quot; FROM Persons; 📢 注意： 实际应用时，这个 AS 可以省略，但是列别名需要加上 &quot; &quot;。 🚁 JOIN – 多表关联JOIN 用于根据两个或多个表中的列之间的关系，从这些表中查询数据。 有时为了得到完整的结果，我们需要从两个或更多的表中获取结果。我们就需要执行 join。 数据库中的表可通过键将彼此联系起来。主键（Primary Key）是一个列，在这个列中的每一行的值都是唯一的。在表中，每个主键的值都是唯一的。这样做的目的是在不重复每个表中的所有数据的情况下，把表间的数据交叉捆绑在一起。 如图，”Id_P” 列是 Persons 表中的的主键。这意味着没有两行能够拥有相同的 Id_P。即使两个人的姓名完全相同，Id_P 也可以区分他们。 ❤️ 为了下面实验的继续，我们需要再创建一个表：Orders。 1234567create table orders (id_o number,orderno number,id_p number);insert into orders values(1,11111,1);insert into orders values(2,22222,2);insert into orders values(3,33333,3);insert into orders values(4,44444,4);insert into orders values(6,66666,6);select * from orders; 如图，”Id_O” 列是 Orders 表中的的主键，同时，”Orders” 表中的 “Id_P” 列用于引用 “Persons” 表中的人，而无需使用他们的确切姓名。 1select * from persons p,orders o where p.id_p=o.id_p; 可以看到，”Id_P” 列把上面的两个表联系了起来。 语法： 1234select 列名from 表AINNER|LEFT|RIGHT|FULL JOIN 表BON 表A主键列 = 表B外键列; 不同的 SQL JOIN： 下面列出了您可以使用的 JOIN 类型，以及它们之间的差异。 JOIN: 如果表中有至少一个匹配，则返回行 INNER JOIN: 内部连接，返回两表中匹配的行 LEFT JOIN: 即使右表中没有匹配，也从左表返回所有的行 RIGHT JOIN: 即使左表中没有匹配，也从右表返回所有的行 FULL JOIN: 只要其中一个表中存在匹配，就返回行 实例： 如果我们希望列出所有人的定购，可以使用下面的 SELECT 语句： 12345SELECT p.LastName, p.FirstName, o.OrderNoFROM Persons pINNER JOIN Orders oON p.Id_P = o.Id_PORDER BY p.LastName DESC; 🚜 UNION – 合并结果集UNION 操作符用于合并两个或多个 SELECT 语句的结果集。 UNION 语法： 123SELECT 列名 FROM 表AUNIONSELECT 列名 FROM 表B; 📢 注意： UNION 操作符默认为选取不同的值。如果查询结果需要显示重复的值，请使用 UNION ALL。 UNION ALL 语法： 123SELECT 列名 FROM 表AUNION ALLSELECT 列名 FROM 表B; 另外，UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。 为了实验所需，创建 Person_b 表： 1234567891011121314CREATE TABLE Persons_b(Id_P int,LastName varchar(255),FirstName varchar(255),Address varchar(255),City varchar(255));INSERT INTO Persons_b VALUES (1, &#x27;Bill&#x27;, &#x27;Gates&#x27;, &#x27;Xuanwumen 10&#x27;, &#x27;Londo&#x27;);INSERT INTO Persons_b VALUES (2, &#x27;John&#x27;, &#x27;Adams&#x27;, &#x27;Oxford Street&#x27;, &#x27;nBeijing&#x27;);INSERT INTO Persons_b VALUES (3, &#x27;George&#x27;, &#x27;Bush&#x27;, &#x27;Fifth Avenue&#x27;, &#x27;Beijing&#x27;);INSERT INTO Persons_b VALUES (4, &#x27;Thomas&#x27;, &#x27;Carter&#x27;, &#x27;Changan Street&#x27;, &#x27;New York&#x27;);INSERT INTO Persons_b VALUES (5, &#x27;William&#x27;, &#x27;Carter&#x27;, &#x27;Xuanwumen 10&#x27;, &#x27;Beijing&#x27;);select * from persons_b; 实例： 使用 UNION 命令： 列出 persons 和 persons_b 中不同的人： 123select * from personsUNIONselect * from persons_b; 📢 注意： UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。 🚌 NOT NULL – 非空NOT NULL 约束强制列不接受 NULL 值。 NOT NULL 约束强制字段始终包含值。这意味着，如果不向字段添加值，就无法插入新记录或者更新记录。 语法： 1234CREATE TABLE 表(列 int NOT NULL); 如上，创建一个表，设置列值不能为空。 实例： 12create table lucifer (id number not null);insert into lucifer values (NULL); 📢 注意： 如果插入 NULL 值，则会报错 ORA-01400 提示无法插入！ ⭐️ 拓展小知识：NOT NULL 也可以用于查询条件： 1select * from persons where FirstName is not null; 同理，NULL 也可： 1select * from persons where FirstName is null; 感兴趣的朋友，可以自己尝试一下！ 🚐 VIEW – 视图在 SQL 中，视图是基于 SQL 语句的结果集的可视化的表。 视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。我们可以向视图添加 SQL 函数、WHERE 以及 JOIN 语句，我们也可以提交数据，就像这些来自于某个单一的表。 语法： 1234CREATE VIEW 视图名 ASSELECT 列名FROM 表名WHERE 查询条件; 📢 注意： 视图总是显示最近的数据。每当用户查询视图时，数据库引擎通过使用 SQL 语句来重建数据。 实例： 下面，我们将 Persons 表中住在 Beijing 的人筛选出来创建视图： 12create view persons_beijing asselect * from persons where city=&#x27;Beijing&#x27;; 查询上面这个视图： 如果需要更新视图中的列或者其他信息，无需删除，使用 CREATE OR REPLACE VIEW 选项： 1234CREATE OR REPLACE VIEW 视图名 ASSELECT 列名FROM 表名WHERE 查询条件; 实例： 现在需要筛选出，LASTNAME 为 Gates 的记录： 12create or replace view persons_beijing asselect * from persons where lastname=&#x27;Gates&#x27;; 删除视图就比较简单，跟表差不多，使用 DROP 即可： 1drop view persons_beijing; ❤️ 本章要讲的高级语言就先到此为止，不宜一次性介绍太多~ 🎯 SQL 常用函数学习SQL 拥有很多可用于计数和计算的内建函数。 函数的使用语法： 1SELECT function(列) FROM 表; ❤️ 下面就来看看有哪些常用的函数！ 🍔 AVG – 平均值AVG 函数返回数值列的平均值。NULL 值不包括在计算中。 语法： 1SELECT AVG(列名) FROM 表名; 实例： 计算 “orderno” 字段的平均值。 1select avg(orderno) from orders; 当然，也可以用在查询条件中，例如查询低于平均值的记录： 1select * from orders where orderno &lt; (select avg(orderno) from orders); 🍕 COUNT – 汇总行数COUNT() 函数返回匹配指定条件的行数。 语法： count() 中可以有不同的语法： COUNT(*) ：返回表中的记录数。 COUNT(DISTINCT 列名) ：返回指定列的不同值的数目。 COUNT(列名) ：返回指定列的值的数目（NULL 不计入）。 123SELECT COUNT(*) FROM 表名;SELECT COUNT(DISTINCT 列名) FROM 表名;SELECT COUNT(列名) FROM 表名; 实例： COUNT(*) ： 1select count(*) from persons; COUNT(DISTINCT 列名) ： 1select count(distinct city) from persons; COUNT(列名) ： 1select count(city) from persons; 🍘 MAX – 最大值MAX 函数返回一列中的最大值。NULL 值不包括在计算中。 语法： 1SELECT MAX(列名) FROM 表名; MIN 和 MAX 也可用于文本列，以获得按字母顺序排列的最高或最低值。 实例： 1select max(orderno) from orders; 🍢 MIN – 最小值MIN 函数返回一列中的最小值。NULL 值不包括在计算中。 语法： 1SELECT MIN(列名) FROM 表名; 实例： 1select min(orderno) from orders; 🍰 SUM – 求和SUM 函数返回数值列的总数（总额）。 语法： 1SELECT SUM(列名) FROM 表名; 实例： 1select sum(orderno) from orders; 🍪 GROUP BY – 分组GROUP BY 语句用于结合合计函数，根据一个或多个列对结果集进行分组。 语法： 1234SELECT 列名A, 统计函数(列名B)FROM 表名WHERE 查询条件GROUP BY 列名A; 实例： 获取 Persons 表中住在北京的总人数，根据 LASTNAME 分组： 123select lastname,count(city) from personswhere city=&#x27;Beijing&#x27;group by lastname; 如果不加 GROUP BY 则会报错： 也就是常见的 ORA-00937 不是单组分组函数的错误。 🍭 HAVING – 句尾连接在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与合计函数一起使用。 语法： 12345SELECT 列名A, 统计函数(列名B)FROM table_nameWHERE 查询条件GROUP BY 列名AHAVING 统计函数(列名B) 查询条件; 实例： 获取 Persons 表中住在北京的总人数大于 1 的 LASTNAME，根据 LASTNAME 分组： 1234select lastname,count(city) from personswhere city=&#x27;Beijing&#x27;group by lastnamehaving count(city) &gt; 1; 🍷 UCASE&#x2F;UPPER – 大写UCASE/UPPER 函数把字段的值转换为大写。 语法： 1select upper(列名) from 表名; 实例： 选取 “LastName” 和 “FirstName” 列的内容，然后把 “LastName” 列转换为大写： 1select upper(lastname),firstname from persons; 🍶 LCASE&#x2F;LOWER – 小写LCASE/LOWER 函数把字段的值转换为小写。 语法： 1select lower(列名) from 表名; 实例： 选取 “LastName” 和 “FirstName” 列的内容，然后把 “LastName” 列转换为小写： 1select lower(lastname),firstname from persons; 👛 LEN&#x2F;LENGTH – 获取长度LEN/LENGTH 函数返回文本字段中值的长度。 语法： 1select length(列名) from 表名; 实例： 获取 LASTNAME 的值字符长度： 1select length(lastname),lastname from persons; 🍗 ROUND – 数值取舍ROUND 函数用于把数值字段舍入为指定的小数位数。 语法： 1select round(列名,精度) from 表名; 实例： 保留 2 位： 12select round(1.1314,2) from dual;select round(1.1351,2) from dual; 📢 注意：ROUND 取舍是 四舍五入 的！ 取整： 12select round(1.1351,0) from dual;select round(1.56,0) from dual; 🍞 NOW&#x2F;SYSDATE – 当前时间NOW/SYSDATE 函数返回当前的日期和时间。 语法： 1select sysdate from 表名; 实例： 获取当前时间： 1select sysdate from dual; 📢 注意： 如果您在使用 Sql Server 数据库，请使用 getdate() 函数来获得当前的日期时间。 🍺 写在最后**上述如果都学完了的话，可以来做个小测验：SQL 测验**，看看掌握的怎么样！","tags":["SQL"],"categories":["SQL"]},{"title":"Python基础教程","path":"/2024/02/26/Python基础教程/","content":"python 基础教程python 教程 廖雪峰 简介python 是一种简单优雅的脚本语言，包含非常完善的基础代码库, 覆盖网络、文件、GUI、 数据库、文本等, 除了内置库以外还有大量第三方库。 python 的适用范围: web应用、脚本程序和自动化工具 安装python 是跨平台的，解释型的脚本语言 (脚本语言基本都是跨平台的)python 有 2.x 和 3.x 两个版本，较多的应用都是基于 2.x 开发的，目前的主流版本应该是 3.x; 安装 python 就是安装 python解释器, 得到一个命令行交互环境. mac brew install python3 ubuntu sodu apt-get install python3 window 直接到官网下载对应安装包 安装后将 python 安装目录，添加到环境变量, 然后打开命令行，输入 python ， 进入交互环境 注意 windows 用户在 git bash 下，输入 python，不能进入到 python 交互环境, 执行 winpty python 进入交互环境 在命令行中输入 python 进入交互模式 进入交互模式123&gt; python&gt;&gt;&gt; print(&#x27;hello world&#x27;)&gt;&gt;&gt; exit() 执行 python 脚本 执行 python 脚本1python hello.py 开始菜单可以找到 python 专用 REPL 工具 ( IDLE ) python 解释器python 代码文件以.py为后缀，由 python 解释器解释执行。 python 有多种解释器: CPython 官方解释器，C 语言开发的，所以叫 CPython, 命令行下输入 python 就是进入 CPython 解释器环境 IPython 增强版的 CPython PyPy 执行速度较快 Jython 把 python 编译成 java 字节码执行 IronPython 运行在.NET 平台的 pyton 解释器 命令行交互环境可在命令行交互环境执行，或保存为 hello.py 文件 123&gt; python&gt;&gt;&gt;print(&#x27;hello world&#x27;)&gt;&gt;&gt;exit() 执行python脚本1234567891011# 用python命令执行指定python脚本python hello.py# Mac 或 Linux上还可直接运行python脚本# ---- hello.py ----&gt;#!/usr/bin/env python3print(&#x27;hello world&#x27;)&gt; chmod a+x hello.py&gt; ./hello.py 输出123print(&#x27;hello python&#x27;)print(&#x27;nice&#x27;, &#x27;to&#x27;, &#x27;meet&#x27;, &#x27;you&#x27;) # 可打印多个字符串 同 console.logprint(&#x27;100+200=&#x27;, 100+200) # 逗号分隔的每个表达式间加空格 输入123name = input(&#x27;input your name:&#x27;) # python3name = raw_input(&#x27;input your name:&#x27;) # python2print(name) 语法python 的语法比较简单 用缩进表示代码块; 不用括号,花括号划分代码块 不用分号表示语句结束 标识符大小写敏感 不需要声明变量 不需要 var 等关键字 1234567# print absolute valuea = -120if a &gt;= 0: print(a)else: print(-a) 数据类型和变量python 的数据类型包括: 整数、浮点数、字符串、字节型、布尔值、空值、列表、字典和自定义类型 12345678910111213141516171819202122232425262728293031323334353637383940411, 100, -80, 0xfa # 整数1.23 1.23e9, 1.2e-5 # 浮点数# 字符串 单双引号互相包含&quot;what&#x27;s your name&quot;&#x27;I\\&#x27;m &quot;OK&quot;&#x27;# raw string 内部的特殊字符都做普通字符对待r&#x27;\\the-school &#x27;# 三引号 可输出换回字符串&#x27;&#x27;&#x27;line1,line2&#x27;&#x27;&#x27;r&#x27;&#x27;&#x27;line one \\twill not escape&#x27;&#x27;&#x27;# f-string 变量插值name = &#x27;Alice&#x27;f&#x27;hi, &#123;name&#125;&#x27;# 字节型 bytesb&#x27;ABC&#x27;len(&#x27;abc&#x27;) # 3b&#x27;hello&#x27;.decode(&#x27;ascii&#x27;)len(b&#x27;good&#x27;) # 4# 布尔值True False# 逻辑运算符and or not# 空值None# 条件判断if age &gt;= 18: print(&#x27;adult&#x27;)else: print(&#x27;teenager&#x27;) python 是弱类型语言 1234a = 100 # 整数print(a)a = &#x27;hello&#x27; # 字符串print(a) python 中常量习惯用全大写字母表示, 如 PI=3.1415, 并非真正意义的常量(同 JS) python 的两种除法： 1234567print(10 / 3) # 3.33.. 普通除法/真除法，结果为浮点数print(9 / 3) # 3.0 真除法计算结果总是浮点数，即使是两个整数恰好整除print(10 // 3) # 3 地板除 结果为整数 整除(有小数 则向下取整) 结果为整数print(20 // 3) # 6print(10 % 3) # 1 模运算，取余数 python 的整数和浮点数没有大小限制 字符串和编码字符编码因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用 8 个比特（bit）作为一个字节（byte） ASCII 1 个字节，最大 255 由于计算机是美国人发明的，因此，最早只有 127 个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为 ASCII 编码，比如大写字母 A 的编码是 65，小写字母 z 的编码是 122 GB2312 处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和 ASCII 编码冲突，所以，中国制定了 GB2312 编码，用来把中文编进去 Unicode 最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要 4 个字节） 全世界有上百种语言，日本把日文编到 Shift_JIS 里，韩国把韩文编到 Euc-kr 里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码 因此，Unicode 应运而生。Unicode 把所有语言都统一到一套编码里，这样就不会再有乱码问题了 UTF-8 用于存储和传输 英文 1 个字节 中文 3 个字节 统一成 Unicode 编码，解决了乱码问题；但是，如果你写的文本基本上全部是英文的话，用 Unicode 编码比 ASCII 编码需要多一倍的存储空间，在存储和传输上就十分不划算。所以，本着节约的精神，又出现了把 Unicode 编码转化为“可变长编码”的 UTF-8 编码。UTF-8 编码把一个 Unicode 字符根据不同的数字大小编码成 1-6 个字节，常用的英文字母被编码成 1 个字节，汉字通常是 3 个字节，只有很生僻的字符才会被编码成 4-6 个字节。如果你要传输的文本包含大量英文字符，用 UTF-8 编码就能节省空间： 在计算机内存中，统一使用 Unicode 编码，当需要保存到硬盘或者需要传输的时候，就转换为 UTF-8 编码。 用记事本编辑的时候，从文件读取的 UTF-8 字符被转换为 Unicode 字符到内存里，编辑完成后，保存的时候再把 Unicode 转换为 UTF-8 保存到文件 浏览网页的时候，服务器会把动态生成的 Unicode 内容转换为 UTF-8 再传输到浏览器, 所以你看到很多网页的源码上会有类似&lt;meta charset=&quot;UTF-8&quot; /&gt;的信息，表示该网页正是用的 UTF-8 编码。 Python 的字符串在最新的 Python 3 版本中，字符串是以 Unicode 编码的，也就是说，Python 的字符串支持多语言 12345print(&#x27;包含中文的str&#x27;)print(ord(&#x27;A&#x27;)) # 字符对应的编码print(chr(66)) # 编码对应的字符# 知道字符的编码，可用十六进制 输出字符print(&#x27;\\u4e2d\\u6587&#x27;) 由于 Python 的字符串，在内存中以 Unicode 表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把 str 变为以字节为单位的 bytes 用带 b 前缀的单引号或双引号表示bytes类型 12strVal = &#x27;Hello&#x27;bytesVal = b&#x27;Hello&#x27; # bytes的每个字符都只占用一个字节。 以 Unicode 表示的 str 通过 encode()方法可以编码为指定的 bytes 123print(&#x27;ABC&#x27;.encode(&#x27;ascii&#x27;)) # b&#x27;ABC&#x27;print(&#x27;中文&#x27;.encode(&#x27;utf-8&#x27;)) # b&#x27;\\xe4\\xb8\\xad\\xe6\\x96\\x87&#x27;&#x27;中文&#x27;.encode(&#x27;ascii&#x27;) # 报错 中文不能编码为ascii的bytes 反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是 bytes。要把 bytes 变为 str，就需要用 decode()方法： 123456&gt;&gt;&gt; b&#x27;ABC&#x27;.decode(&#x27;ascii&#x27;)&#x27;ABC&#x27;&gt;&gt;&gt; b&#x27;\\xe4\\xb8\\xad\\xe6\\x96\\x87&#x27;.decode(&#x27;utf-8&#x27;)&#x27;中文&#x27;&gt;&gt;&gt; b&#x27;\\xe4\\xb8\\xad\\xff&#x27;.decode(&#x27;utf-8&#x27;, errors=&#x27;ignore&#x27;) # 忽略错误的字节 len()函数计算的是 str 的字符数，不是字符串占用的字节数，如果换成 bytes，len()函数就计算字节数 len(seq) 返回序列元素个数 12345678910&gt;&gt;&gt; len(&#x27;ABC&#x27;)3&gt;&gt;&gt; len(&#x27;中文&#x27;)2&gt;&gt;&gt; len(b&#x27;ABC&#x27;)3&gt;&gt;&gt; len(b&#x27;\\xe4\\xb8\\xad\\xe6\\x96\\x87&#x27;)6&gt;&gt;&gt; len(&#x27;中文&#x27;.encode(&#x27;utf-8&#x27;))6 可见，1 个中文字符经过 UTF-8 编码后通常会占用 3 个字节，而 1 个英文字符只占用 1 个字节 由于 Python 源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为 UTF-8 编码。当 Python 解释器读取源代码时，为了让它按 UTF-8 编码读取，我们通常在代码文件开头声明编码格式： 12345# 首行 hash-bang-line 告诉Linux/OS X系统，# 这是一个Python可执行程序，Windows系统会忽略这个注释；#!/usr/bin/env python3 # -*- coding: utf-8 -*- ## 告诉Python解释器，按照UTF-8编码读取源代码 格式化字符串%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。 在 Python 中，采用的格式化方式和 C 语言是一致的，用%实现 格式化字符串常用占位符 占位符 替换内容 %d 整数 %f 浮点数 %s 字符串 %x 十六进制整数 12345678910111213141516171819202122# %d 整数 %f浮点数 %g 整数或科学计数法显示print(&#x27;Hello, %s&#x27; % &#x27;world&#x27;)# 多个变量占位 值用元组print(&#x27;Hi %s, you have spent $%d&#x27; % （&#x27;sindy&#x27;, 1000))# g =&gt; guestprint(&#x27;normal number: %g&#x27; % 123)print(&#x27;big number: %g&#x27; % 1234567)print(&#x27;float number: %f&#x27; % 12.2235)print(&#x27;float number: %.2f&#x27; % 12.2225)print(&#x27;float number: %+.2f&#x27; % -12.6135)print(&#x27;float number: % .2f&#x27; % 12.5685)print(&#x27;%2d-%02d&#x27; % (3, 1))print(&#x27;%.2f&#x27; % 3.1415926)# 不太确定应该用什么占位符，%s永远起作用，它会把任何数据类型转换为字符串print(&#x27;Age: %s. Gender: %s&#x27; % (25, True))# 转义，用%%来表示一个%print(&#x27;growth rate: %d %%&#x27; % 7) format方法格式化字符串, 语法`strPattern.format(val1)`它会用传入的参数依次替换字符串内的占位符`{0}、{1}……` 1&gt;&gt;&gt; &#x27;Hello, &#123;0&#125;, 成绩提升了 &#123;1:.1f&#125;%&#x27;.format(&#x27;小明&#x27;, 17.125) f-string语法格式化字符串(变量插值), 语法： `f'hello {varName}'` f-string123r = 2.5s = 3.14 * r ** 2print(f&#x27;The area of a circle with radius &#123;r&#125; is &#123;s:.2f&#125;&#x27;) 字典列表和元组列表是元素的有序集合，可增删元素, 不要求元素的数据类型相同 123456789101112131415161718roles = [&#x27;nami&#x27;, &#x27;zoro&#x27;, &#x27;lufy&#x27;]print(roles)len(roles) # 3roles[10] # 索引越界会报错 IndexErrorroles[-1] # 最后一个元素 支持负索引roles.append(&#x27;robin&#x27;) # 在末尾追加元素roles.insert(1, &#x27;sandge&#x27;) # 在指定位置插入元素roles.pop() # 删除末尾元素roles.pop(1) # 删除指定位置元素roles[1] = &#x27;jobar&#x27; # 修改元素# 二维数组langs = [&#x27;python&#x27;, &#x27;java&#x27;, [&#x27;asp&#x27;, &#x27;php&#x27;], &#x27;scheme&#x27;] tuple 和 list 很相似，不过元组的元素是不可修改的, 所以元组没有`append()`, `insert()`之类的方法 1234567colors = (&#x27;yellow&#x27;, &#x27;green&#x27;, &#x27;red&#x27;)colors2 = () # 空元组nums = (1,) # 只有1个数字的元组，nums = (1) 括号会被认为是数字求值， 所以要加个,# 元组的元素为列表，列表的元素可修改friends = (&#x27;idle&#x27;, &#x27;sandy&#x27;, [&#x27;lucy&#x27;, 8])friends[2][1] = 18 条件判断12345678910111213141516171819age = 3# 多分支if age &gt;= 18: print(&#x27;your age is&#x27;, age) print(&#x27;adult&#x27;)elif age &gt;= 6: print(&#x27;teenager&#x27;)else: print(&#x27;your age is&#x27;, age) print(&#x27;kid&#x27;)s = input(&#x27;birth year: &#x27;)birth = int(s) # 转换为数值型# 两个分支if birth &lt; 2000: print(&#x27;00前&#x27;)else: print(&#x27;00后&#x27;) 循环123456789101112131415161718192021222324252627282930313233343536names = [&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;]# for 循环，遍历序列for name in names: print(name)for i in range(10): print(i)sum = 0n = 99# wile循环, 条件循环while n &gt; 0: sum = sum + n n = n - 2print(sum)n = 1while n &lt;= 100: if n &gt; 10: # 当n = 11时，条件满足，执行break语句 break # break语句会结束当前循环 print(n) n = n + 1print(&#x27;END&#x27;)n = 0while n &lt; 10: n = n + 1 if n % 2 == 0: # 如果n是偶数，执行continue语句 # continue语句会直接继续下一轮循环， # 后续的print()语句不会执行 continue print(n) 字典 dictdict 全称 dictionary，在其他语言中也称为 map，使用键-值（key-value）存储，具有极快的查找速度。 同 js 的对象 123456789101112# !!属性名的引号不能省略role = &#123;&#x27;name&#x27;: &#x27;rufy&#x27;, &#x27;age&#x27;: 18, &#x27;skill&#x27;: &#x27;stretch&#x27;&#125; role[&#x27;age&#x27;] = 19# role.age = 20 这样修改属性值报错 :(# 判断属性是否存在if(&#x27;age&#x27; in role): print(&#x27;yes&#x27;)role.get(&#x27;age&#x27;) # 若没有age字段 返回Nonerole.get(&#x27;age&#x27;, 10) # 没有age字段 返回默认值 在 Python 代码中几乎无处不在，正确使用 dict 非常重要，需要牢记的第一条就是 dict 的 key 必须是不可变对象。 这是因为 dict 根据 key 来计算 value 的存储位置，如果每次计算相同的 key 得出的结果不同，那 dict 内部就完全混乱了。这个通过 key 计算位置的算法称为哈希算法（Hash）。 要保证 hash 的正确性，作为 key 的对象就不能变。在 Python 中，字符串、整数等都是不可变的，因此，可以放心地作为 key。而 list 是可变的，就不能作为 key 集合 setset 是无序不重复的元素集合 1234567s = set([1,2,3])print(s) # &#123;1, 2, 3&#125;s.add(4) # 添加元素s2 = set([3,4,5])print(s &amp; s2) # 交集print(s | s2) # 并集 set 和 dict 的唯一区别仅在于没有存储对应的 value，但是，set 的原理和 dict 一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证 set 内部“不会有重复元素”。试试把 list 放入 set，看看是否会报错。 函数Python 内置了很多有用的函数，我们可以直接调用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124&gt;&gt;&gt;help(abs) # 查看函数帮助abs(-120)abs(-1, 2) # 入参数量不对 会报错abs(&#x27;ABC&#x27;) # 入参类型不对 会报错min(1,2)max(2,3) # min max不限定参数个数# 数据类型转换int(&#x27;12&#x27;)float(&#x27;12.33&#x27;)str(100)bool(1)bool(&#x27;&#x27;)hex(100)# 函数定义def myabs(x): if x &gt;= 0: return x else: return -xdef my_abs2(x): # 参数类型检查 if not isinstance(x, (int, float)): raise TypeError(&#x27;bad operand type&#x27;) if x &gt;= 0: return x else: return -xmyabs(-9) # 函数调用# 空函数def noop(): # pass可以用来作为占位符， # 比如现在还没想好怎么写函数的代码， # 就可以先放一个pass，让代码能运行起来 pass # 返回多个值import mathdef move(x, y, step, angle=0): nx = x + step * math.cos(angle) ny = y - step * math.sin(angle) return nx, ny # 实际返回的是一个tuplex, y = move(100, 100, 60, math.pi / 6) # 解构赋值print(x, y)r = move(100, 100, 60, math.pi / 6)print(r)# 位置参数 x n , 参数默认值def power(x, n = 2): s = 1 while n &gt; 0: n = n - 1 s = s * x return sdef enroll(name, gender, age=6, city=&#x27;Beijing&#x27;): print(&#x27;name:&#x27;, name) print(&#x27;gender:&#x27;, gender) print(&#x27;age:&#x27;, age) print(&#x27;city:&#x27;, city)# 多个默认参数 用参数名只指定某个参数值enroll(&#x27;Adam&#x27;, &#x27;M&#x27;, city=&#x27;Tianjin&#x27;)# 默认参数必须是不可变对象，不然容易掉坑def add_end(L=[]): L.append(&#x27;END&#x27;) return Ladd_end()add_end() # [&#x27;END&#x27;, &#x27;END&#x27;] 每次调用时，默认参数指向的地址不变# 可变参数 参数个数可变def calc(*numbers): sum = 0 for n in numbers: sum = sum + n * n return sumcalc(1,2) # 参数会被自动组装为tuplecalc()# tuple 或 list 展开作为可变参数传入nums = [1,2,3]calc(*nums)# 关键字参数 类似js函数的optionsdef person(name, age, **kw): print(&#x27;name:&#x27;, name, &#x27;age:&#x27;, age, &#x27;other:&#x27;, kw)# 关键字参数会被组装为dict对象kwperson(&#x27;Adam&#x27;, 45, gender=&#x27;M&#x27;, job=&#x27;Engineer&#x27;) # dict展开作为关键字参数传入extra = &#123;&#x27;city&#x27;: &#x27;Beijing&#x27;, &#x27;job&#x27;: &#x27;Engineer&#x27;&#125;person(&#x27;Jack&#x27;, 24, **extra)# 命名关键字参数，约束关键字参数只能包含指定字段# 组装成dict, 函数内部再解构为字段同名的变量def person(name, age, *, city, job): print(name, age, city, job)person(&#x27;jack&#x27;, 23, job=&#x27;worker&#x27;, city=&#x27;beijing&#x27;)# 如果函数定义中已经有了一个可变参数，# 后面跟着的命名关键字参数就不再需要一个特殊分隔符*了def person2(name, age, *args, city, job): print(name, age, args, city, job)person2(&#x27;jack&#x27;, 12, &#x27;hello&#x27;, &#x27;world&#x27;, city=&#x27;beijing&#x27;, job=&#x27;accounting&#x27;)# 命名关键字参数可以有缺省值def person(name, age, *, city=&#x27;Beijing&#x27;, job): print(name, age, city, job)person(&#x27;Jack&#x27;, 24, job=&#x27;Engineer&#x27;) 参数组合在 Python 中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这 5 种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。 12345678910111213141516171819202122232425262728def f1(a, b, c=0, *args, **kw): print(&#x27;a =&#x27;, a, &#x27;b =&#x27;, b, &#x27;c =&#x27;, c, &#x27;args =&#x27;, args, &#x27;kw =&#x27;, kw)def f2(a, b, c=0, *, d, **kw): print(&#x27;a =&#x27;, a, &#x27;b =&#x27;, b, &#x27;c =&#x27;, c, &#x27;d =&#x27;, d, &#x27;kw =&#x27;, kw)&gt;&gt;&gt; f1(1, 2)a = 1 b = 2 c = 0 args = () kw = &#123;&#125;&gt;&gt;&gt; f1(1, 2, c=3)a = 1 b = 2 c = 3 args = () kw = &#123;&#125;&gt;&gt;&gt; f1(1, 2, 3, &#x27;a&#x27;, &#x27;b&#x27;)a = 1 b = 2 c = 3 args = (&#x27;a&#x27;, &#x27;b&#x27;) kw = &#123;&#125;&gt;&gt;&gt; f1(1, 2, 3, &#x27;a&#x27;, &#x27;b&#x27;, x=99)a = 1 b = 2 c = 3 args = (&#x27;a&#x27;, &#x27;b&#x27;) kw = &#123;&#x27;x&#x27;: 99&#125;&gt;&gt;&gt; f2(1, 2, d=99, ext=None)a = 1 b = 2 c = 0 d = 99 kw = &#123;&#x27;ext&#x27;: None&#125;&gt;&gt;&gt; args = (1, 2, 3, 4)&gt;&gt;&gt; kw = &#123;&#x27;d&#x27;: 99, &#x27;x&#x27;: &#x27;#&#x27;&#125;&gt;&gt;&gt; f1(*args, **kw)a = 1 b = 2 c = 3 args = (4,) kw = &#123;&#x27;d&#x27;: 99, &#x27;x&#x27;: &#x27;#&#x27;&#125;&gt;&gt;&gt; args = (1, 2, 3)&gt;&gt;&gt; kw = &#123;&#x27;d&#x27;: 88, &#x27;x&#x27;: &#x27;#&#x27;&#125;&gt;&gt;&gt; f2(*args, **kw)a = 1 b = 2 c = 3 d = 88 kw = &#123;&#x27;x&#x27;: &#x27;#&#x27;&#125;# 对于任意函数，都可以通过类似 func(*args, **kw) # 的形式调用它，无论它的参数是如何定义的 Python 的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。 默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！ 要注意定义可变参数和关键字参数的语法： *args 是可变参数，args 接收的是一个 tuple； **kw 是关键字参数，kw 接收的是一个 dict。 以及调用函数时如何传入可变参数和关键字参数的语法： 可变参数既可以直接传入：func(1, 2, 3)，又可以先组装 list 或 tuple，再通过*args 传入：func(*(1, 2, 3))； 关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装 dict，再通过**kw 传入：func(**&#123;&#39;a&#39;: 1, &#39;b&#39;: 2&#125;)。 使用 *args 和 **kw 是 Python 的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。 命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。 定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*，否则定义的将是位置参数。 递归函数在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。 使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出 123456def fact(n): if n==1: return 1 return n * fact(n - 1)print(fact(10)) 解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。 尾递归是指，在函数返回的时候，调用自身本身，并且，return 语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。 上面的 fact(n) 函数由于 return n * fact(n - 1) 引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中： 123456789def fact(n): return fact_iter(n, 1)def fact_iter(num, product): if num == 1: return product return fact_iter(num - 1, num * product)fact(100) 遗憾的是，大多数编程语言没有针对尾递归做优化，Python 解释器也没有做优化，所以，即使把上面的 fact(n)函数改成尾递归方式，也会导致栈溢出。 尾递归事实上和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环。 1234567891011## 利用递归函数移动汉诺塔:def move(n, a, b, c): if n == 1: print(&#x27;move&#x27;, a, &#x27;--&gt;&#x27;, c) else: move(n-1, a, c, b) move(1, a, b, c) move(n-1, b, a, c)move(4, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;) 高级特性切片12345678910111213L = [&#x27;Michael&#x27;, &#x27;Sarah&#x27;, &#x27;Tracy&#x27;, &#x27;Bob&#x27;, &#x27;Jack&#x27;]# list[start:end:step]L[0:3] # 前3个元素同 L[:3]L[-3:] # 后3个元素L[-2:-1] # 倒数切片L[-1] # 末尾元素L[:10:2] # 前10个数，每两个取一个L[::5] # 所有数，每5个取一个L[:] # 取所有，即复制一个list# tuple和字符串也是序列，同样可用切片操作(0, 1, 2, 3, 4, 5)[:3]&#x27;ABCDEFG&#x27;[:3] 迭代如果给定一个 list 或 tuple，我们可以通过 for 循环来遍历这个 list 或 tuple，这种遍历我们称为迭代（Iteration）。 Python 的 for 循环抽象程度要高于 C 的 for 循环，因为 Python 的 for 循环不仅可以用在 list 或 tuple 上，还可以作用在其他可迭代对象上。 1234567891011d = &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;for key in d: print(&#x27;key:&#x27;, key)for val in d.values(): print(&#x27;val:&#x27;, val)for key,val in d.items(): print(&#x27;key:&#x27;, key, &#x27; val:&#x27;, val)for c in &#x27;ABCD&#x27;: print(&#x27;c:&#x27;, c) 当我们使用 for 循环时，只要作用于一个可迭代对象，for 循环就可以正常运行，而我们不太关心该对象究竟是 list 还是其他数据类型 1234567891011121314151617# 判断对象是否可迭代&gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; isinstance(&#x27;abc&#x27;, Iterable) # str是否可迭代True&gt;&gt;&gt; isinstance([1,2,3], Iterable) # list是否可迭代True&gt;&gt;&gt; isinstance(123, Iterable) # 整数是否可迭代Falsefor i, value in enumerate([&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]): print(i, value)# for循环里，同时引用了两个变量，在Python里是很常见的for x,y in [(1,2), (3,4)]: print(x, y) 列表生成式列表生成式即 List Comprehensions，是 Python 内置的非常简单却强大的可以用来创建 list 的生成式 12345678910111213141516171819202122# [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]list(range(1, 11))# [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 类似js map[x * x for x in range(1, 11)] # [4, 16, 36, 64, 100] js arr filter and map[x * x for x in range(1, 11) if x % 2 == 0] # [&#x27;AX&#x27;, &#x27;AY&#x27;, &#x27;AZ&#x27;, &#x27;BX&#x27;, &#x27;BY&#x27;, &#x27;BZ&#x27;, &#x27;CX&#x27;, &#x27;CY&#x27;, &#x27;CZ&#x27;] 笛卡尔积[m + n for m in &#x27;ABC&#x27; for n in &#x27;XYZ&#x27;] # 导入os模块，模块的概念后面讲到import os# os.listdir可以列出文件和目录[d for d in os.listdir(&#x27;.&#x27;)] d = &#123;&#x27;hi&#x27;: &#x27;hello&#x27;, &#x27;age&#x27;: &#x27;12&#x27;, &#x27;name&#x27;: &#x27;lufy&#x27;&#125;#[&#x27;y=B&#x27;, &#x27;x=A&#x27;, &#x27;z=C&#x27;][k + &#x27;=&#x27; + v for k, v in d.items()] L = [&#x27;Hello&#x27;, &#x27;World&#x27;, &#x27;IBM&#x27;, &#x27;Apple&#x27;]print([s.lower() for s in L]) 生成器要创建一个 generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个 generator： 同 es6 的 generator通过 next() 函数获得 generator 的下一个返回值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950L = [x * x for x in range(10)]print(L)g = (x * x for x in range(10))print(g)print(next(g))# generator也是可迭代的for n in g: print(n)# 著名的斐波拉契数列（Fibonacci），# 除第一个和第二个数外，任意一个数都可由前两个数相加得到def fib(max): n, a, b = 0, 0, 1 while n &lt; max: print(b) a, b = b, a + b n = n + 1 return &#x27;done&#x27;# 函数定义中包含yield关键字，那么这个函数就# 不再是一个普通函数，而是一个generatordef fib(max): n, a, b = 0, 0, 1 while n &lt; max: yield b a, b = b, a + b n = n + 1 return &#x27;done&#x27;def odd(): print(&#x27;step 1&#x27;) yield 1 print(&#x27;step 2&#x27;) yield(3) print(&#x27;step 3&#x27;) yield(5)og = odd()for n in og: print(n)g = fib(6)while True: try: x = next(g) print(&#x27;g:&#x27;, x) except StopIteration as e: print(&#x27;Generator return value:&#x27;, e.value) break generator 是非常强大的工具，在 Python 中，可以简单地把列表生成式改成 generator，也可以通过函数实现复杂逻辑的 generator。 迭代器用于 for 循环的数据类型有以下几种： 一类是集合数据类型，如 list、tuple、dict、set、str 等； 一类是 generator 生成器和带 yield 的 generator function。 12345from collections import Iterableprint(isinstance([], Iterable)) // Trueprint(isinstance(&#123;&#125;, Iterable)) // Trueprint(isinstance(&#x27;abc&#x27;, Iterable)) 生成器都是 Iterator 对象，但 list、dict、str 虽然是 Iterable，却不是 Iterator。 list、dict、str 等 Iterable 对象变成 Iterator对象 ，可以使用 iter() 函数 123isinstance(iter([]), Iterator) // Trueisinstance(iter(&#x27;abc&#x27;), Iterator) // True# 注意区分可迭代 和 迭代对象 iter() 你可能会问，为什么 list、dict、str 等数据类型不是 Iterator？ 这是因为 Python 的 Iterator 对象表示的是一个数据流，Iterator 对象可以被 next()函数调用并不断返回下一个数据，直到没有数据时抛出 StopIteration 错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过 next()函数实现按需计算下一个数据，所以 Iterator 的计算是惰性的，只有在需要返回下一个数据时它才会计算。 凡是可作用于 for 循环的对象都是 Iterable 类型； 凡是可作用于 next() 函数的对象都是 Iterator 类型，它们表示一个惰性计算的序列； 集合数据类型如 list、dict、str 等是 Iterable 但不是 Iterator，不过可以通过 iter()函数获得一个 Iterator 对象。 Python 的 for 循环本质上就是通过不断调用 next()函数实现的 123456789101112131415for x in [1, 2, 3, 4, 5]: pass# 等价于# 首先获得Iterator对象:it = iter([1, 2, 3, 4, 5])# 循环:while True: try: # 获得下一个值: x = next(it) except StopIteration: # 遇到StopIteration就退出循环 break 函数式编程我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元 而函数式编程（请注意多了一个“式”字）——Functional Programming，虽然也可以归结到面向过程的程序设计，但其思想更接近数学计算 对应到编程语言，就是越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如 C 语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如 Lisp 语言。 函数式编程就是一种抽象程度很高的编程范式, 函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！ Python 对函数式编程提供部分支持。由于 Python 允许使用变量，因此，Python 不是纯函数式编程语言。 纯函数: 相同的输入，就会得到相同的输出，对外部没有副作用的函数 高级函数变量可以指向函数abs(-10)是函数调用，而abs是函数本身; 函数本身也可以赋值给变量，即：变量可以指向函数。 12f = absprint(f(-200)) 函数名也是变量函数名其实就是指向函数的变量 12345&gt;&gt;&gt; abs = 10&gt;&gt;&gt; abs(-10)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: &#x27;int&#x27; object is not callable 注：由于 abs 函数实际上是定义在 import builtins 模块中的，所以要让修改 abs 变量的指向在其它模块也生效，要用 import builtins; builtins.abs &#x3D; 10。 传入函数可以接受函数作为参数的函数，称为高阶函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445def add(x, y, f): return f(x) + f(y)# map map(f, list)def f2(x): return x * x# 返回map对象 同js arr.mapr = map(f2, [1,2,3]) print(list(r), type(r))print(list(map(str, [1,2,3])))# reduce reduce(f, list)from functools import reducedef add(x, y): return x + yprint(reduce(add, [1,3,5,7]))# lamda 同js匿名函数from functools import reduceDIGITS = &#123;&#x27;0&#x27;: 0, &#x27;1&#x27;: 1, &#x27;2&#x27;: 2, &#x27;3&#x27;: 3, &#x27;4&#x27;: 4, &#x27;5&#x27;: 5, &#x27;6&#x27;: 6, &#x27;7&#x27;: 7, &#x27;8&#x27;: 8, &#x27;9&#x27;: 9&#125;def char2num(s): return DIGITS[s]def str2int(s): return reduce(lambda x, y: x * 10 + y, map(char2num, s))# filter filter(f, list)def is_odd(n): return n % 2 == 1# filter()函数返回的是一个Iterator，# 也就是一个惰性序列，所以要强迫filter()完成计算结果，# 需要用list()函数获得所有结果并返回listlist(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))# sorted sorted(list, keyFn)sorted([&#x27;bob&#x27;, &#x27;about&#x27;, &#x27;Zoo&#x27;, &#x27;Credit&#x27;], key=str.lower) # 升序sorted([&#x27;bob&#x27;, &#x27;about&#x27;, &#x27;Zoo&#x27;, &#x27;Credit&#x27;], key=str.lower, reverse=True) # 降序 函数作为返回值高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。 1234567def lazy_sum(*args): def sum(): ax = 0 for n in args: ax = ax + n return ax return sum 当 lazy_sum 返回函数 sum 时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力 闭包 当一个函数返回了一个函数后，其内部的局部变量还被返回的子函数引用 123456789101112def count(): fns = [] for i in range(1, 4): def f(): return i*i fns.append(f) return fnsf1, f2, f3 = count()f1() #9f2() #9f3() #9 匿名函数在 Python 中，对匿名函数提供了有限支持, 匿名函数有个限制，就是只能有一个表达式，不用写 return，返回值就是该表达式的结果 比 js 的匿名函数弱 123456list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))def build(x, y): return lambda: x * x + y * yf = lambda x: x * x 装饰器由于函数也是一个对象，而且函数对象可以被赋值给变量，所以，通过变量也能调用该函数; 函数对象有一个__name__属性，可以拿到函数的名字 1234567def now(): print(&#x27;2019-09-02&#x27;)f = nowf()print(now.__name__, f.__name__) # now now 不修改 now()函数的定义，又可以代码运行期间动态增加功能，称之为“装饰器”（Decorator）。 本质上，decorator 就是一个返回函数的高阶函数 1234567891011121314def log(func): def wrapper(*args, **kw): print(&#x27;call %s():&#x27; % func.__name__) return func(*args, **kw) return wrapper # 返回装饰了目标函数的函数# 借助Python的@语法，把decorator置于函数的定义处@logdef now2(): print(&#x27;2019-01-09&#x27;)# 调用now()函数，不仅会运行now()函数本身，# 还会在运行now()函数前打印一行日志now2() 把@log放到now()函数的定义处，相当于执行了语句 now=log(now) 12345678910111213141516171819202122232425# 可接受参数的装饰器def log(text): def decorator(func): def wrapper(*args, **kw): print(&#x27;%s %s():&#x27; % (text, func.__name__)) return func(*args, **kw) return wrapper return decorator# now = log(&#x27;execute&#x27;)(now)@log(&#x27;execute&#x27;) # 返回的结果作为装饰器def now(): print(&#x27;2019-11-12&#x27;)# 修正__name__的值import functoolsdef log(func): # wrapper.__name__ = func.__name__ @functools.wraps(func) def wrapper(*args, **kw): print(&#x27;call %s():&#x27; % func.__name__) return func(*args, **kw) return wrapper 在面向对象（OOP）的设计模式中，decorator 被称为装饰模式。OOP 的装饰模式需要通过继承和组合来实现，而 Python 除了能支持 OOP 的 decorator 外，直接从语法层次支持 decorator。Python 的 decorator 可以用函数实现，也可以用类实现。 decorator 可以增强函数的功能，定义起来虽然有点复杂，但使用起来非常灵活和方便。 偏函数在介绍函数参数的时候，我们讲到，通过设定参数的默认值，可以降低函数调用的难度。而偏函数也可以做到这一点 123456789101112131415161718# int(num, base)def int2(x, base=2): return int(x, base)# functools.partial就是帮助我们创建一个偏函数的，不需要我们自己定义int2()import functoolsint2 = functools.partial(int, base=2) # 返回预绑定末尾参数的函数# 固定了int()函数的关键字参数base# 相当于kw = &#123;&#x27;base&#x27;: 2&#125;init(&#x27;1001&#x27;, **kw)max2 = functools.partial(max, 10)# 实际上会把10作为*args的一部分自动加到左边max2(5,6)# args = (10, 5, 6) 当函数的参数个数太多，需要简化时，使用functools.partial可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。 模块为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在 Python 中，一个 `.py` 文件就称之为一个模块（Module）。 模块化有什么好处？ 最大的好处是大大提高了代码的可维护性。 其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括 Python 内置的模块和来自第三方的模块。 使用模块还可以避免命名冲突 (函数名和变量名)。 你也许还想到，如果不同的人编写的模块名相同怎么办？为了避免模块名冲突，Python 又引入了按目录来组织模块的方法，称为包（Package） 包作为模块的命名空间，避免模块名冲突 请注意，每一个包目录下面都会有一个__init__.py的文件，这个文件是必须存在的，否则，Python 就把这个目录当成普通目录，而不是一个包。__init__.py可以是空文件，也可以有 Python 代码，因为__init__.py本身就是一个模块 包也可以有多级结构，如mycompanry.web.util 使用模块Python 本身就内置了很多非常有用的模块 1234567891011121314151617181920#!/usr/bin/env python3# -*- coding: utf-8 -*-&#x27; a test module &#x27;__author__ = &#x27;Michael Liao&#x27;import sysdef test(): args = sys.argv if len(args)==1: print(&#x27;Hello, world!&#x27;) elif len(args)==2: print(&#x27;Hello, %s!&#x27; % args[1]) else: print(&#x27;Too many arguments!&#x27;)if __name__==&#x27;__main__&#x27;: test() 作用域在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，有的函数和变量我们希望仅仅在模块内部使用 (模块私有成员约定用`_`前缀标识)。 正常的函数和变量名是公开的（public），可以被直接引用，比如：abc，x123，PI 等； __author__，__name__等是特殊变量，如: __doc__可访问文档注释，自定义的变量一般不要用__xx__格式； 实际上模块内的所有东西都是可访问的，_私有前缀也只是习惯约定 1234567891011def _private_1(name): return &#x27;Hello, %s&#x27; % namedef _private_2(name): return &#x27;Hi, %s&#x27; % namedef greeting(name): if len(name) &gt; 3: return _private_1(name) else: return _private_2(name) 安装第三方模块在 Python 中，安装第三方模块，是通过包管理工具 pip 完成的。 pip install Pillow 更多内容","tags":["Python"],"categories":["Python"]},{"path":"/house/bh.html","content":"贷款计算 贷款计算 ${winWidth} 房子总价 首付比例 首付金额 贷款金额 贷款利率 贷款年限 贷款时间 月供金额 已还总金额 已还本金 已还利息 剩余待还总额 剩余待还本金 剩余待还利息 累计还款金额 累计支付利息 总计成本 当前时间 还清时间 提前还款金额 提前还款时间 提前还还清时间 提前还累计还款 提前还累计利息 提前还利息减少 提前还总计成本 房子现在市值 即使部分提前还款，也能节省不少利息，缩短还贷年限 可以在上面表单的 提前还款金额 和 提前还款时间 字段中，输入提前还款金额和时间，计算对比提前还款前后的利息和还款年限 例如: 在2025-06-01提前还款3万, 那么就可以减少36000元利息(表明: 这3万本金在2025-06后产生的利息是36000元), 缩短还款年2年3个月 例如: 在2025-06-01提前还款10万, 那么就可以减少100884元利息(表明: 这10万本金在2025-06后产生的利息是100884元), 缩短还款年6年9个月 在房子价格下行的趋势下，如果一直供完，损失比较大 如果房子现在市值已经低于贷款剩余本金时，一直供下去，只会损失更大; 相当于支付剩余待还本金+剩余待还利息，共 ${house.remainPayBenjin * 1 + house.remainPayLixi * 1} 元, 去购买一个只值 ${baseInfo.nowHouseAmount} 的房子 如果一直供完，从上面表单可看到总成本为 ${house.totalCost} 元, 去购买一个只值 ${baseInfo.nowHouseAmount} 的房子(供完时，房子价值应该会更低), 损失金额为 ${house.totalCost - baseInfo.nowHouseAmount} 元 如果断供放弃房子，相对而言它的损失轻很多 房子的价值已经比剩余贷款本金还低，选择断供也是很常见的做法。此时的损失为: 首付(${baseInfo.firstPayMoney})+已还总金额(${house.hasPayAmount}) = ${baseInfo.firstPayMoney + house.hasPayAmount} 元; 相比一直供完，少损失 ${(house.totalCost - baseInfo.nowHouseAmount - (baseInfo.firstPayMoney + house.hasPayAmount)).toFixed(2)} 元. (剩余待还本金 ${house.remainPayBenjin} - 房子现在市值 ${baseInfo.nowHouseAmount} = ${(house.remainPayBenjin - baseInfo.nowHouseAmount).toFixed(2)} 元是否需要补交不确定?) 如果提前全部还款，那么损失和断供差不多 尝试在 提前还款金额 输入剩余待还本金 416315 元，此时总成本为首付+提前还累计还款 = 810960.51 元，得到价值 ${baseInfo.nowHouseAmount} 的房子, 共损失为 ${810960.51 - baseInfo.nowHouseAmount} 元 期数 日期 月供金额 还款本金 还款利息 年还利息 剩余本金 还款本金(提前还) 还款利息(提前还) 年还利息(提前还) 剩余本金(提前还) 22 2017年12月 2446 793 1653 20010 495146 118 2025年12月 2446 1092 1355 16492 405285 1134 1313 16120 (年省:372, 累计省:372) 392694 期数 日期 月供金额 还款本金 还款利息 年还利息 剩余本金 还款本金(提前还) 还款利息(提前还) 年还利息(提前还) 剩余本金(提前还) ${index + 1} ${item.date} ${item.monthlyPay} ${item.monthlyBenjin} ${item.monthlyInterest} ${item.yearInterest || ''} ${item.remainBenjin} ${house.aheadMonthlyData[index]?.monthlyBenjin} ${house.aheadMonthlyData[index]?.monthlyInterest} ${house.aheadMonthlyData[index]?.yearInterest || ''} ${' (年省:'+ house.aheadMonthlyData[index]?.yearSaveInterest +', 累计省:'+ house.aheadMonthlyData[index]?.totalSaveInterest +')'} ${house.aheadMonthlyData[index]?.remainBenjin} 0 ${' (年省:'+ item.yearInterest +', 累计省:'+ (lastTotalSaveInterest * 1 + extraYearSaves[index] *1) +')'} &gt; &lt;"},{"path":"/house/nj.html","content":"贷款计算 贷款计算 ${winWidth} 房子总价 首付比例 首付金额 贷款金额 贷款利率 贷款年限 贷款时间 月供金额 已还总金额 已还本金 已还利息 剩余待还总额 剩余待还本金 剩余待还利息 累计还款金额 累计支付利息 总计成本 当前时间 还清时间 提前还款金额 提前还款时间 提前还还清时间 提前还累计还款 提前还累计利息 提前还利息减少 提前还总计成本 房子现在市值 由于贷款金额比较高，部分提前还款，能显著减轻负担 可以在上面表单的 提前还款金额 和 提前还款时间 字段中，输入提前还款金额和时间，计算对比提前还款前后的利息和还款年限 例如: 在2025-04-01提前还款3万, 那么就可以减少80425元利息(表明: 这3万本金在2025-06后产生的利息是80425元), 缩短还款年1年7个月 例如: 在2025-04-01提前还款10万, 那么就可以减少239357元利息(表明: 这10万本金在2025-06后产生的利息是239357元), 缩短还款年5年 例如: 在2025-04-01提前还款55万, 那么就可以减少748392.88元利息(表明: 这10万本金在2025-06后产生的利息是748392.88元), 缩短还款年18年8个月，还清时间为 2034-06 部分提前还款减少的利息支出远高于房租收入 提前还款50万能减少利息718335.04元，租房每月1500元来算，一年租金 ${1500 * 12} 元, 需要租 ${(718335.04 / 1500 / 12).toFixed(0)} 年才能得到同等的价值，显然提前还款更划算。 房价总体下行，若干年后再考虑卖房提前还贷，减负的效果差很多 现在贷款剩余本金较多，年利息基本5万左右，有可能的话，现在提前还款是最有效降低利息成本的 还完后，若有多余积蓄，还可以到baohua购置个养老房 2034-06年还完贷款后，若有积蓄，可以到baohua购置个养老的房子，这个时间点估计30w左右都可以买到了吧? 给未来增加点确定性，心会更安稳一点，也能够对透支健康的工作说不吧 期数 日期 月供金额 还款本金 还款利息 年还利息 剩余本金 还款本金(提前还) 还款利息(提前还) 年还利息(提前还) 剩余本金(提前还) 22 2017年12月 2446 793 1653 20010 495146 118 2025年12月 2446 1092 1355 16492 405285 1134 1313 16120 (年省:372, 累计省:372) 392694 期数 日期 月供金额 还款本金 还款利息 年还利息 剩余本金 还款本金(提前还) 还款利息(提前还) 年还利息(提前还) 剩余本金(提前还) ${index + 1} ${item.date} ${item.monthlyPay} ${item.monthlyBenjin} ${item.monthlyInterest} ${item.yearInterest || ''} ${item.remainBenjin} ${house.aheadMonthlyData[index]?.monthlyBenjin} ${house.aheadMonthlyData[index]?.monthlyInterest} ${house.aheadMonthlyData[index]?.yearInterest || ''} ${' (年省:'+ house.aheadMonthlyData[index]?.yearSaveInterest +', 累计省:'+ house.aheadMonthlyData[index]?.totalSaveInterest +')'} ${house.aheadMonthlyData[index]?.remainBenjin} 0 ${' (年省:'+ item.yearInterest +', 累计省:'+ (lastTotalSaveInterest * 1 + extraYearSaves[index] *1) +')'} &gt; &lt;"},{"path":"/house/main.js","content":"document.title = \"房贷计算器\"; /* 根据还款年限，计算月供金额 */ function getMonthlyPayment(loanAmount, interestRate, loanTerm) { const monthlyRate = interestRate / 12; const totalPayments = loanTerm * 12; return ( (loanAmount * monthlyRate) / (1 - Math.pow(1 + monthlyRate, -totalPayments)) ); } function throttle(fn, delayMs) { let lastTime = 0; let timer = null return function thrFn() { const now = Date.now(); if (timer) clearTimeout(timer); if (now - lastTime < delayMs) { timer = setTimeout(thrFn, delayMs + 50); return; } lastTime = now; fn.apply(this, arguments); }; } function toFixed(num, decimal = 0) { return num.toFixed(decimal) * 1; } function mapValues(obj, keys, fn) { return Object.keys(obj).reduce((acc, key) => { acc[key] = keys.includes(key) ? fn(obj[key], key, obj) : obj[key]; return acc; }, {}); } // 添加日期字段 const getDate = (date, isDash = false) => { const d = new Date(date); return isDash ? `${d.getFullYear()}-${fillZero(d.getMonth() + 1)}` : `${d.getFullYear()}年${fillZero(d.getMonth() + 1)}月`; }; // 中文时间转为数字时间 const cnTimeToDashTime = (date) => { return date.replace(/\\D/g, \"-\").replace(/-\\D*$/, \"\"); }; function fillZero(num) { return num < 10 ? \"0\" + num : num; } const getLast = (list) => { return list[list.length - 1]; }; const getYearMonth = (dateStr) => { const date = new Date(dateStr); return date.getFullYear() + \"-\" + fillZero(date.getMonth() + 1); }; const getSum = (list, key) => { return toFixed(list.reduce((acc, item) => acc + item[key], 0)) }; function getCurTime() { const today = new Date(); today.setDate(1); const year = today.getFullYear(); const month = today.getMonth() + 1; const date = today.getDate(); return `${year}-${fillZero(month)}-${fillZero(date)}`; } /** * 根据借款基础信息，计算月供等数据 */ function getMonthlyDetail({ firstPayMoney, // 首付 loanMoney, loanRate, loanYears, startTime, curTime, aheadPayTime, aheadPayMoney, }) { const monthlyRate = loanRate / 12; const totalMonths = loanYears * 12; let monthlyData = []; let remainBenjin = loanMoney; let monthlyPay = 15000; const getMonthlyInfo = () => { while (remainBenjin > 0) { // debugger; const monthlyInterest = remainBenjin * monthlyRate; const monthlyBenjin = monthlyPay - monthlyInterest; remainBenjin -= monthlyBenjin; monthlyData.push({ sn: monthlyData.length + 1, remainBenjin, monthlyBenjin, monthlyInterest, monthlyPay, }); } }; const smallLs = []; const bigLs = []; while (monthlyData.length != totalMonths) { const actualTotalMonths = monthlyData.length; const isSmall = actualTotalMonths > totalMonths; const ls = isSmall ? smallLs : bigLs; ls.push(monthlyPay); let delta = 1; if (isSmall) { const lastBig = bigLs[bigLs.length - 1]; delta = lastBig ? (lastBig - monthlyPay) * 0.5 : monthlyPay * 0.5; } else { const lastSmall = smallLs[smallLs.length - 1]; delta = lastSmall ? (lastSmall - monthlyPay) * 0.5 : (0 - monthlyPay) * 0.5; } // const delta = actualTotalMonths > totalMonths ? 1 : -1; monthlyData = []; remainBenjin = loanMoney; monthlyPay = monthlyPay + delta; const minMonthlyPay = remainBenjin * monthlyRate; if (monthlyPay < minMonthlyPay) { monthlyPay = minMonthlyPay + 100; } console.log(\"🚀 ~ getMonthlyDetail ~ monthlyPay:\", monthlyPay); console.time(\"mm\"); getMonthlyInfo(); console.timeEnd(\"mm\"); } let yearStartIndex = 0 monthlyData.forEach((item, index) => { const itemDate = new Date(startTime); itemDate.setMonth(itemDate.getMonth() + index); const nextItemDate = new Date(startTime); nextItemDate.setMonth(nextItemDate.getMonth() + index + 1); if (itemDate.getFullYear() !== nextItemDate.getFullYear()) { yearEndIndex = index; const yearData = monthlyData.slice(yearStartIndex, yearEndIndex + 1); const yearInterest = getSum(yearData, \"monthlyInterest\"); item.yearInterest = yearInterest; yearStartIndex = index + 1; } const date = getDate(itemDate); const curDate = new Date(curTime); const aheadDate = new Date(aheadPayTime); if (curDate > itemDate) { item.isBefore = true; } else { if (getYearMonth(curDate) === getYearMonth(itemDate)) { item.isCur = true; } if (getYearMonth(aheadDate) === getYearMonth(itemDate)) { item.isAhead = true; } item.isAfter = true; } item.date = date; }); const addMonth = (date, n) => { const d = new Date(date); d.setMonth(d.getMonth() + n); return d; }; // 如有提前还款，则重新计算后续还款的明细 let aheadMonthlyData = []; if (aheadPayMoney) { aheadMonthlyData = monthlyData.slice(); const aheadIndex = aheadMonthlyData.findIndex((item) => { aheadDate = getDate(aheadPayTime); return item.date === aheadDate }); aheadMonthlyData.splice(aheadIndex); let remainBenjin = aheadMonthlyData[aheadMonthlyData.length - 1].remainBenjin - aheadPayMoney; let i = 0; while (remainBenjin > 0) { const monthlyInterest = remainBenjin * monthlyRate; const monthlyBenjin = monthlyPay - monthlyInterest; remainBenjin -= monthlyBenjin; aheadMonthlyData.push({ sn: aheadIndex + i + 1, isAfter: true, date: getDate(addMonth(aheadPayTime, i)), monthlyBenjin, monthlyInterest, remainBenjin, monthlyPay, }); i = i + 1; } } // add yearInterest if (aheadMonthlyData.length > 0) { let aheadYearStartIdx = 0; const yearSaveInterestList = []; aheadMonthlyData.forEach((item, index) => { const time = cnTimeToDashTime(item.date) const itemDate = new Date(time); const month = itemDate.getMonth() + 1; if (month === 12) { const aheadYearEndIdx = index; const yearData = aheadMonthlyData.slice(aheadYearStartIdx, aheadYearEndIdx + 1); const yearInterest = getSum(yearData, \"monthlyInterest\"); item.yearInterest = yearInterest; const yearSaveInterest = toFixed(monthlyData[index].yearInterest - yearInterest || 0); item.yearSaveInterest = yearSaveInterest; yearSaveInterestList.push(yearSaveInterest); item.totalSaveInterest = toFixed(yearSaveInterestList.reduce((a, b) => a + b, 0)); aheadYearStartIdx = index + 1; } }) } const beforeData = monthlyData.filter((item) => item.isBefore); const afterData = monthlyData.filter((item) => item.isAfter); const hasPayLixi = getSum(beforeData, \"monthlyInterest\"); const hasPayBenjin = getSum(beforeData, \"monthlyBenjin\"); const hasPayAmount = hasPayBenjin + hasPayLixi; const remainPayBenjin = getSum(afterData, \"monthlyBenjin\"); const remainPayLixi = getSum(afterData, \"monthlyInterest\"); const remainPayAmount = toFixed(remainPayBenjin + remainPayLixi); const sumPayAmount = toFixed(hasPayAmount + remainPayAmount) const sumPayLixi = toFixed(hasPayLixi + remainPayLixi); const totalCost = toFixed(sumPayAmount + firstPayMoney); const endTime = cnTimeToDashTime(getLast(monthlyData).date); // 贷款结束时间 const aheadEndTime = !aheadMonthlyData.length ? endTime : cnTimeToDashTime(getLast(aheadMonthlyData).date); // 提前还贷款结束时间 const aheadSumPayAmount = !aheadMonthlyData.length ? sumPayAmount : getSum(aheadMonthlyData, \"monthlyPay\") + aheadPayMoney * 1; const aheadSumPayLixi = !aheadMonthlyData.length ? sumPayLixi : getSum(aheadMonthlyData, \"monthlyInterest\"); const aheadTotalCost = !aheadMonthlyData.length ? totalCost : toFixed(aheadSumPayAmount + firstPayMoney); const monthPayMoney = toFixed(monthlyPay); monthlyData = monthlyData.map((item) => mapValues( item, [\"monthlyInterest\", \"monthlyPay\", \"remainBenjin\", \"monthlyBenjin\", \"yearInterest\"], (value) => toFixed(value) ) ); aheadMonthlyData = aheadMonthlyData.map((item) => mapValues( item, [\"monthlyInterest\", \"monthlyPay\", \"remainBenjin\", \"monthlyBenjin\", \"yearInterest\"], (value) => toFixed(value) ) ); console.table(monthlyData); console.table(aheadMonthlyData); return { monthlyData, aheadMonthlyData, monthPayMoney, endTime, aheadEndTime, hasPayLixi, hasPayAmount, hasPayBenjin, remainPayAmount, remainPayBenjin, remainPayLixi, sumPayAmount, sumPayLixi, aheadSumPayAmount, aheadSumPayLixi, totalCost, aheadTotalCost, }; } window.myapp = new Vue({ el: \"#houseApp\", delimiters: [\"${\", \"}\"], data() { const bhInfo = { nowHouseAmount: 350000, firstPayRate: 0.2, firstPayMoney: 128000, loanRate: 0.04, loanYears: 30, aheadPayMoney: 0, aheadPayTime: getCurTime(), startTime: \"2016-03-01\", }; const njInfo = { nowHouseAmount: 1350000, firstPayRate: 0.25, firstPayMoney: 375000, loanRate: 0.048, loanYears: 30, aheadPayMoney: 0, aheadPayTime: getCurTime(), startTime: \"2023-04-01\", }; const winWidth = window.innerWidth; return location.pathname.endsWith(\"bh.html\") ? { baseInfo: bhInfo, winWidth, scrollLeft: 0 , headerTableHeight: 69} : { baseInfo: njInfo, winWidth, scrollLeft: 0 , headerTableHeight: 69}; }, computed: { house() { return this.getData(this.baseInfo); }, hasAheadPay() { return this.house.aheadMonthlyData.length > 0; }, lastTotalSaveInterest() { if (!this.hasAheadPay) { return 0; } const lastYearItem = this.house.aheadMonthlyData .filter((it) => it.totalSaveInterest) .pop(); return lastYearItem?.totalSaveInterest || 0; }, extraYearSaves() { if (!this.hasAheadPay) { return {}; } const { aheadMonthlyData, monthlyData } = this.house; const extraYearLs = []; monthlyData.forEach((it, index) => { if (index < aheadMonthlyData.length) return false; if (it.yearInterest) { extraYearLs.push([index, it.yearInterest]); } }); const extraYearSumLs = extraYearLs.map(([index, yearInterest], j) => { const sumInterest = extraYearLs .slice(0, j + 1) .reduce((sum, [index, yearInterest]) => sum + yearInterest, 0); return [index, sumInterest]; }); const extraYearSumMap = Object.fromEntries(extraYearSumLs); return extraYearSumMap; }, }, methods: { goTop() { window.scrollTo({ top: 0, behavior: \"smooth\" }); }, goBottom() { window.scrollTo({ top: 100000, behavior: \"smooth\" }); }, getData: ({ firstPayRate, firstPayMoney, loanRate, loanYears, aheadPayMoney, startTime, aheadPayTime, }) => { const houseAmount = toFixed(firstPayMoney / firstPayRate); const loanMoney = toFixed(houseAmount - firstPayMoney); const curTime = getCurTime(); if (!aheadPayTime) { aheadPayTime = curTime; // 如果没有提前还款时间，则默认为当前时间 } const detail = getMonthlyDetail({ firstPayMoney, loanMoney, loanRate, loanYears, startTime, curTime, aheadPayTime, aheadPayMoney, }); return { firstPayRate, firstPayMoney, loanRate, loanYears, aheadPayMoney, startTime, houseAmount, loanMoney, curTime, aheadPayTime, ...detail, }; }, changeCurrentUser() { LCache.set(\"curUser\", this.currentUser); showToast(`修改成功，当前用户是 ${this.currentUser || \"默认用户\"}`); }, }, mounted() { const loanTableDiv = this.$refs.loanTable; const onlyHeaderTable = this.$refs.onlyHeaderTable; if (onlyHeaderTable) { const headerTableHeight = onlyHeaderTable.offsetHeight; this.headerTableHeight = headerTableHeight; const observer = new ResizeObserver(() => { const headerTableHeight = onlyHeaderTable.offsetHeight; console.log(\"🚀 ~ observer ~ headerTableHeight:\", headerTableHeight) this.headerTableHeight = headerTableHeight; }); observer.observe(onlyHeaderTable); } const callback = throttle(() => { const scrollLeft = loanTableDiv.scrollLeft; if (scrollLeft !== this.scrollLeft) { this.scrollLeft = scrollLeft; } }, 100); if (loanTableDiv) { loanTableDiv.addEventListener(\"scroll\", callback); } }, }); console.log('myapp data::', window.myapp.$data)"},{"title":"react","path":"/react/index.html","content":"react introducea very popular lib for building ui"},{"path":"/house/style.css","content":"/* hide other sections */ aside.l_left, .l_main > .banner, .l_right, .float-panel, .page-footer, .l_main #comments { display: none !important; } .l_body { display: block !important; overflow-x: hidden; } /* --------------------------------- */ body { overflow-x: hidden; } .flex { display: flex; padding: 3px 0; } .fixed-right { position: fixed; z-index: 10000; top: 0px; right: 20px; opacity: 0.6; padding: 5px; background: #fff; border-radius: 4px; } .flex-row { display: flex; flex-direction: row; flex-wrap: wrap; gap: 30px; } .hotpink { color: hotpink; } .blue { color: blue; } .ta-c { text-align: center; } .lh-2 { line-height: 2; } input { border: 1px solid #ccc; padding: 6px; border-radius: 3px; font-size: 16px; } input[readonly] { background: #eee; } .label { width: 150px; text-align: right; margin-right: 10px; } .mt-10 { margin-top: 10px; } .mt-15 { margin-top: 15px; } .mt-20 { margin-top: 20px; } .label::after { content: \": \"; } .month-table { table-layout: auto; border-collapse: collapse; text-align: center; width: 100%; /* min-width: 600px; */ } .month-table.has-ahead { width: 1500px; } #loanTable { width: 100%; overflow: auto; height: 1000px; } #loanForm .value select { width: 208px; padding: 6px; } .md-text.content { overflow: visible !important; } .month-table td, .month-table th { border: 1px solid #ccc; } .month-table th { padding: 5px; } .month-table thead tr { background: #eee; visibility: hidden; } .month-table.only-header{ margin-bottom: -69px; position: sticky; top: 0; } .month-table.only-header thead tr { visibility: visible; } .month-table.only-header tbody { visibility: hidden; } .month-table.only-header td { border: none; } .green { color: green; } .month-table tr.active { background: yellow; } .month-table tr.ahead { background: skyblue; } .month-table td:nth-child(10), .month-table td:nth-child(6) { color: hotpink; } .month-table td:nth-child(8), .month-table td:nth-child(9), .month-table td:nth-child(10), .month-table td:nth-child(11) { /* background: #d2f3d2; */ background: #e5f5e5; } .month-table tr.last-month { background: #eee; } #houseApp .advise-list { margin-top: 50px; margin-bottom: 100px; padding: 30px; background: #eee; line-height: 2; font-size: 16px; } .gotop-btn, .gobtm-btn { position: fixed; bottom: 70px; right: 10px; border: 0; border-radius: 50%; width: 40px; height: 40px; line-height: 40px; background: #ccc; color: #fff; transform: rotate(-90deg); font-family: serif; font-size: 30px; } .gobtm-btn { bottom: 20px; } .gotop-btn:hover, .gobtm-btn:hover { background: #ddd; } .advise-ttl { font-size: 20px; line-height: 1.5; } .tag { border: 1px solid #ccc; background: #fff; color: black; margin: 0 5px; padding: 3px 5px; border-radius: 3px;; } .advise-list i { color: #666; } /* ---------------- media query ----------------- */ @media screen and (max-width: 640px){ .label { width: 110px; font-size: 14px; } input { width: 130px; } } @media screen and (max-width: 480px){ .month-table td { font-size: 12px; } .md-text.content { padding: 0; } }"},{"path":"/study/admin-tags.html","content":"当前用户: ${ currentUser || '默认用户' } 标签列表 序号 标签 状态 日期 操作 ${ index + 1 } ${ item.name } ${ item.status === 'enable' ? '启用' : '禁用' } ${ item.date } ${ item.status === 'enable' ? '禁用' : '启用' } 删除 添加 全部删除 const currentUser = getCurUser(); new Vue({ el: \"#app\", delimiters: [\"${\", \"}\"], data: { currentUser, newTag: \"\", tagList: getCache(\"tags\") || [], }, methods: { updateCache(data) { if (!data) { data = this.tagList; } setCache(\"tags\", data); }, addTag() { if (this.newTag.trim()) { const tagName = this.newTag.trim(); const exists = this.tagList.find( (tag) => tag.name === tagName ); if (exists) { showToast(\"该标签已存在\"); return; } const today = getTodayStr(); this.tagList.push({ date: today, name: tagName, status: \"enable\", }); this.newTag = \"\"; this.updateCache(); } }, rmTag(index) { this.tagList.splice(index, 1); this.updateCache(); }, rmAllTags() { this.tagList = []; this.updateCache(); }, toggleStatus(tag) { tag.status = tag.status === \"enable\" ? \"disable\" : \"enable\"; this.updateCache(); }, }, });"},{"path":"/study/admin-users.html","content":"用户管理 序号 用户 状态 日期 操作 ${ index + 1 } ${ item.name } ${ item.status === 'enable' ? '启用' : '禁用' } ${ item.date } 应用默认字库 应用默认词语库 ${ item.status === 'enable' ? '禁用' : '启用' } 删除 添加 全部删除 new Vue({ el: \"#app\", delimiters: [\"${\", \"}\"], data: { newUser: \"\", userList: LCache.get(\"users\") || [], }, methods: { updateCache(data) { if (!data) { data = this.userList; } LCache.set(\"users\", data); }, applyDefaultCharacterData(user) { const defKey = \"words\"; const userKey = `${user.name}:${defKey}`; const oldData = LCache.get(userKey); if (oldData) { const isOverwrite = confirm( `确认要覆盖 ${user.name} 的现有字库?` ); if (!isOverwrite) return; } const data = LCache.get(defKey) || []; LCache.set(userKey, data); showToast(\"字库已更新成功!\"); }, applyDefaultWordData(user) { const defKey = \"mwords\"; const userKey = `${user.name}:${defKey}`; const oldData = LCache.get(userKey); if (oldData) { const isOverwrite = confirm( `确认要覆盖 ${user.name} 的现有词语库?` ); if (!isOverwrite) return; } const data = LCache.get(defKey) || []; LCache.set(userKey, data); showToast(\"词语库已更新成功!\"); }, addUser() { if (this.newUser.trim()) { const userName = this.newUser.trim(); const exists = this.userList.find( (user) => user.name === userName ); if (exists) { showToast(\"该用户已存在\"); return; } const today = getTodayStr(); this.userList.push({ date: today, name: userName, status: \"enable\", }); this.newUser = \"\"; this.updateCache(); } }, rmUser(index) { this.userList.splice(index, 1); this.updateCache(); }, rmAllUsers() { this.userList = []; this.updateCache(); }, toggleStatus(user) { user.status = user.status === \"enable\" ? \"disable\" : \"enable\"; if (user.status === 'disable' && LCache.get('curUser') === user.name) { LCache.set('curUser', ''); } this.updateCache(); }, }, });"},{"path":"/study/admin-multiple.html","content":"词语库管理 搜索 批量删除 序号 词语 标题 标签 学会 状态 日期 操作 ${ index + 1 } ${ item.word } ${ item.title } ${ (item.tags ?? []).join(', ') } ${ item.isKnow ? '是' : '否' } ${ item.status === 'enable' ? '启用' : '禁用' } ${ item.date } ${ item.status === 'enable' ? '禁用' : '启用' } 删除 标题: 词语: 添加 全部删除 清除全部标签 可上传字/词文件, 每行1个字/词, 空白行或//开头的注释行将被忽略，##开头的为标题行 上传 &gt; &gt; new Vue({ el: \"#app\", delimiters: [\"${\", \"}\"], data: { kw: '', keyword: '', newTitle: \"初级词语\", newWord: \"\", upfile: \"\", wordList: getCache(\"mwords\") || [], }, computed: { displayWordList() { if (!this.keyword) return this.wordList; return this.wordList.filter(item => item.title.includes(this.keyword) || item.word.includes(this.keyword)); } }, methods: { goTop() { window.scrollTo({top: 0, behavior: \"smooth\"}) }, goBottom() { const maxScroll = document.documentElement.scrollHeight - window.innerHeight; window.scrollTo({top: maxScroll, behavior: \"smooth\"}); }, handleSearch() { this.keyword = this.kw; }, updateCache(data) { if (!data) { data = this.wordList; } setCache(\"mwords\", data); }, uploadCallback(text) { const lines = text.split(\" \").map((line) => line.trim()); let title = \"\"; let lesson = '' const date = getTodayStr(); const upwords = []; for (let line of lines) { line = line.trim(); // skip empty line if (!line) { continue; } // starts with ## , is title line if (line.startsWith(\"##\")) { title = line.replace(/^##/, \"\").trim(); continue; } // starts with #Lesson is lesson title line if (/^#Lesson/i.test(line)) { lesson = line.replace(/^#Lesson/i, \"\").trim(); continue; } // others starts with # are comment lines if (/^#(?!#)/.test(line) || !line) continue; const [upword, desc = ''] = line.split(/(? { const text = event.target.result; this.uploadCallback(text); }); fileReader.readAsText(file); }, addWord() { if (this.newWord.trim()) { const word = this.newWord.trim(); const exists = this.wordList.find( (item) => item.word === word ); if (exists) { showToast(\"该词语已存在\"); return; } const today = getTodayStr(); this.wordList.push({ date: today, word, title: this.newTitle, status: \"enable\", tags: [], isKnow: false, }); this.newWord = \"\"; this.updateCache(); } }, rmWord(index) { const curWord = this.displayWordList[index] // this.wordList.splice(index, 1); this.wordList = this.wordList.filter(word => { return word.word != curWord.word }) this.updateCache(); }, rmAllWords() { this.wordList = []; this.updateCache(); }, rmDisplayWords() { this.wordList = this.wordList.filter((word) => { const matched = this.displayWordList.find(viewWord => { return viewWord.word === word.word && viewWord.title === word.title; }) return !matched }); this.updateCache(); }, rmAllTags() { this.wordList = this.wordList.map((item) => { item.tags = []; return item; }); this.updateCache(); }, toggleStatus(item) { item.status = item.status === \"enable\" ? \"disable\" : \"enable\"; this.updateCache(); }, }, });"},{"path":"/study/home.html","content":"home hello kk"},{"path":"/study/index.html","content":"轻舟学伴 切换用户: 默认用户 ${user.name} 切换用户 管理用户 支持多用户, 每个用户有自己的字库、词语库和标签, 默认模式为单用户, 默认模式下用户名称为空 管理当前用户标签 每个用户可为字/词设置标签，并使用标签进行过滤 管理文字 单字练习 单字默写 管理词语 词语练习 词语默写 new Vue({ el: '#app', delimiters: ['${', '}'], data: { isMobile: getIsMobile(), currentUser: getCurUser(), userList: (LCache.get('users') || []).filter(user => user.status !== 'disable') }, methods: { changeCurrentUser() { LCache.set('curUser', this.currentUser); showToast(`修改成功，当前用户是 ${this.currentUser || '默认用户'}`) }, } });"},{"path":"/study/admin-single.html","content":"当前用户: ${ currentUser || '默认用户' } 字库管理 搜索 批量删除 序号 字 标题 标签 学会 状态 日期 操作 ${ index + 1 } ${ item.word } ${ item.title || '' } ${ (item.tags ?? []).join(', ') } ${ item.isKnow ? '是' : '否' } ${ item.status === 'enable' ? '启用' : '禁用' } ${ item.date } ${ item.status === 'enable' ? '禁用' : '启用' } 删除 标题: 字: 添加 全部删除 清除全部标签 可上传字/词文件, 每行1个字/词, 空白行或//开头的注释行将被忽略，##开头的为标题行 上传 new Vue({ el: \"#app\", delimiters: [\"${\", \"}\"], data: { kw: '', keyword: '', currentUser: getCurUser(), newTitle: \"学前生字\", newWord: \"\", upfile: \"\", wordList: getCache(\"words\") || [], }, computed: { displayWordList() { if (!this.keyword) return this.wordList; return this.wordList.filter((item) => item.title.includes(this.keyword) || item.word.includes(this.keyword) ); } }, methods: { handleSearch() { this.keyword = this.kw; }, updateCache(data) { if (!data) { data = this.wordList; } setCache(\"words\", data); }, uploadCallback(text) { const lines = text.split(\" \").map((line) => line.trim()); let title = \"\"; let lesson = '' const date = getTodayStr(); const upwords = []; for (let line of lines) { line = line.trim(); // skip empty line if (!line) { continue; } // starts with ## , is title line if (line.startsWith(\"##\")) { title = line.replace(/^##/, \"\").trim(); continue; } // starts with #Lesson is lesson title line if (/^#Lesson/i.test(line)) { lesson = line.replace(/^#Lesson/i, \"\").trim(); continue; } // others starts with # are comment lines if (/^#(?!#)/.test(line) || !line) continue; const [upword, desc = ''] = line.split(/(? { const text = event.target.result; this.uploadCallback(text); }); fileReader.readAsText(file); }, addWord() { if (this.newWord.trim()) { const word = this.newWord.trim()[0]; const exists = this.wordList.find( (item) => item.word === word ); if (exists) { showToast(\"该文字已存在\"); return; } const today = getTodayStr(); this.wordList.push({ date: today, word, title: this.newTitle, status: \"enable\", tags: [], isKnow: false, }); this.newWord = \"\"; this.updateCache(); } }, rmWord(index) { const curWord = this.displayWordList[index] // this.wordList.splice(index, 1); this.wordList = this.wordList.filter(word => { return word.word != curWord.word }) this.updateCache(); }, rmDisplayWords() { this.wordList = this.wordList.filter((word) => { const matched = this.displayWordList.find(viewWord => { return viewWord.word === word.word && viewWord.title === word.title; }) return !matched }); this.updateCache(); }, rmAllWords() { this.wordList = []; this.updateCache(); }, rmAllTags() { this.wordList = this.wordList.map((item) => { item.tags = []; return item; }); this.updateCache(); }, toggleStatus(item) { item.status = item.status === \"enable\" ? \"disable\" : \"enable\"; this.updateCache(); }, }, });"},{"title":"小学堂","path":"/study/index.html","content":"切换用户: 默认用户 ${user.name} 切换用户 管理用户 支持多用户, 每个用户有自己的字库、词语库和标签, 默认模式为单用户, 默认模式下用户名称为空 管理当前用户标签 每个用户可为字/词设置标签，并使用标签进行过滤 管理文字 单字练习 单字默写 管理词语 词语练习 词语默写 new Vue({ el: '#app', delimiters: ['${', '}'], data: { isMobile: getIsMobile(), currentUser: getCurUser(), userList: (LCache.get('users') || []).filter(user => user.status !== 'disable') }, methods: { changeCurrentUser() { LCache.set('curUser', this.currentUser); showToast(`修改成功，当前用户是 ${this.currentUser || '默认用户'}`) }, } });","tags":[null]},{"path":"/study/multiple.html","content":"用户: ${ currentUser || '默认用户' } ${activeIndex + 1} / ${wordList.length} 词语认读 &gt; 选择字体: 字体1 字体2 字体3 字体4 字体5 筛选: 标题: 全部 ${ttl} 标签: ${ selTag.text } ${tagOpt.text} 取反 掌握: 全部 已掌握 未掌握 随机: 设置掌握: 已掌握 未掌握 设置标签: 创建标签 ${ tag.name } ${ wordList } ${ activeWord } &lt; &gt; ${ wordList[activeIndex]?.lesson ? wordList[activeIndex].lesson.includes('》') ? wordList[activeIndex].lesson : '《' + wordList[activeIndex].lesson + '》' : ''} ${chr} ${ wordList[activeIndex].explain || '' } ${activeIndex + 1} / ${wordList.length} const searchParams = new URLSearchParams(location.search); const isTest = ![null, \"0\", \"false\"].includes(searchParams.get(\"test\")); const primaryWords = priorityWords; const tagTable = getCache(\"tags\", true) || []; const sortedTagList = getSortedTagList(tagTable, true); const selectedTagList = getCache(\"mwordTagLs\") || [getAllOptionOfTag()]; const tagOptions = getTagOptions(tagTable); updateSelectedForTags(tagOptions, selectedTagList); window.myapp = new Vue({ el: \"#app\", delimiters: [\"${\", \"}\"], data: { isCloseCtrl: false, primaryWords, tagSelectOpen: false, title: getCache(\"mwordTitle\") || \"\", // tag: getCache('mwordTagLs') || '', selTagLs: selectedTagList, know: getCache(\"mwordKnow\") || \"\", currentUser: getCurUser(), activeIndex: 0, isNext: true, isMobile: getIsMobile(), isRandom: false, fontType: isTest ? 5 : getCache(\"mfontType\") || 5, cacheWordList: getCache(\"mwords\", true) || [], tagList: sortedTagList, tagOptions: tagOptions, orderedWordList: [], isViewAnswer: false, isTestMode: isTest, }, computed: { fontStyle: function () { // word: {date, word} const word = this.wordList[this.activeIndex]; if (!word) { return { fontSize: \"250px\" }; } const sizeMap = { 1: 330, 2: 330, 3: 330, 4: 250, 5: 200, 6: 160, 7: 130, }; const mobileSizeMap = { 1: 180, 2: 120, 3: 90, 4: 120, 5: 60, 6: 90, 7: 90, }; const map = this.isMobile ? mobileSizeMap : sizeMap; const size = map[word.word.length] || 50; return { fontSize: size + \"px\" }; }, total() { return this.wordList.length; }, titleList() { return [ ...new Set( this.cacheWordList.map((item) => item.title).filter((v) => !!v) ), ]; }, wordList() { // if (!this.isConditionChanged) return this.displayingWordList; console.log(\"computed wordList start------------>\"); let viewWordList = this.sourceWordList.filter((item) => { let shouldKept = !this.title ? true : this.title === item.title; const hasAllSelection = this.selTagLs.some( (stag) => stag.name === \"all\" ); if (shouldKept && !hasAllSelection) { // check if match every selected tag condition shouldKept = this.selTagLs.every((stag) => { const hasCurSelectedTag = item.tags.includes(stag.name); return stag.reverse ? !hasCurSelectedTag : hasCurSelectedTag; }); } if (shouldKept && this.know) { const knowVal = item.isKnow ? \"yes\" : \"no\"; shouldKept = knowVal === this.know; } return shouldKept; }); if (this.sourceWordList === this.cacheWordList) { this.orderedWordList = viewWordList; } if (this.isRandom) { const isClickRandom = this.lastIsRandom === false; // if result set changed, shuffle the new list if ( viewWordList.length !== this.displayingWordList.length || isClickRandom ) { viewWordList = getShuffleList(viewWordList); } else { viewWordList = this.displayingWordList; // reuse the old list, keep the same random order } } else { const isClickRandom = this.lastIsRandom === true; } // console.log(\"🚀 ~ wordList ~ viewWordList.length !== this.displayingWordList.length:\", viewWordList.length !== this.displayingWordList.length) // if (viewWordList.length !== this.displayingWordList.length) { // this.activeIndex = 0; // } this.displayingWordList = viewWordList; this.sourceWordList = this.displayingWordList; this.isConditionChanged = false; this.lastIsRandom = this.isRandom; return viewWordList; }, activeWord() { return this.wordList[this.activeIndex]; }, }, watch: { activeIndex() { this.isViewAnswer = false; }, fontType() { setCache(\"mfontType\", this.fontType); }, know: { handler() { this.onConditionChanged(); this.sourceWordList = this.cacheWordList; setCache(\"mwordKnow\", this.know); }, immediate: true, }, title: { handler() { this.onConditionChanged(); this.sourceWordList = this.cacheWordList; setCache(\"mwordTitle\", this.title); }, immediate: true, }, selTagLs: { handler() { this.onConditionChanged(); console.log(\"selTagLs changed ============>\", this.selTagLs); this.sourceWordList = this.cacheWordList; setCache(\"mwordTagLs\", this.selTagLs); }, deep: true, immediate: true, }, isRandom: { handler() { this.onConditionChanged(); this.sourceWordList = this.cacheWordList; }, immediate: true, }, total() { const cacheTotal = this.cacheWordList.length; if (!this.total && cacheTotal) { this.tipsFilterEmpty(); } if (this.activeIndex > this.total - 1) { this.activeIndex = this.total - 1; } }, }, methods: { toggleSelectTag(tagOption) { const selected = this.selTagLs.some( (stag) => stag.name === tagOption.name ); const isAllOption = tagOption.name === \"all\"; if (selected) { newSelTagLs = this.selTagLs; if (isAllOption) { // do nothing, select other options will unselect all-option } else { newSelTagLs = this.selTagLs.filter( (stag) => stag.name !== tagOption.name ); if (newSelTagLs.length === 0) { newSelTagLs = [getAllOptionOfTag()]; } } this.selTagLs = newSelTagLs; } else { const matchedPWord = priorityWords.find((w) => tagOption.name.startsWith(w) ); if (isAllOption) { this.selTagLs = [tagOption]; } else { const newSelTagLs = [...this.selTagLs, tagOption].filter( (stag) => stag.name !== \"all\" ); if (matchedPWord && !tagOption.reverse) { this.selTagLs = newSelTagLs.filter( (stag) => stag === tagOption || !(stag.name.startsWith(matchedPWord) && !stag.reverse) ); } else { this.selTagLs = newSelTagLs; } } } }, onConditionChanged() { this.isConditionChanged = true; this.activeIndex = 0; }, tipsFilterEmpty() { showToast(\"无符合的数据，请修改筛选\"); }, updateCache(data) { if (!data) { data = this.cacheWordList; } setCache(\"mwords\", data, true); }, changeRandom(event) { this.randomClickTimes = this.randomClickTimes ? this.randomClickTimes + 1 : 1; console.log(\"🚀 ~ changeRandom ~ this.isRandom:\", this.isRandom); }, handleClickCard(index) { if (!index === this.activeIndex) return; this.isViewAnswer = !this.isViewAnswer; }, showNext() { this.isNext = true; if (this.activeIndex < this.wordList.length - 1) { this.activeIndex++; } else { this.activeIndex = 0; } }, showPrev() { this.isNext = false; if (this.activeIndex > 0) { this.activeIndex--; } else { this.activeIndex = this.wordList.length - 1; } }, toggleTag(tag) { let wordTags = this.activeWord.tags || []; const exists = wordTags.includes(tag.name); if (exists) { this.activeWord.tags = delArrayItem(wordTags, tag.name); } else { const matchedPWord = priorityWords.find((w) => tag.name.startsWith(w) ); if (!matchedPWord) { wordTags.push(tag.name) } else { wordTags = [...wordTags, tag.name].filter( (tagName) => tag.name === tagName || !tagName.startsWith(matchedPWord) ); } this.activeWord.tags = wordTags; } this.updateCache(); }, toggleKnow(isKnow) { this.activeWord.isKnow = isKnow; this.updateCache(); }, }, beforeCreate() { this.lastIsRandom = false; this.isConditionChanged = false; // not reactive data this.displayingWordList = []; this.sourceWordList = this.cacheWordList; }, mounted() { console.vm = this; console.log('this.sourceWordList======>', this.sourceWordList.length); if (!this.cacheWordList.length) { showToast(\"请先增加词语\"); setTimeout(() => { location.href = \"/study\"; }, 3000); } else { if (!this.wordList.length) { this.tipsFilterEmpty(); } } document.body.addEventListener(\"keyup\", (event) => { if (event.key === \"ArrowRight\" || event.code === \"Space\") { this.showNext(); } if (event.key === \"ArrowLeft\") { this.showPrev(); } }); }, });"},{"path":"/study/service-worker.js","content":"self.addEventListener('fetch', function (event) { console.log(\"🚀 ~ dd event req.url:\", event.request.url, [...event.request.headers.entries()]) if (event.request.url.endsWith('.woff') || event.request.url.endsWith('.woff2') || event.request.url.endsWith('.ttf')) { // event.respondWith(fetch(event.request)); const myReq = new Request(event.request, { headers: new Headers(event.request.headers).delete('referer') }); console.log('myReq headers:', myReq.url, [...myReq.headers.entries()]) event.respondWith( fetch(myReq) ); } else { event.respondWith(fetch(event.request)); } });"},{"path":"/study/chinese.html","content":"小学堂 管理文字 单字练习 多字练习"},{"path":"/study/study.js","content":"function getShuffleList(list) { const cloneList = list.slice() function pickRandomOne(list) { const i = Math.floor(Math.random() * list.length) const item = list.splice(i, 1).pop() return item } const retList = [] while(cloneList.length) { const item = pickRandomOne(cloneList) retList.push(item) } return retList } function uniqBy(list, key) { let field = key const valueList = [] const retList = [] list.forEach((val, i) => { const compareValue = typeof key === 'function' ? key(val, i) : key ? val[key] : val if (!valueList.includes(compareValue)) { valueList.push(compareValue) retList.push(val) } }) return retList } function isJsonLike(val) { const re = /^\\[.*\\]$|^\\{.*\\}$/ return re.test(val) } function isPlainObj(val) { return Object.prototype.toString.call(val) === '[object Object]' } function addZero(val) { return val < 10 ? '0' + val : val + '' } function getTodayStr() { const today= new Date() const y = today.getFullYear() const m = today.getMonth() + 1 const d = today.getDate() return [y, m, d].map(addZero).join('-') } class LStorage { constructor() { this.storage = window.localStorage; } set(key, value) { if (isPlainObj(value) || Array.isArray(value)) { value = JSON.stringify(value); } this.storage.setItem(key, value); } get(key) { let value = this.storage.getItem(key); if (isJsonLike(value)) { value = JSON.parse(value); } if (/^[0-9\\.]+$/.test(value)) { value = value * 1 } return value; } del(key) { this.storage.removeItem(key); } clear() { this.storage.clear(); } } const LCache = new LStorage(); function getCurUser() { return LCache.get('curUser') || '' } function getUserKey(cacheKey) { const curUser = getCurUser() return curUser ? curUser + ':' + cacheKey : cacheKey; } const listDataKeys = ['words', 'mwords', 'tags', 'users'] function getCache(cacheKey, skipDisables) { const userKey = getUserKey(cacheKey) let data = LCache.get(userKey) if (listDataKeys.includes(cacheKey) && skipDisables) { data = (data || []).filter(item => item.status !== 'disable') } return data } function clone(data) { return JSON.parse(JSON.stringify(data)) } function setCache(cacheKey, data, isFillDisables) { const userKey = getUserKey(cacheKey) let newData = data if (!listDataKeys.includes(cacheKey) && isFillDisables) { newData = clone(data) const oldData = LCache.get(userKey) || [] const disableIndexLs = oldData.map((item, i) => item.status !== 'disable' ? i : null).filter(v => v !== null) while(disableIndexLs.length > 0) { const i = disableIndexLs.shift() const len = newData.length if (i < len) { newData.splice(i, 0, oldData[i]) } else { newData.push(oldData[i]) } } } LCache.set(userKey, newData) return true } function delArrayItem(arr, item) { const index = arr.findIndex((el) => el === item) if (index > -1) { arr.splice(index, 1) } return arr; } function showToast(msg) { let appDiv = document.querySelector('#app') let toastDiv = document.createElement('div') toastDiv.className = 'my-toast' toastDiv.innerText = msg appDiv.appendChild(toastDiv) setTimeout(() => { toastDiv.classList.add('show') setTimeout(() => { appDiv.removeChild(toastDiv) toastDiv = null appDiv = null }, 2500); }, 300) } function getIsMobile() { return window.innerWidth < 800; } function getAllOptionOfTag() { const allOption = {name: \"all\", text: '全部', reverse: false} return allOption } const priorityWords = [\"练习\", \"测试\", \"第\"]; function sortByPriority(list, isPriorityLast = false) { const PList = list.filter((item) => priorityWords.some((w) => item.name.startsWith(w)) ); const OList = list.filter((item) => !PList.includes(item)); PList.sort((a, b) => (a.name > b.name ? 1 : -1)); OList.sort((a, b) => (a.name > b.name ? 1 : -1)); return isPriorityLast ? [...OList, ...PList] : [...PList, ...OList]; } function getTagOptions(tagList) { const allOption = getAllOptionOfTag() const otherOptions = tagList.map(tag => { if (!tag.text) { tag.text = tag.name } if (tag.reverse == null) { tag.reverse = false } return {...tag} }) return [allOption, ...sortByPriority(otherOptions)] } function getSortedTagList(tagList, isPriorityLast) { return sortByPriority(tagList, isPriorityLast); } function updateSelectedForTags(tagList, selectedTags) { tagList.forEach((tag, i) => { const matched = selectedTags.find(t => t.name === tag.name) if (matched) { tagList[i] = matched } }) } function insertNoReferrerMeta() { const meta = document.createElement('meta') meta.setAttribute('name', 'referrer') meta.setAttribute('content', 'no-referrer') document.head.appendChild(meta) } async function defineMyFonts() { const baseURL = 'https://gitee.com/stephenykk/stephenykk.github.io/raw/master/source/study/' const fonts = { // AaKaishupinyin: baseURL + 'AaKaishupinyin.woff2', pinyin: 'https://files.cnblogs.com/files/stephenykk/AaKaishupinyin.woff2.zip' } Object.keys(fonts).forEach(fontName => { const fontURL = fonts[fontName] injectFont(fontName, fontURL) }) } async function injectFont(fontName, fontURL, isObjectURL = false) { // while response content-type is text/plain, res.blob() is empty // const blob = await fetch(fontURL, { mode: 'no-cors'}).then(res => res.blob()) const res = await fetch(fontURL, { /* mode: 'no-cors', */ responseType: 'blob'}) const text = await res.text() // debugger; console.log(\"🚀 ~ injectFont ~ text:\", text) const blob = await res.blob() console.log(\"🚀 ~ injectFont ~ blob:\", blob) let targetURL = '' if (isObjectURL) { const objURL = URL.createObjectURL(obj) targetURL = objURL } else { const reader = new FileReader() const readPromise = new Promise(resolve => { reader.onload = function(event) { resolve(event.target.result) console.log(\"🚀 ~ readPromise ~ event:\", event) } reader.readAsDataURL(blob) }) const dataURL = await readPromise targetURL = dataURL } console.log(\"🚀 ~ injectFont ~ targetURL:\", targetURL) const format = fontURL.replace(/\\.zip$/, '').split('.').pop(); const fontFaceRule = ` @font-face { font-family: ${fontName}; src: url(${targetURL}) format('${format}'); font-weight: normal; font-style: normal; font-display: swap; } ` const style = document.createElement('style') style.type = 'text/css' style.setAttribute('data-font', fontName) if (style.styleSheet) { style.styleSheet.cssText = fontFaceRule; // ie } else { style.appendChild(document.createTextNode(fontFaceRule)) } document.head.appendChild(style) console.log(`inject font [${fontName}] success!`); } insertNoReferrerMeta() // defineMyFonts();"},{"path":"/study/study.css","content":"/* ----------------- reset ---------------------> */ * { box-sizing: border-box; } .app ul, .app li { list-style: none; margin: 0; padding: 0; } body, h1, h2, h3, h4, h5, h6, input, button, a { font-weight: 300; } .actions-container { margin: 20px 0; } a { text-decoration: none; } input { border-radius: 5px; font-size: 20px; padding: 5px 10px; outline: none; border: 1px solid #ccc; } input:focus { border: 1px solid #1e81ce; } /* --------------------- overwrite ------------> */ .md-text.content { overflow: visible; } .l_body { grid-template-columns: 1fr; } #comments, .l_body .l_left, .l_right, .banner.top, .page-footer, .float-panel { display: none; } article.content { padding-bottom: 0; } footer.page-footer { margin: 0 20px; } /* ---------------- utils ----------------> */ .hide, .debug-hide { display: none !important; } .debug-info { display: none; } .debug-show { display: block !important; } .shrink0 { flex-shrink: 0 !important; } .shrink1 { flex-shrink: 1 !important; } .shrink2 { flex-shrink: 2 !important; } .shrink3 { flex-shrink: 3 !important; } .bg-grey { background: #f3f3f3; } .bg-white { background: white; } .br-3 { border-radius: 3px; } .br-4 { border-radius: 4px; } .br-5 { border-radius: 5px; } .w-full { width: 100%; } .minw-100 { min-width: 100px; } .minw-150 { min-width: 150px; } .minw-200 { min-width: 200px; } .of-h { overflow: hidden; } .va-m { vertical-align: middle; } .pointer { cursor: pointer; } .hide { display: none; } .dis-ib { display: inline-block; } .dis-i { display: inline; } .grey { color: #888 !important; } .purple { color: #b613dc !important; } .blue { color: #0088ff !important; } .green { color: darkgreen !important; } .items-center { align-items: center; } .justify-center { justify-content: center; } .justify-between { justify-content: space-between; } .flex-row { display: flex; flex-direction: row; align-items: center; gap: 10px; } .flex-col { display: flex; flex-direction: column; gap: 10px; } .flex1 { flex-grow: 1; flex-shrink: 0; flex-basis: auto; } .flex2 { flex: 2; } .flex3 { flex: 3; } .flex-wrap { flex-wrap: wrap; } .flex0 { flex-grow: 0; flex-shrink: 0; flex-basis: auto; } .gap0 { gap: 0 !important; } .gap-10 { gap: 10px !important; } .gap-20 { gap: 20px !important; } .gap-30 { gap: 30px !important; } .f-serif { font-family: 'serif'; } .m-auto { margin: auto; } .ta-c { text-align: center; } .ta-r { text-align: right; } .ta-l { text-align: left; } .mt-5 { margin-top: 5px; } .mt-10 { margin-top: 10px; } .mt-20 { margin-top: 20px; } .mt-30 { margin-top: 30px; } .mt-40 { margin-top: 40px; } .mt-50 { margin-top: 50px; } .ml-5 { margin-left: 5px; } .ml-10 { margin-left: 10px; } .ml-20 { margin-left: 20px; } .ml-30 { margin-left: 30px; } .ml-40 { margin-left: 40px; } .ml-50 { margin-left: 50px; } .mr-5 { margin-right: 5px; } .mr-10 { margin-right: 10px; } .mr-20 { margin-right: 20px; } .mr-30 { margin-right: 30px; } .mr-40 { margin-right: 40px; } .mr-50 { margin-right: 50px; } .mb-5 { margin-bottom: 5px; } .mb-10 { margin-bottom: 10px; } .mb-20 { margin-bottom: 20px; } .mb-30 { margin-bottom: 30px; } .mb-40 { margin-bottom: 40px; } .mb-50 { margin-bottom: 50px; } .fw-300 { font-weight: 300; } .fw-400 { font-weight: 400; } .fw-500 { font-weight: 500; } .fw-600 { font-weight: 600; } .f12 { font-size: 12px!important; } .f13 { font-size: 13px!important; } .f14 { font-size: 14px!important; } .f15 { font-size: 15px!important; } .f16 { font-size: 16px!important; } .f17 { font-size: 17px!important; } .f18 { font-size: 18px!important; } .f19 { font-size: 19px!important; } .f20 { font-size: 20px!important; } .f25 { font-size: 25px!important; } .f30 { font-size: 30px!important; } .pos-r { position: relative; } .pos-a { position: absolute; } .lfade-enter-active, .rfade-enter-active { transition: all 0.5s linear; } .lfade-enter { opacity: 0; transform: translateX(500px) scale(0.3); } .lfade-leave-active { transition: all 0.5s linear; transform: translateX(-500px) scale(0.3); } .rfade-enter { opacity: 0; transform: translateX(-500px) scale(0.3); } .rfade-leave-active { transition: all 0.5s linear; transform: translateX(500px) scale(0.3); } .lfade-leave-to, .rfade-leave-to { opacity: 0; } /* ----------- common ---------------> */ .app .myselect { padding: 0; min-height: 27px; line-height: 13px; } .app .myselect::before { content: '>'; position: absolute; right: 10px; top: 8px; font-family: serif; font-weight: bolder; transform: rotate(90deg); color: black; } .app .myselect-view { padding: 4px 18px 4px 8px; font-weight: 400; width: 200px; } .app .myselect-tag { background: #ccc; padding: 3px 6px; border-radius: 10px; margin-bottom: 5px; } .app .myselect-options { position: absolute; /* position: relative; */ width: 100%; border: 0px solid #888; border-radius: 4px; padding: 0px; z-index: 9999; max-height: 0; overflow: hidden; transition: max-height 0.5s ease-out; } .app .myselect.expand .myselect-options { max-height: 500px; border-width: 1px; } .app .myselect-options li { padding: 6px 14px; cursor: pointer; border-bottom: 1px solid #dadada; } .app .myselect-options li:hover { background: #0088ff; color: white; } .app .myselect-options li.selected { background: #0464b8; color: white; } .app .myselect-options li:last-child { border-bottom: none; } .app .myselect-options li.selected{ font-weight: 400; } .app .myselect-options li.selected::before { content: '*'; position: absolute; top: 10px; left: 5px; } .app .my-toast { max-width: 60%; padding: 5px 12px; line-height: 1.5; color: white; font-weight: 500; text-align: center; border-radius: 8px; background: rgba(0, 0, 0, .7); position: fixed; left: 50%; /* top: 32px; */ top: -132px; transform: translateX(-50%); z-index: 999; transition: top 0.4s ease-out; display: block; } .app .my-toast.show { display: block; top: 32px; } #app { margin: 0; height: 100%; display: flex; flex-direction: column; position: relative; } #app .user-info, #app .top-counter { position: fixed; top: 0; right: 0; z-index: 1000; background: rgba(200, 200, 230, .6); padding: 2px 5px; border-radius: 3px 0 0 3px; } #app div.top-counter { right: auto; left: 0px; padding: 2px 10px; border-radius: 0 5px 5px 0; } #app .user-info .name { color: rgb(23, 161, 23); } #app>h1 { margin: 0; } @font-face { font-family: 'HFSimpleLife'; src: url('HFSimpleLife.woff2') format('woff2'), url('HFSimpleLife.woff') format('woff'); font-weight: normal; font-style: normal; font-display: swap; } .app .prev, .app .next { /* font-family: serif, HFSimpleLife, monospace; */ font-family: HFSimpleLife, monospace; font-style: normal; color: #999; background: none; font-size: 50px; position: absolute; padding: 20px 10px; top: 50%; transform: translateY(-50%) scaleY(2.5); left: -10px; cursor: pointer; z-index: 1000; } .app .prev:hover, .app .next:hover { color: #333; /* background: #c1e0f6; */ } .app .next { left: auto; right: -10px; } .ctrl-section { padding: 10px; max-height: 1000px; transition: max-height 0.5s ease; } .tag-bar .tag, .font-bar button { display: inline-block; font-size: 13px; /* padding: 2px 6px; */ padding: 6px; /* margin: 0 5px 2px 0; */ margin: 8px; border-radius: 10px; background: #ccc; cursor: pointer; } .tag-bar .tag.primary { font-size: 15px; padding: 4px 8px; } .know-bar { margin-bottom: 10px; } .font-bar button:hover { background: #ccf; } .tag-bar .tag:hover { background: #cfc; } .tag-bar .tag.active { background: rgb(6, 161, 6); color: white; } .tag-bar .tag.primary:hover { background: #7dc6fd; } .tag-bar .tag.primary.active { background: #0088ff; color: white; } .app-main { flex: 1; /* overflow: hidden; */ } h1 { font-size: 30px; text-align: center; } .action-btn a { color: #333; } .action-btn, .op-btn { padding: 5px 10px; border-radius: 5px; background: #ddd; color: #333; border: 1px solid #ddd; font-size: 20px; cursor: pointer; margin: 10px; } .app.mobile .action-btn { padding: 2px 5px; margin: 3px; font-size: 18px; } /* .op-btn + .op-btn { margin-left: 0; } */ .op-btn.primary a, button.primary a { color: white; } .action-btn:hover, .op-btn:hover, .op-btn-wrap:hover .op-btn { background: #eee; border-color: #eee; } .op-btn.primary, button.primary { background: #0088ff; color: #fff; border-color: #0088ff; } .op-btn.primary:hover, button.primary:hover, .op-btn-wrap:hover .op-btn { background: #0464b8; border-color: #0464b8; } .op-btn.danger, button.danger { background: #e00; color: #fff; border-color: #e00; } .op-btn.danger:hover, button.danger:hover { background: #f00; border-color: #f00; } .op-btn { font-size: 16px; } /* ----------------------- admin ----------------> */ .admin { /* max-width: 500px; */ max-width: auto; } .sticky-0 { position: sticky; top: 0; z-index: 100; background: #f9fafb; } .sticky-50 { position: sticky; top: 50px; z-index: 100; background: #f9fafb; } article.md-text { padding: 0; } .admin .word-list { font-size: 15px; } .admin table.word-list th { font-weight: 400; font-size: 18px; } .admin table.word-list { width: 100%; table-layout: auto; border-collapse: collapse; min-height: 200px; } .admin table.word-list tr { border-bottom: 1px solid #ccc; display: table-row !important; } .admin table.word-list tr.disable { color: #bbb; } .admin table.word-list td, .admin table.word-list th { /* border: 1px solid #ccc; */ } .admin .word-item { margin-bottom: 10px; border-bottom: 1px solid #ccc; } .admin .word-item:last-child { /* border-bottom: none; */ } .admin .word-item .sn:after { /* content: \".\"; */ } .admin .append-line, .admin .upload-line { padding: 0 10px; } .admin .append-line input { width: 180px; } /* ------------------ single -------------------> */ .app .collapse-bar { margin-bottom: 0px; padding-right: 20px; padding-bottom: 10px; font-size: 20px; } .app .collapse-bar .collapse-btn { /* color: coral; */ transform: rotate(-90deg) scaleY(150%); } .app .collapse-bar.close-ctrl .collapse-btn { transform: rotate(90deg) scaleY(150%); } .app .collapse-bar.close-ctrl + .ctrl-section { max-height: 0; padding: 0; overflow: hidden; } .file-input { position: absolute; left: -200px; top: 0; width: 300px; height: 100%; opacity: 0; z-index: 10; } .card-list { min-height: 550px; } .go-btn { position: fixed; z-index: 10000; left: 20px; bottom: 120px; transform: rotate(-90deg); width: 30px; height: 30px; border-radius: 50%; text-align: center; overflow: hidden; opacity: 0.8; line-height: 30px; font-size: 22px; font-weight: bold; background:#90d5dd; cursor: pointer; font-style: normal; font-family: serif; } .go-btn.bottom { bottom: 80px; transform: rotate(90deg); } html button { border: 0; } /* @font-face { font-family: 'AaKaishupinyin'; src: url('AaKaishupinyin.woff2') format('woff2'), url('AaKaishupinyin.woff') format('woff'); font-weight: normal; font-style: normal; font-display: swap; } */ /* @font-face { font-family: 'AaKaishupinyin'; src: url('AaKaishupinyin.woff2') format('woff2'), url('AaKaishupinyin.woff') format('woff'); font-weight: normal; font-style: normal; font-display: swap; } */ @font-face { font-family: 'AaWDXDNFAN'; src: url('AaWDXDNFANNon-CommercialUse.woff2') format('woff2'), url('AaWDXDNFANNon-CommercialUse.woff') format('woff'); font-weight: normal; font-style: normal; font-display: swap; } @font-face { font-family: 'zihunShuxinti'; src: url('zihun104hao-shuxinti.woff2') format('woff2'), url('zihun104hao-shuxinti.woff') format('woff'); font-weight: normal; font-style: normal; font-display: swap; } @font-face { font-family: 'zihun81hao-qingfengti'; src: url('zihun81hao-qingfengti.woff2') format('woff2'), url('zihun81hao-qingfengti.woff') format('woff'); font-weight: normal; font-style: normal; font-display: swap; } @font-face { font-family: 'AaHuayuziluolanyongheng'; src: url('AaHuayuziluolanyongheng.woff2') format('woff2'), url('AaHuayuziluolanyongheng.woff') format('woff'); font-weight: normal; font-style: normal; font-display: swap; } .card-con.font1 { font-family: 'AaWDXDNFAN', \"cursive\", fangsong, serif; } .card-con.font2 { font-family: 'zihun81hao-qingfengti', \"cursive\", fangsong, serif; } .card-con.font3 { font-family: 'zihunShuxinti', \"cursive\", fangsong, serif; } .card-con.font4 { font-family: 'AaHuayuziluolanyongheng', \"cursive\", fangsong, serif; } .card-con.font5 { font-family: 'AaKaishupinyin', \"cursive\", fangsong, serif; } .card-con { letter-spacing: -15px; line-height: 1.2; text-align: center; font-size: 330px; border: 20px solid beige; padding: 10px; background: white; border-radius: 30px; } .mobile .card-con { font-size: 250px; } .card-item-wrap { position: absolute; left: 50%; transform: translate(-50%, -50%); top: 50%; } /* -------------- multiple ---------------> */ .multiple-container .card-item-wrap { width: 90%; } .title-select, .myselect, .my-select { padding: 3px 6px; background: white; border-radius: 5px; border: 1px solid #0088ff; font-size: 13px; width: 200px; min-height: 30px; } .filter-btn { padding: 3px 10px; border-radius: 5px; background: #0088ff; color: white; } .know-bar .op-btn { padding: 2px 5px; font-size: 14px; margin: 0 5px 0; } .testing .card-item .chr::after { display: block; } .card-item .chr::after { display: none; content: \"\"; width: 120%; height: 70%; border-radius: 10px; position: absolute; bottom: 0; left: 50%; transform: translateX(-50%); background: #eee; opacity: 1; transition: opacity 0.5s ease-in-out; } aside { visibility: hidden !important; } .card-item.view-answer .chr::after { opacity: 0; } .app .minus-sign { height: 0; width: 8px; border-top: 1px solid #333; margin-right: 3px; transform: translateY(-5px); }"},{"path":"/study/single.html","content":"// if ('serviceWorker' in navigator) { // console.log(\"🚀 ~ serviceWorker:\", navigator.serviceWorker) // navigator.serviceWorker.register('./service-worker.js').then(function(registration) { // console.log('Service Worker registered with scope:', registration.scope); // }).catch(function(error) { // console.log('Service Worker registration failed:', error); // }); // } 用户: ${ currentUser || '默认用户' } ${activeIndex + 1} / ${wordList.length} 单字认读 &gt; 选择字体: 字体1 字体2 字体3 字体4 字体5 筛选: 标题: 全部 ${ttl} 标签: ${ selTag.text } ${tagOpt.text} 取反 掌握: 全部 已掌握 未掌握 随机: 设置掌握: 已掌握 未掌握 设置标签: 创建标签 ${ tag.name } ${ wordList } ${ activeWord } ${ wordList[activeIndex]?.lesson ? '《' + wordList[activeIndex].lesson + '》' : ''} &lt; &gt; ${chr} ${ wordList[activeIndex].explain || '' } ${activeIndex + 1} / ${wordList.length} const searchParams = new URLSearchParams(location.search); const isTest = ![null, \"0\", \"false\"].includes(searchParams.get(\"test\")); const primaryWords = priorityWords; const tagTable = getCache(\"tags\", true) || []; const sortedTagList = getSortedTagList(tagTable, true); const selectedTagList = getCache(\"wordTagLs\") || [getAllOptionOfTag()]; const tagOptions = getTagOptions(tagTable); updateSelectedForTags(tagOptions, selectedTagList); window.myapp = new Vue({ el: \"#app\", delimiters: [\"${\", \"}\"], data: { isCloseCtrl: false, primaryWords, tagSelectOpen: false, title: getCache(\"wordTitle\") || \"\", // tag: getCache('mwordTagLs') || '', selTagLs: selectedTagList, know: getCache(\"wordKnow\") || \"\", currentUser: getCurUser(), activeIndex: 0, isNext: true, isMobile: getIsMobile(), isRandom: false, fontType: isTest ? 5 : getCache(\"fontType\") || 5, cacheWordList: getCache(\"words\", true) || [], tagList: sortedTagList, tagOptions: tagOptions, orderedWordList: [], isViewAnswer: false, isTestMode: isTest, }, computed: { fontStyle: function () { // word: {date, word} const word = this.wordList[this.activeIndex]; if (!word) { return { fontSize: \"250px\" }; } const sizeMap = { 1: 330, 2: 330, 3: 330, 4: 250, 5: 200, 6: 160, 7: 130, }; const mobileSizeMap = { 1: 180, 2: 120, 3: 90, 4: 120, 5: 60, 6: 90, 7: 90, }; const map = this.isMobile ? mobileSizeMap : sizeMap; const size = map[word.word.length] || 50; return { fontSize: size + \"px\" }; }, total() { return this.wordList.length; }, titleList() { return [ ...new Set( this.cacheWordList.map((item) => item.title).filter((v) => !!v) ), ]; }, wordList() { // if (!this.isConditionChanged) return this.displayingWordList; console.log(\"computed wordList start------------>\"); let viewWordList = this.sourceWordList.filter((item) => { let shouldKept = !this.title ? true : this.title === item.title; const hasAllSelection = this.selTagLs.some( (stag) => stag.name === \"all\" ); if (shouldKept && !hasAllSelection) { // check if match every selected tag condition shouldKept = this.selTagLs.every((stag) => { const hasCurSelectedTag = item.tags.includes(stag.name); return stag.reverse ? !hasCurSelectedTag : hasCurSelectedTag; }); } if (shouldKept && this.know) { const knowVal = item.isKnow ? \"yes\" : \"no\"; shouldKept = knowVal === this.know; } return shouldKept; }); if (this.sourceWordList === this.cacheWordList) { this.orderedWordList = viewWordList; } if (this.isRandom) { const isClickRandom = this.lastIsRandom === false; // if result set changed, shuffle the new list if ( viewWordList.length !== this.displayingWordList.length || isClickRandom ) { viewWordList = getShuffleList(viewWordList); } else { viewWordList = this.displayingWordList; // reuse the old list, keep the same random order } } else { const isClickRandom = this.lastIsRandom === true; } // console.log(\"🚀 ~ wordList ~ viewWordList.length !== this.displayingWordList.length:\", viewWordList.length !== this.displayingWordList.length) // if (viewWordList.length !== this.displayingWordList.length) { // this.activeIndex = 0; // } this.displayingWordList = viewWordList; this.sourceWordList = this.displayingWordList; this.isConditionChanged = false; this.lastIsRandom = this.isRandom; return viewWordList; }, activeWord() { return this.wordList[this.activeIndex]; }, }, watch: { activeIndex() { this.isViewAnswer = false; }, fontType() { setCache(\"fontType\", this.fontType); }, know: { handler() { this.onConditionChanged(); this.sourceWordList = this.cacheWordList; setCache(\"wordKnow\", this.know); }, immediate: true, }, title: { handler() { this.onConditionChanged(); this.sourceWordList = this.cacheWordList; setCache(\"wordTitle\", this.title); }, immediate: true, }, selTagLs: { handler() { this.onConditionChanged(); this.sourceWordList = this.cacheWordList; setCache(\"wordTagLs\", this.selTagLs); }, deep: true, immediate: true, }, isRandom: { handler() { this.onConditionChanged(); this.sourceWordList = this.cacheWordList; }, immediate: true, }, total() { const cacheTotal = this.cacheWordList.length; if (!this.total && cacheTotal) { this.tipsFilterEmpty(); } if (this.activeIndex > this.total - 1) { this.activeIndex = this.total - 1; } }, }, methods: { toggleSelectTag(tagOption) { const selected = this.selTagLs.some( (stag) => stag.name === tagOption.name ); const isAllOption = tagOption.name === \"all\"; if (selected) { newSelTagLs = this.selTagLs; if (isAllOption) { // do nothing, select other options will unselect all-option } else { newSelTagLs = this.selTagLs.filter( (stag) => stag.name !== tagOption.name ); if (newSelTagLs.length === 0) { newSelTagLs = [getAllOptionOfTag()]; } } this.selTagLs = newSelTagLs; } else { const matchedPWord = priorityWords.find((w) => tagOption.name.startsWith(w) ); if (isAllOption) { this.selTagLs = [tagOption]; } else { const newSelTagLs = [...this.selTagLs, tagOption].filter( (stag) => stag.name !== \"all\" ); if (matchedPWord && !tagOption.reverse) { this.selTagLs = newSelTagLs.filter( (stag) => stag === tagOption || !(stag.name.startsWith(matchedPWord) && !stag.reverse) ); } else { this.selTagLs = newSelTagLs; } } } }, onConditionChanged() { this.isConditionChanged = true; this.activeIndex = 0; }, tipsFilterEmpty() { showToast(\"无符合的数据，请修改筛选\"); }, updateCache(data) { if (!data) { data = this.cacheWordList; } setCache(\"words\", data, true); }, changeRandom(event) { this.randomClickTimes = this.randomClickTimes ? this.randomClickTimes + 1 : 1; console.log(\"🚀 ~ changeRandom ~ this.isRandom:\", this.isRandom); }, handleClickCard(index) { if (!index === this.activeIndex) return; this.isViewAnswer = !this.isViewAnswer; }, showNext() { this.isNext = true; if (this.activeIndex < this.wordList.length - 1) { this.activeIndex++; } else { this.activeIndex = 0; } }, showPrev() { this.isNext = false; if (this.activeIndex > 0) { this.activeIndex--; } else { this.activeIndex = this.wordList.length - 1; } }, toggleTag(tag) { let wordTags = this.activeWord.tags || []; const exists = wordTags.includes(tag.name); if (exists) { this.activeWord.tags = delArrayItem(wordTags, tag.name); } else { const matchedPWord = priorityWords.find((w) => tag.name.startsWith(w) ); if (!matchedPWord) { wordTags.push(tag.name) } else { wordTags = [...wordTags, tag.name].filter( (tagName) => tag.name === tagName || !tagName.startsWith(matchedPWord) ); } this.activeWord.tags = wordTags; } this.updateCache(); }, toggleKnow(isKnow) { this.activeWord.isKnow = isKnow; this.updateCache(); }, }, beforeCreate() { this.lastIsRandom = false; this.isConditionChanged = false; // not reactive data this.displayingWordList = []; this.sourceWordList = this.cacheWordList; }, mounted() { if (!this.cacheWordList.length) { showToast(\"请先增加文字\"); setTimeout(() => { location.href = \"/study\"; // kkkk }, 3000); } else { if (!this.wordList.length) { this.tipsFilterEmpty(); } } document.body.addEventListener(\"keyup\", (event) => { if (event.key === \"ArrowRight\" || event.code === \"Space\") { this.showNext(); } if (event.key === \"ArrowLeft\") { this.showPrev(); } }); }, });"},{"path":"/house/qy.html","content":"贷款计算 贷款计算 ${winWidth} 房子总价 首付比例 首付金额 贷款金额 贷款利率 贷款年限 贷款时间 月供金额 月供本金 还款方式 等额本息 等额本金 已还总金额 已还本金 已还利息 剩余待还总额 剩余待还本金 剩余待还利息 累计还款金额 累计支付利息 总计成本 当前时间 还清时间 提前还款金额 提前还款时间 提前还还清时间 提前还累计还款 提前还累计利息 提前还利息减少 提前还总计成本 房子现在市值 期数 日期 月供金额 还款本金 还款利息 年还利息 剩余本金 还款本金(提前还) 还款利息(提前还) 年还利息(提前还) 剩余本金(提前还) 22 2017年12月 2446 793 1653 20010 495146 118 2025年12月 2446 1092 1355 16492 405285 1134 1313 16120 (年省:372, 累计省:372) 392694 期数 日期 月供金额 还款本金 还款利息 年还利息 剩余本金 还款本金(提前还) 还款利息(提前还) 年还利息(提前还) 剩余本金(提前还) ${index + 1} ${item.date} ${item.monthlyPay} ${item.monthlyBenjin} ${item.monthlyInterest} ${item.yearInterest || ''} ${item.remainBenjin} ${house.aheadMonthlyData[index]?.monthlyBenjin} ${house.aheadMonthlyData[index]?.monthlyInterest} ${house.aheadMonthlyData[index]?.yearInterest || ''} ${' (年省:'+ house.aheadMonthlyData[index]?.yearSaveInterest +', 累计省:'+ house.aheadMonthlyData[index]?.totalSaveInterest +')'} ${house.aheadMonthlyData[index]?.remainBenjin} 0 ${' (年省:'+ item.yearInterest +', 累计省:'+ (lastTotalSaveInterest * 1 + extraYearSaves[index] *1) +')'} &gt; &lt;"},{"path":"/house/house.js","content":"document.title = \"房贷计算器\"; const SAME_BENXI = 1 const SAME_BENJIN = 2 /* 根据还款年限，计算月供金额 */ function getMonthlyPayment(loanAmount, interestRate, loanTerm) { const monthlyRate = interestRate / 12; const totalPayments = loanTerm * 12; return ( (loanAmount * monthlyRate) / (1 - Math.pow(1 + monthlyRate, -totalPayments)) ); } function throttle(fn, delayMs) { let lastTime = 0; let timer = null return function thrFn() { const now = Date.now(); if (timer) clearTimeout(timer); if (now - lastTime < delayMs) { timer = setTimeout(thrFn, delayMs + 50); return; } lastTime = now; fn.apply(this, arguments); }; } function toFixed(num, decimal = 0) { return num.toFixed(decimal) * 1; } function mapValues(obj, keys, fn) { return Object.keys(obj).reduce((acc, key) => { acc[key] = keys.includes(key) ? fn(obj[key], key, obj) : obj[key]; return acc; }, {}); } // 添加日期字段 const getDate = (date, isDash = false) => { const d = new Date(date); return isDash ? `${d.getFullYear()}-${fillZero(d.getMonth() + 1)}` : `${d.getFullYear()}年${fillZero(d.getMonth() + 1)}月`; }; // 中文时间转为数字时间 const cnTimeToDashTime = (date) => { return date.replace(/\\D/g, \"-\").replace(/-\\D*$/, \"\"); }; function fillZero(num) { return num < 10 ? \"0\" + num : num; } const getLast = (list) => { return list[list.length - 1]; }; const getYearMonth = (dateStr) => { const date = new Date(dateStr); return date.getFullYear() + \"-\" + fillZero(date.getMonth() + 1); }; const getSum = (list, key) => { return toFixed(list.reduce((acc, item) => acc + item[key], 0)) }; function getCurTime() { const today = new Date(); today.setDate(1); const year = today.getFullYear(); const month = today.getMonth() + 1; const date = today.getDate(); return `${year}-${fillZero(month)}-${fillZero(date)}`; } /** * 根据借款基础信息，计算月供等数据 */ function getMonthlyDetail({ firstPayMoney, // 首付 loanMoney, loanRate, loanYears, startTime, curTime, aheadPayTime, aheadPayMoney, }) { const monthlyRate = loanRate / 12; const totalMonths = Math.ceil(loanYears * 12) let monthlyData = []; let remainBenjin = loanMoney; let monthlyPay = 15000; const getMonthlyInfo = () => { while (remainBenjin > 0) { // debugger; const monthlyInterest = remainBenjin * monthlyRate; const monthlyBenjin = monthlyPay - monthlyInterest remainBenjin -= monthlyBenjin; monthlyData.push({ sn: monthlyData.length + 1, remainBenjin, monthlyBenjin, monthlyInterest, monthlyPay, }); } }; const smallLs = []; const bigLs = []; while (monthlyData.length != totalMonths) { const actualTotalMonths = monthlyData.length; const isSmall = actualTotalMonths > totalMonths; const ls = isSmall ? smallLs : bigLs; ls.push(monthlyPay); let delta = 1; if (isSmall) { const lastBig = bigLs[bigLs.length - 1]; delta = lastBig ? (lastBig - monthlyPay) * 0.5 : monthlyPay * 0.5; } else { const lastSmall = smallLs[smallLs.length - 1]; delta = lastSmall ? (lastSmall - monthlyPay) * 0.5 : (0 - monthlyPay) * 0.5; } // const delta = actualTotalMonths > totalMonths ? 1 : -1; monthlyData = []; remainBenjin = loanMoney; monthlyPay = monthlyPay + delta; const minMonthlyPay = remainBenjin * monthlyRate; if (monthlyPay < minMonthlyPay) { monthlyPay = minMonthlyPay + 100; } console.log(\"🚀 ~ getMonthlyDetail ~ monthlyPay:\", monthlyPay); console.time(\"mm\"); getMonthlyInfo(); console.timeEnd(\"mm\"); } let yearStartIndex = 0 monthlyData.forEach((item, index) => { const itemDate = new Date(startTime); itemDate.setMonth(itemDate.getMonth() + index); const nextItemDate = new Date(startTime); nextItemDate.setMonth(nextItemDate.getMonth() + index + 1); if (itemDate.getFullYear() !== nextItemDate.getFullYear()) { yearEndIndex = index; const yearData = monthlyData.slice(yearStartIndex, yearEndIndex + 1); const yearInterest = getSum(yearData, \"monthlyInterest\"); item.yearInterest = yearInterest; yearStartIndex = index + 1; } const date = getDate(itemDate); const curDate = new Date(curTime); const aheadDate = new Date(aheadPayTime); if (curDate > itemDate) { item.isBefore = true; } else { if (getYearMonth(curDate) === getYearMonth(itemDate)) { item.isCur = true; } if (getYearMonth(aheadDate) === getYearMonth(itemDate)) { item.isAhead = true; } item.isAfter = true; } item.date = date; }); const addMonth = (date, n) => { const d = new Date(date); d.setMonth(d.getMonth() + n); return d; }; // 如有提前还款，则重新计算后续还款的明细 let aheadMonthlyData = []; if (aheadPayMoney) { aheadMonthlyData = monthlyData.slice(); const aheadIndex = aheadMonthlyData.findIndex((item) => { aheadDate = getDate(aheadPayTime); return item.date === aheadDate }); aheadMonthlyData.splice(aheadIndex); let remainBenjin = aheadMonthlyData[aheadMonthlyData.length - 1].remainBenjin - aheadPayMoney; let i = 0; while (remainBenjin > 0) { const monthlyInterest = remainBenjin * monthlyRate; const monthlyBenjin = monthlyPay - monthlyInterest; remainBenjin -= monthlyBenjin; aheadMonthlyData.push({ sn: aheadIndex + i + 1, isAfter: true, date: getDate(addMonth(aheadPayTime, i)), monthlyBenjin, monthlyInterest, remainBenjin, monthlyPay, }); i = i + 1; } } // add yearInterest if (aheadMonthlyData.length > 0) { let aheadYearStartIdx = 0; const yearSaveInterestList = []; aheadMonthlyData.forEach((item, index) => { const time = cnTimeToDashTime(item.date) const itemDate = new Date(time); const month = itemDate.getMonth() + 1; if (month === 12) { const aheadYearEndIdx = index; const yearData = aheadMonthlyData.slice(aheadYearStartIdx, aheadYearEndIdx + 1); const yearInterest = getSum(yearData, \"monthlyInterest\"); item.yearInterest = yearInterest; const yearSaveInterest = toFixed(monthlyData[index].yearInterest - yearInterest || 0); item.yearSaveInterest = yearSaveInterest; yearSaveInterestList.push(yearSaveInterest); item.totalSaveInterest = toFixed(yearSaveInterestList.reduce((a, b) => a + b, 0)); aheadYearStartIdx = index + 1; } }) } const beforeData = monthlyData.filter((item) => item.isBefore); const afterData = monthlyData.filter((item) => item.isAfter); const hasPayLixi = getSum(beforeData, \"monthlyInterest\"); const hasPayBenjin = getSum(beforeData, \"monthlyBenjin\"); const hasPayAmount = hasPayBenjin + hasPayLixi; const remainPayBenjin = getSum(afterData, \"monthlyBenjin\"); const remainPayLixi = getSum(afterData, \"monthlyInterest\"); const remainPayAmount = toFixed(remainPayBenjin + remainPayLixi); const sumPayAmount = toFixed(hasPayAmount + remainPayAmount) const sumPayLixi = toFixed(hasPayLixi + remainPayLixi); const totalCost = toFixed(sumPayAmount + firstPayMoney); const endTime = cnTimeToDashTime(getLast(monthlyData).date); // 贷款结束时间 const aheadEndTime = !aheadMonthlyData.length ? endTime : cnTimeToDashTime(getLast(aheadMonthlyData).date); // 提前还贷款结束时间 const aheadSumPayAmount = !aheadMonthlyData.length ? sumPayAmount : getSum(aheadMonthlyData, \"monthlyPay\") + aheadPayMoney * 1; const aheadSumPayLixi = !aheadMonthlyData.length ? sumPayLixi : getSum(aheadMonthlyData, \"monthlyInterest\"); const aheadTotalCost = !aheadMonthlyData.length ? totalCost : toFixed(aheadSumPayAmount + firstPayMoney); const monthPayMoney = toFixed(monthlyPay); monthlyData = monthlyData.map((item) => mapValues( item, [\"monthlyInterest\", \"monthlyPay\", \"remainBenjin\", \"monthlyBenjin\", \"yearInterest\"], (value) => toFixed(value) ) ); aheadMonthlyData = aheadMonthlyData.map((item) => mapValues( item, [\"monthlyInterest\", \"monthlyPay\", \"remainBenjin\", \"monthlyBenjin\", \"yearInterest\"], (value) => toFixed(value) ) ); console.table(monthlyData); aheadPayMoney && console.table(aheadMonthlyData); return { monthlyData, aheadMonthlyData, monthPayMoney, endTime, aheadEndTime, hasPayLixi, hasPayAmount, hasPayBenjin, remainPayAmount, remainPayBenjin, remainPayLixi, sumPayAmount, sumPayLixi, aheadSumPayAmount, aheadSumPayLixi, totalCost, aheadTotalCost, }; } function getMonthlyDetailForSameBenJin({ firstPayMoney, // 首付 loanMoney, loanRate, loanYears, startTime, curTime, aheadPayTime, aheadPayMoney, }) { const monthlyRate = loanRate / 12; const totalMonths = Math.ceil(loanYears * 12); let monthlyData = []; let remainBenjin = loanMoney; let monthlyBenjin = remainBenjin; const getMonthlyInfo = () => { while (remainBenjin > 0) { // debugger; const monthlyInterest = remainBenjin * monthlyRate; const monthlyPay = monthlyBenjin + monthlyInterest remainBenjin -= monthlyBenjin; monthlyData.push({ sn: monthlyData.length + 1, remainBenjin, monthlyBenjin, monthlyInterest, monthlyPay, }); } }; const smallLs = []; const bigLs = []; while (monthlyData.length != totalMonths) { const actualTotalMonths = monthlyData.length; const isSmall = actualTotalMonths > totalMonths; const ls = isSmall ? smallLs : bigLs; ls.push(monthlyBenjin); let delta = 1; if (isSmall) { const lastBig = bigLs[bigLs.length - 1]; delta = lastBig ? (lastBig - monthlyBenjin) * 0.5 : monthlyBenjin * 0.5; } else { const lastSmall = smallLs[smallLs.length - 1]; delta = lastSmall ? (lastSmall - monthlyBenjin) * 0.5 : (0 - monthlyBenjin) * 0.5; } // const delta = actualTotalMonths > totalMonths ? 1 : -1; monthlyData = []; remainBenjin = loanMoney; monthlyBenjin = monthlyBenjin + delta; const minMonthlyPay = remainBenjin * monthlyRate; if (monthlyBenjin * (1 + monthlyRate) < minMonthlyPay) { monthlyBenjin = monthlyBenjin + 100; } console.log(\"🚀 ~ getMonthlyDetail ~ monthlyBenjin:\", monthlyBenjin); console.time(\"mm\"); getMonthlyInfo(); console.timeEnd(\"mm\"); } let yearStartIndex = 0 monthlyData.forEach((item, index) => { const itemDate = new Date(startTime); itemDate.setMonth(itemDate.getMonth() + index); const nextItemDate = new Date(startTime); nextItemDate.setMonth(nextItemDate.getMonth() + index + 1); if (itemDate.getFullYear() !== nextItemDate.getFullYear()) { yearEndIndex = index; const yearData = monthlyData.slice(yearStartIndex, yearEndIndex + 1); const yearInterest = getSum(yearData, \"monthlyInterest\"); item.yearInterest = yearInterest; yearStartIndex = index + 1; } const date = getDate(itemDate); const curDate = new Date(curTime); const aheadDate = new Date(aheadPayTime); if (curDate > itemDate) { item.isBefore = true; } else { if (getYearMonth(curDate) === getYearMonth(itemDate)) { item.isCur = true; } if (getYearMonth(aheadDate) === getYearMonth(itemDate)) { item.isAhead = true; } item.isAfter = true; } item.date = date; }); const addMonth = (date, n) => { const d = new Date(date); d.setMonth(d.getMonth() + n); return d; }; // 如有提前还款，则重新计算后续还款的明细 let aheadMonthlyData = []; if (aheadPayMoney) { aheadMonthlyData = monthlyData.slice(); const aheadIndex = aheadMonthlyData.findIndex((item) => { aheadDate = getDate(aheadPayTime); return item.date === aheadDate }); aheadMonthlyData.splice(aheadIndex); let remainBenjin = aheadMonthlyData[aheadMonthlyData.length - 1].remainBenjin - aheadPayMoney; let i = 0; while (remainBenjin > 0) { const monthlyInterest = remainBenjin * monthlyRate; const monthlyPay = monthlyBenjin + monthlyInterest; remainBenjin -= monthlyBenjin; aheadMonthlyData.push({ sn: aheadIndex + i + 1, isAfter: true, date: getDate(addMonth(aheadPayTime, i)), monthlyBenjin, monthlyInterest, remainBenjin, monthlyPay, }); i = i + 1; } } // add yearInterest if (aheadMonthlyData.length > 0) { let aheadYearStartIdx = 0; const yearSaveInterestList = []; aheadMonthlyData.forEach((item, index) => { const time = cnTimeToDashTime(item.date) const itemDate = new Date(time); const month = itemDate.getMonth() + 1; if (month === 12) { const aheadYearEndIdx = index; const yearData = aheadMonthlyData.slice(aheadYearStartIdx, aheadYearEndIdx + 1); const yearInterest = getSum(yearData, \"monthlyInterest\"); item.yearInterest = yearInterest; const yearSaveInterest = toFixed(monthlyData[index].yearInterest - yearInterest || 0); item.yearSaveInterest = yearSaveInterest; yearSaveInterestList.push(yearSaveInterest); item.totalSaveInterest = toFixed(yearSaveInterestList.reduce((a, b) => a + b, 0)); aheadYearStartIdx = index + 1; } }) } const beforeData = monthlyData.filter((item) => item.isBefore); const afterData = monthlyData.filter((item) => item.isAfter); const hasPayLixi = getSum(beforeData, \"monthlyInterest\"); const hasPayBenjin = getSum(beforeData, \"monthlyBenjin\"); const hasPayAmount = hasPayBenjin + hasPayLixi; const remainPayBenjin = getSum(afterData, \"monthlyBenjin\"); const remainPayLixi = getSum(afterData, \"monthlyInterest\"); const remainPayAmount = toFixed(remainPayBenjin + remainPayLixi); const sumPayAmount = toFixed(hasPayAmount + remainPayAmount) const sumPayLixi = toFixed(hasPayLixi + remainPayLixi); const totalCost = toFixed(sumPayAmount + firstPayMoney); const endTime = cnTimeToDashTime(getLast(monthlyData).date); // 贷款结束时间 const aheadEndTime = !aheadMonthlyData.length ? endTime : cnTimeToDashTime(getLast(aheadMonthlyData).date); // 提前还贷款结束时间 const aheadSumPayAmount = !aheadMonthlyData.length ? sumPayAmount : getSum(aheadMonthlyData, \"monthlyPay\") + aheadPayMoney * 1; const aheadSumPayLixi = !aheadMonthlyData.length ? sumPayLixi : getSum(aheadMonthlyData, \"monthlyInterest\"); const aheadTotalCost = !aheadMonthlyData.length ? totalCost : toFixed(aheadSumPayAmount + firstPayMoney); // const monthPayMoney = toFixed(monthlyPay); const monthPayMoney = 0; monthlyData = monthlyData.map((item) => mapValues( item, [\"monthlyInterest\", \"monthlyPay\", \"remainBenjin\", \"monthlyBenjin\", \"yearInterest\"], (value) => toFixed(value) ) ); aheadMonthlyData = aheadMonthlyData.map((item) => mapValues( item, [\"monthlyInterest\", \"monthlyPay\", \"remainBenjin\", \"monthlyBenjin\", \"yearInterest\"], (value) => toFixed(value) ) ); console.table(monthlyData); if (aheadPayMoney) { console.table(aheadMonthlyData); } return { monthlyData, aheadMonthlyData, monthPayMoney, monthlyBenjin: toFixed(monthlyBenjin), endTime, aheadEndTime, hasPayLixi, hasPayAmount, hasPayBenjin, remainPayAmount, remainPayBenjin, remainPayLixi, sumPayAmount, sumPayLixi, aheadSumPayAmount, aheadSumPayLixi, totalCost, aheadTotalCost, }; } window.myapp = new Vue({ el: \"#houseApp\", delimiters: [\"${\", \"}\"], data() { const qyInfo = { nowHouseAmount: 880000, firstPayRate: 0.3, firstPayMoney: 321600, loanRate: 0.05, loanYears: 13, aheadPayMoney: 0, aheadPayTime: getCurTime(), startTime: \"2020-01-01\", payType: 2 }; const winWidth = window.innerWidth; return { baseInfo: qyInfo, winWidth, scrollLeft: 0, headerTableHeight: 69 } }, computed: { house() { console.log('----------> computed house data'); return this.getData(this.baseInfo); }, hasAheadPay() { return this.house.aheadMonthlyData.length > 0; }, lastTotalSaveInterest() { if (!this.hasAheadPay) { return 0; } const lastYearItem = this.house.aheadMonthlyData .filter((it) => it.totalSaveInterest) .pop(); return lastYearItem?.totalSaveInterest || 0; }, extraYearSaves() { if (!this.hasAheadPay) { return {}; } const { aheadMonthlyData, monthlyData } = this.house; const extraYearLs = []; monthlyData.forEach((it, index) => { if (index < aheadMonthlyData.length) return false; if (it.yearInterest) { extraYearLs.push([index, it.yearInterest]); } }); const extraYearSumLs = extraYearLs.map(([index, yearInterest], j) => { const sumInterest = extraYearLs .slice(0, j + 1) .reduce((sum, [index, yearInterest]) => sum + yearInterest, 0); return [index, sumInterest]; }); const extraYearSumMap = Object.fromEntries(extraYearSumLs); return extraYearSumMap; }, }, methods: { goTop() { window.scrollTo({ top: 0, behavior: \"smooth\" }); }, goBottom() { window.scrollTo({ top: 100000, behavior: \"smooth\" }); }, getData: ({ firstPayRate, firstPayMoney, loanRate, loanYears, aheadPayMoney, startTime, aheadPayTime, payType, }) => { const houseAmount = toFixed(firstPayMoney / firstPayRate); const loanMoney = toFixed(houseAmount - firstPayMoney); const curTime = getCurTime(); if (!aheadPayTime) { aheadPayTime = curTime; // 如果没有提前还款时间，则默认为当前时间 } const getMonthlyDetailMethod = payType === SAME_BENJIN ? getMonthlyDetailForSameBenJin : getMonthlyDetail; const detail = getMonthlyDetailMethod({ firstPayMoney, loanMoney, loanRate, loanYears, startTime, curTime, aheadPayTime, aheadPayMoney, payType, }); return { firstPayRate, firstPayMoney, loanRate, loanYears, aheadPayMoney, startTime, houseAmount, loanMoney, curTime, aheadPayTime, ...detail, }; }, }, mounted() { const loanTableDiv = this.$refs.loanTable; const onlyHeaderTable = this.$refs.onlyHeaderTable; if (onlyHeaderTable) { const headerTableHeight = onlyHeaderTable.offsetHeight; this.headerTableHeight = headerTableHeight; const observer = new ResizeObserver(() => { const headerTableHeight = onlyHeaderTable.offsetHeight; console.log(\"🚀 ~ observer ~ headerTableHeight:\", headerTableHeight) this.headerTableHeight = headerTableHeight; }); observer.observe(onlyHeaderTable); } const callback = throttle(() => { const scrollLeft = loanTableDiv.scrollLeft; if (scrollLeft !== this.scrollLeft) { this.scrollLeft = scrollLeft; } }, 100); if (loanTableDiv) { loanTableDiv.addEventListener(\"scroll\", callback); } }, }); console.log('myapp data::', window.myapp.$data)"}]