[{"title":"pnpm 使用教程","path":"/2024/03/05/pnpm-使用教程/","content":"workspace初始化 monorepo 项目结构1234567891011121314151617181920# 创建root projectmkdir mono-projectcd mono-projectpnpm init# 创建 workspace 配置文件# pnpm-workspace.yamlpackages: - &quot;examples/*&quot; - &quot;shares/*&quot;mkdir -p examples/appmkdir -p shares/down-clicd examples/apppnpm initcd shares/down-clipnpm init 配置子项目的package.json文件, app 依赖 down-cli app&#x2F;package.json 配置如下 12345678910&#123; &quot;name&quot;: &quot;app&quot;, &quot;scripts&quot;: &#123; &quot;down&quot;: &quot;down --help&quot;, &quot;hi&quot;: &quot;echo app hello&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;down-cli&quot;: &quot;workspace:*&quot; &#125;&#125; down-cli&#x2F;package.json 配置如下: 123456789&#123; &quot;name&quot;: &quot;down-cli&quot;, &quot;scripts&quot;: &#123; &quot;hi&quot;: &quot;echo down hello&quot; &#125;, &quot;bin&quot;: &#123; &quot;down&quot;: &quot;bin/index.js&quot; &#125;&#125; down-cli&#x2F;bin&#x2F;index.js 12#!/usr/bin/env nodeconsole.log(&quot;down command starting..&quot;); 安装依赖在 root project 下面执行 pnpm i, pnpm 会自动安装依赖，子项目间的相互依赖会 link 到对应项目的 node_modules 文件夹下. 比如, 以上的项目结构，app/node_modules/down-cli 会软链接到 down-cli/bin/index.js 执行子项目的命令配置 root project 的 npm scripts 执行指定子项目的命令 mono-project/package.json 12345678&#123; &quot;name&quot;: &quot;mono-project&quot;, &quot;scripts&quot;: &#123; &quot;app-hi&quot;: &quot;pnpm run --filter app hi&quot;, &quot;app-hi2&quot;: &quot;pnpm run --filter ./examples/* hi&quot;, &quot;down&quot;: &quot;pnpm --filter app down&quot; &#125;&#125; 更多 --filter 参数的用法可查帮助信息 pnpm help run 在 root project 下执行, pnpm down 可测试子项目的命令，实现脚本工具(down-cli)的开发调试","tags":["pnpm","monorepo"]},{"title":"Linux 基础教程","path":"/2024/02/26/Linux-基础教程/","content":"简介Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。 Linux 的发行版Linux 的发行版简单说就是 linux 内核和应用软件的打包目前市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、TurboLinux、BluePoint、RedFlag、Xterm、SlackWare 等。 系统启动过程 内核引导BIOS 自检，由设置的启动设备启动，操作系统接管硬件，读&#x2F;boot 目录的内核文件 运行 init 进程读取配置 &#x2F;etc&#x2F;inittab 运行级别许多程序需要开机启动。它们在 Windows 叫做”服务”（service），在 Linux 就叫做”守护进程”（daemon）。不同的场合需要启动不同的程序，所以就有了运行级别 init 进程的一大任务，就是去运行这些开机启动的程序。 Linux 系统有 7 个运行级别(runlevel)： + 运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动 + 运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆 + 运行级别2：多用户状态(没有NFS) + 运行级别3：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式 + 运行级别4：系统未使用，保留 + 运行级别5：X11控制台，登陆后进入图形GUI模式 + 运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动 系统初始化真正的 rc 启动脚本，放在 init.d 目录，它们有类似的用法，一般都能接受 start, stop, restart, status等参数&#x2F;etc&#x2F;rc5.d 中的 rc 脚本，通常都是 K 或 S 开头的链接文件，S 开头则用start参数运行, K 开头的则用stop参数运行 建立终端rc 脚本执行完后，init 会接着打开 6 个终端, 以便用户登录 用户登录用户有三种登录方式: 命令行登录 ssh 登录 图形界面登录 运行级别为 5，登录后进入 KDE Gnome 等窗口管理器 终端切换ctrl+alt+F1-F6 切换终端 1-6, ctrl+alt+F7返回图形界面 linux 关机正确的关机流程: sync &gt; shutdown &gt; reboot &gt; halt关机指令 shutdown, man shutdown 查看帮助 12345678910shutdown -h 1 &#x27;machine will shutdown in 1 minute&#x27; # -h haltshutdown now # 马上关机shutdown -r now # 马上重启 同 rebootshutdown -r +5 # 5分钟后重启shutdown -h 20:24 # 某时间点关机shutdown -h now # 马上关机 同 haltshutdown -c # 取消定时关机poweroff # 关机init 0 # 关机init 6 # 重启 shutdown 和 halt 的区别halt 执行时﹐杀死应用进程﹐执行 sync 系统调用﹐文件系统写操作完成后就会停止内核，要手动关闭电源shutdown 会停止应用进程 卸载文件系统 然后关闭电源 linux 系统目录结构 /binbin 是 binary 的缩写，该目录存放最常用的命令 /boot存放启动 linux 时用到的核心文件 /devdev 是 device 的缩写, 存放外部设备 linux 中访问设备的方式和访问文件相同 /etc存放系统的配置文件 /home用户的主目录，每个用户都有自己的主目录 通常和用户名同名 /lib存放系统的动态链接共享库, 类似于 windows 中的 dll 文件,几乎所有应用程序都需要这些共享库 /lost+found一般为空，非法关机后，会存放一些文件 /media把识别的媒体设备挂载到该目录 /mnt用户挂载的其他文件系统 /opt存放额外安装的软件 /proc该目录是虚拟目录，是系统内存的映射，可以从中获取系统信息, 可直接修改里面的某些文件 /root超级管理员的主目录 /sbin存放系统管理相关的程序 selinuxRedhat&#x2F;CentOS 特有的，安全相关的文件 /srv存放服务启动后需提取的数据 /sys内核设备树的直观反映，创建内核对象时，会在这里新增对应的文件 /tmp存放临时文件 usr非常重要的目录，用户的程序和文件都放这里，类似 windows 的 program files 文件夹 usr/bin普通用户使用的程序 /usr/sbin超级管理员使用的程序 /usr/src存放源码的目录 /var存放经常被修改的文件，如 日志 /run临时文件系统，存储系统启动以来的信息。系统重启时，会清空 忘记密码的解决办法: 单用户模式 或 rescue 模式 linux 远程登录window 下远程登录客户端有 secureCRT, Putty, SSH Secure Shell, Xshell等 linux 文件基本属性123ls -al # 长列表格式 显示所有文件 包括 . ..ls -R # 递归地显示子目录内容ll # 同 ls -l 文件类型|属主权限|属组权限|其他用户的权限 文件类型: d 文件夹 - 文件 l 链接文件 b 二进制文件&#x2F;可执行文件&#x2F;接口设备 c 字符文件&#x2F;串行端口设备 文件归属 文件属主 文件所有者 文件属组 所有者的同组用户 其他用户 文件所有者,文件所有组和其他用户的权限。 对于 root 用户来说，一般情况下，文件的权限对其不起作用。 123456789101112131415161718192021222324252627282930cat /etc/group | sort # 查看用户组 (sort表示按字母排序) group_name:passwd:GID:user_list (passwd 为 x 表示加密)cat /etc/passwd | sort # 查看用户信息 user_name:passwd:uid:gid:group_name:home_dir:default_shellcat /etc/gshadow # 用户组的密码文件 group_name:passwd 密码是加密的cat /etc/shadow # 用户的密码文件 user_name:passwdwhoami # 查看当前登录用户groups &lt;user&gt; # 查看当前登录用户/指定用户 属于哪些组 如 groups rootls /etc/sudoers.d #sudo用户列表# 不同用户有不同权限 若没有x权限不能打开目录sudo adduser test # 创建用户test# sudo deluser test --remove-home 删除用户和用户的主目录cd /optmkdir myfolderll # 查看chown pan myfolder # 修改所有者为panchmod g-x,o-x myfolder # 同组和其他组的用户 取消执行权限su test # 切换到test用户cd myfolder # test用户没有myfolder的执行权限 所以打不开文件夹alias # 查看别名su - &lt;user&gt; # 切换用户 工作目录也切换到目标用户的home目录su &lt;user&gt; # 只切换用户tar -cvzf demo.tgz demoDir # 压缩文件夹tar -zxvf demo.tar.gz -C /home/pan # 解压到指定路径下(该路径需要真实存在)tar -tvf demo.tar # 查看压缩包内容 更改文件属性chgrp 更改文件属组 12# chgrp [-R] 属组名 文件名chgrp pan tmpdir chown 更改文件所有者，也可同时属组 123# chown [–R] 属主名 文件名# chown [-R] 属主名:属组名 文件名chown test:test tmpdir chmod 更改文件权限Linux 文件属性有两种设置方法，一种是数字，一种是符号。 符号: a &#x3D; all u &#x3D; user 所有者 g &#x3D; group o &#x3D; other 12345678chmod -R 700 hello # 用数字指定权限 相对方便chmod -R u+x hello # 属主+x权限chmod -R o-x hello # 其他用户-x权限chomd -R g+w hello # 属组+w权限chmod -R a+w hello # 所有用户+w权限chmod -R u=rxw hello # 设置所有者的权限chmod -R u=rxw,g=r,o=w hello # 设置三种用户的权限 (注意逗号分隔) linux 文件和目录管理Linux 的目录结构为树状结构，最顶级的目录为根目录 &#x2F; 绝对路径 从根目录开始 /home/pan, /media/pan 相对路径 ./pan or ../pan 目录管理命令 ls 列出目录内容 cd 切换目录 pwd 显示当前目录 mkdir 创建目录 rmdir 删除空目录 rm 删除文件或目录 cp 复制文件或目录 cp -r folder folder2 复制目录要加 -r mv 移动文件或目录, 也可以用来重命名文件或目录 man ls 查看帮助文档 列出目录 123ls -a # 全部文件，连同.开头的隐藏文件ls -d # 显示目录自身，而不是目录的内容ls -l # 长格式显示文件内容，包含文件的权限、大小和修改时间等 切换目录 123456cd /root/hellocd ./foocd ~ # 用户的主目录cd # 不带参数 同上 则返回用户主目录cd - # 返回之前的目录cd .. # 上级目录 显示当前目录 123456789pwdpwd -P # 显示真实路径，而非链接文件的路径# 例子cd ~ln -s Music mp3 # 创建软链接 mp3cd mp3pwd -P 创建目录 12345678mkdir dirnamemkdir -m 711 dirname # 配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～mkdir -p path/to/you/want # 创建多层目录cd path/to/you/wanttouch hellorm -rf path/to/you/wan/*rmdir -p path/to/you/want # rmdir 不能删除非空目录 所以要先用 rm 磁盘管理 df 列出磁盘使用量df [-ahHikmT] [目录或文件名] -a：列出所有的文件系统，包括系统特有的 &#x2F;proc 等文件系统; -k：以 KBytes 的容量显示各文件系统; -m：以 MBytes 的容量显示各文件系统; -h：以人们较易阅读的 GBytes，MBytes，KBytes 等格式自行显示; -H：以 M &#x3D; 1000K 取代 M &#x3D; 1024K 的进位方式; -T：显示文件系统类型，连同该分区的文件系统名称（例如 ext3）也列出; -i：不用硬盘容量，而以 inode 的数量来显示 du 查看文件&#x2F;目录的使用空间du [-ahskm] [文件或目录] -a：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。 -h：以人们较易读的容量格式（G &#x2F; M）显示; -s：列出总量而已，而不列出每个各别的目录占用容量; -S：不包括子目录下的总计(当前目录下文件的总大小)，与-s 有点差别。 -k：以 KBytes 列出容量显示; -m：以 MBytes 列出容量显示; 直接输入 du 没有加任何选项时，则 du 会分析当前所在目录的文件与目录所占用的硬盘空间。 fdisk 分区工具fdisk -l 【设备] 显示指定设备&#x2F;当前目录所在设备的分区信息fdisk /dev/sda1 对指定设备分区, (q 退出，w 保存) mkfs 分区格式化mkfs -t 文件系统类型 设备， 例如： mkfs -t mkfs.ext4 &#x2F;dev&#x2F;sda2 fsck 文件系统检查若系统掉电或磁盘发生问题，可用 fsck 进行检查, 详细用法见 fsck -h 磁盘挂载(mount)或卸载(umount)mount -L label -t 文件系统类型 挂载点 umount -fn 设备文件名或挂载点 定时任务crontab 命令(cron table)，它是 cron 的配置文件，也可以叫它作业列表，我们可以在以下文件夹内找到相关配置文件。 &#x2F;var&#x2F;spool&#x2F;cron&#x2F; 目录下存放的是每个用户包括 root 的 crontab 任务，每个任务以创建者的名字命名 &#x2F;etc&#x2F;crontab 这个文件负责调度各种管理和维护任务。 &#x2F;etc&#x2F;cron.d&#x2F; 这个目录用来存放任何要执行的 crontab 文件或脚本。 我们还可以把脚本放在&#x2F;etc&#x2F;cron.hourly、&#x2F;etc&#x2F;cron.daily、&#x2F;etc&#x2F;cron.weekly、&#x2F;etc&#x2F;cron.monthly 目录中，让它每小时&#x2F;天&#x2F;星期、月执行一次。 123456789101112131415161718192021222324252627282930313233343536373839crontab [-u username] # 省略用户 表示操作当前用户的crontab -e (编辑工作表) -l (列出工作表里的命令) -r (删除工作作)crontab -e # 编辑定时任务# 语法分 时 日 月 周 cmd# 例子# 每1分钟执行一次myCommand# 默认不支持秒级别执行频率* * * * * myCommand# 每小时的第3和第15分钟执行3,15 * * * * myCommand# 在上午8点到11点的第3和第15分钟执行3,15 8-11 * * * myCommand# 每隔两天的上午8点到11点的第3和第15分钟执行# * == */1 执行30次 每天1次 , 而 */2 代表 12次，每2天执行1次3,15 8-11 */2 * * myCommand# 每周一上午8点到11点的第3和第15分钟执行3,15 8-11 * * 1 myCommand# 每晚的21:30重启smb30 21 * * * /etc/init.d/smb restart# 每月1、10、22日的4 : 45重启smb45 4 1,10,22 * * /etc/init.d/smb restart# 每周六、周日的1 : 10重启smb10 1 * * 6,0 /etc/init.d/smb restart# 每天18 : 00至23 : 00之间每隔30分钟重启smb0,30 18-23 * * * /etc/init.d/smb restart# 每星期六的晚上11 : 00 pm重启smb0 23 * * 6 /etc/init.d/smb restart# 每一小时重启smb* */1 * * * /etc/init.d/smb restart# 晚上11点到早上7点之间，每隔一小时重启smb* 23-7/1 * * * /etc/init.d/smb restart 常用命令12345678type curl # 查看命令的类型 *可以用来确认有没有这个命令*type echotype ifconfigwhich mongo # 查看应用安装在哪里whereis mongo linux 后台运行和关闭、查看后台任务","tags":["Linux"]},{"title":"SQL 零基础入门图文教程","path":"/2024/02/26/SQL-零基础入门图文教程/","content":"原文地址❤️ SQL 零基础入门图文教程！ - 掘金 本文已参与「掘力星计划」，赢取创作大礼包，挑战创作激励金。 📚 前言SQL 语言有 40 多年的历史，从它被应用至今几乎无处不在。我们消费的每一笔支付记录，收集的每一条用户信息，发出去的每一条消息，都会使用数据库或与其相关的产品来存储，而操纵数据库的语言正是 SQL ！ SQL 对于现在的互联网公司生产研发等岗位几乎是一个必备技能，如果不会 SQL 的话，可能什么都做不了。你可以把 SQL 当做是一种工具，利用它可以帮助你完成你的工作，创造价值。 文章结尾有 SQL 小测验哦！看看你能得几分？ 👉🏻 点我跳转到 SQL 测验！🌴 SQL 介绍🌼 什么是 SQLSQL 是用于访问和处理数据库的标准的计算机语言。 SQL 指结构化查询语言 SQL 使我们有能力访问数据库 SQL 是一种 ANSI 的标准计算机语言 SQL 可与数据库程序协同工作，比如 MS Access、DB2、Informix、MS SQL Server、Oracle、Sybase 以及其他数据库系统。但是由于各种各样的数据库出现，导致很多不同版本的 SQL 语言，为了与 ANSI 标准相兼容，它们必须以相似的方式共同地来支持一些主要的关键词（比如 SELECT、UPDATE、DELETE、INSERT、WHERE 等等），这些就是我们要学习的 SQL 基础。 🌀 SQL 的类型可以把 SQL 分为两个部分：数据操作语言 (DML) 和 数据定义语言 (DDL)。 数据查询语言（DQL: Data Query Language） 数据操纵语言（DML：Data Manipulation Language） 🌵 学习 SQL 的作用SQL 是一门 ANSI 的标准计算机语言，用来访问和操作数据库系统。SQL 语句用于取回和更新数据库中的数据。 SQL 面向数据库执行查询 SQL 可从数据库取回数据 SQL 可在数据库中插入新的记录 SQL 可更新数据库中的数据 SQL 可从数据库删除记录 SQL 可创建新数据库 SQL 可在数据库中创建新表 SQL 可在数据库中创建存储过程 SQL 可在数据库中创建视图 SQL 可以设置表、存储过程和视图的权限 🍄 数据库是什么顾名思义，你可以理解为数据库是用来存放数据的一个容器。 打个比方，每个人家里都会有冰箱，冰箱是用来干什么的？冰箱是用来存放食物的地方。 同样的，数据库是存放数据的地方。正是因为有了数据库后，我们可以直接查找数据。例如你每天使用余额宝查看自己的账户收益，就是从数据库读取数据后给你的。 最常见的数据库类型是关系型数据库管理系统（RDBMS）： RDBMS 是 SQL 的基础，同样也是所有现代数据库系统的基础，比如 MS SQL Server, IBM DB2, Oracle, MySQL 以及 Microsoft Access 等等。 RDBMS 中的数据存储在被称为表（tables）的数据库对象中。表 是相关的数据项的集合，它由列和行组成。 由于本文主要讲解 SQL 基础，因此对数据库不做过多解释，只需要大概了解即可。咱们直接开始学习 SQL！ 🐥 SQL 基础语言学习在了解 SQL 基础语句使用之前，我们先讲一下 表 是什么？ 一个数据库通常包含一个或多个表。每个表由一个名字标识（例如“客户”或者“订单”）。表包含带有数据的记录(行)。 下面的例子是一个名为 “Persons” 的表： Id LastName FirstName Address City 1 Adams John Oxford Street London 2 Bush George Fifth Avenue New York 3 Carter Thomas Changan Street Beijing 上面的表包含三条记录（每一条对应一个人）和五个列（Id、姓、名、地址和城市）。 有表才能查询，那么如何创建这样一个表？ 🐤 CREATE TABLE – 创建表CREATE TABLE 语句用于创建数据库中的表。 语法： 1234567CREATE TABLE 表名称(列名称1 数据类型,列名称2 数据类型,列名称3 数据类型,....); 数据类型（data_type）规定了列可容纳何种数据类型。下面的表格包含了 SQL 中最常用的数据类型： 数据类型 描述 integer(size),int(size),smallint(size),tinyint(size) 仅容纳整数、在括号内规定数字的最大位数 decimal(size,d),numeric(size,d) 容纳带有小数的数字、”size” 规定数字的最大位数、”d” 规定小数点右侧的最大位数 char(size) 容纳固定长度的字符串（可容纳字母、数字以及特殊字符）、在括号中规定字符串的长度 varchar(size) 容纳可变长度的字符串（可容纳字母、数字以及特殊的字符）、在括号中规定字符串的最大长度 date(yyyymmdd) 容纳日期 实例： 本例演示如何创建名为 “Persons” 的表。 该表包含 5 个列，列名分别是：”Id_P”、”LastName”、”FirstName”、”Address” 以及 “City”： 12345678CREATE TABLE Persons(Id_P int,LastName varchar(255),FirstName varchar(255),Address varchar(255),City varchar(255)); Id_P 列的数据类型是 int，包含整数。其余 4 列的数据类型是 varchar，最大长度为 255 个字符。 空的 “Persons” 表类似这样： 可使用 INSERT INTO 语句向空表写入数据。 🐑 INSERT – 插入数据INSERT INTO 语句用于向表格中插入新的行。 语法： 1INSERT INTO 表名称 VALUES (值1, 值2,....); 我们也可以指定所要插入数据的列： 1INSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....); 实例： 本例演示 “Persons” 表插入记录的两种方式： 1、插入新的行 1INSERT INTO Persons VALUES (1, &#x27;Gates&#x27;, &#x27;Bill&#x27;, &#x27;Xuanwumen 10&#x27;, &#x27;Beijing&#x27;); 2、在指定的列中插入数据 1INSERT INTO Persons (LastName, Address) VALUES (&#x27;Wilson&#x27;, &#x27;Champs-Elysees&#x27;); 插入成功后，数据如下： 这个数据插入之后，是通过 SELECT 语句进行查询出来的，别急马上讲！ 🐼 SELECT – 查询数据SELECT 语句用于从表中选取数据，结果被存储在一个结果表中（称为结果集）。 语法： 1SELECT * FROM 表名称; 我们也可以指定所要查询数据的列： 1SELECT 列名称 FROM 表名称; 📢 注意： SQL 语句对大小写不敏感，SELECT 等效于 select。 实例： SQL SELECT * 实例： 1SELECT * FROM Persons; 📢 注意： 星号（*）是选取所有列的快捷方式。 如需获取名为 “LastName” 和 “FirstName” 的列的内容（从名为 “Persons” 的数据库表），请使用类似这样的 SELECT 语句： 1SELECT LastName,FirstName FROM Persons; 🐫 DISTINCT – 去除重复值如果一张表中有多行重复数据，如何去重显示呢？可以了解下 DISTINCT 。 语法： 1SELECT DISTINCT 列名称 FROM 表名称; 实例： 如果要从 “LASTNAME” 列中选取所有的值，我们需要使用 SELECT 语句： 1SELECT LASTNAME FROM Persons; 可以发现，在结果集中，Wilson 被列出了多次。 如需从 “LASTNAME” 列中仅选取唯一不同的值，我们需要使用 SELECT DISTINCT 语句： 1SELECT DISTINCT LASTNAME FROM Persons; 通过上述查询，结果集中只显示了一列 Wilson，显然已经去除了重复列。 🐸 WHERE – 条件过滤如果需要从表中选取指定的数据，可将 WHERE 子句添加到 SELECT 语句。 语法： 1SELECT 列名称 FROM 表名称 WHERE 列 运算符 值; 下面的运算符可在 WHERE 子句中使用： 操作符 描述 = 等于 &lt;&gt; 不等于 大于 &lt; 小于 &gt;&#x3D; 大于等于 &lt;&#x3D; 小于等于 BETWEEN 在某个范围内 LIKE 搜索某种模式 📢 注意： 在某些版本的 SQL 中，操作符 &lt;&gt; 可以写为 !&#x3D;。 实例： 如果只希望选取居住在城市 “Beijing” 中的人，我们需要向 SELECT 语句添加 WHERE 子句： 1SELECT * FROM Persons WHERE City=&#x27;Beijing&#x27;; 📢 注意： SQL 使用单引号来环绕文本值（大部分数据库系统也接受双引号）。如果是数值，请不要使用引号。 🐹 AND &amp; OR – 运算符AND 和 OR 可在 WHERE 子语句中把两个或多个条件结合起来。 如果第一个条件和第二个条件都成立，则 AND 运算符显示一条记录。 如果第一个条件和第二个条件中只要有一个成立，则 OR 运算符显示一条记录。 语法： AND 运算符实例： 1SELECT * FROM 表名称 WHERE 列 运算符 值 AND 列 运算符 值; OR 运算符实例： 1SELECT * FROM 表名称 WHERE 列 运算符 值 OR 列 运算符 值; 实例： 由于 Persons 表数据太少，因此增加几条记录： 12345INSERT INTO Persons VALUES (2, &#x27;Adams&#x27;, &#x27;John&#x27;, &#x27;Oxford Street&#x27;, &#x27;London&#x27;);INSERT INTO Persons VALUES (3, &#x27;Bush&#x27;, &#x27;George&#x27;, &#x27;Fifth Avenue&#x27;, &#x27;New York&#x27;);INSERT INTO Persons VALUES (4, &#x27;Carter&#x27;, &#x27;Thomas&#x27;, &#x27;Changan Street&#x27;, &#x27;Beijing&#x27;);INSERT INTO Persons VALUES (5, &#x27;Carter&#x27;, &#x27;William&#x27;, &#x27;Xuanwumen 10&#x27;, &#x27;Beijing&#x27;);SELECT * FROM Persons; AND 运算符实例： 使用 AND 来显示所有姓为 “Carter” 并且名为 “Thomas” 的人： 1SELECT * FROM Persons WHERE FirstName=&#x27;Thomas&#x27; AND LastName=&#x27;Carter&#x27;; OR 运算符实例： 使用 OR 来显示所有姓为 “Carter” 或者名为 “Thomas” 的人： 1SELECT * FROM Persons WHERE firstname=&#x27;Thomas&#x27; OR lastname=&#x27;Carter&#x27;; 结合 AND 和 OR 运算符： 我们也可以把 AND 和 OR 结合起来（使用圆括号来组成复杂的表达式）: 1SELECT * FROM Persons WHERE (FirstName=&#x27;Thomas&#x27; OR FirstName=&#x27;William&#x27;) AND LastName=&#x27;Carter&#x27;; 🐰 ORDER BY – 排序ORDER BY 语句用于根据指定的列对结果集进行排序，默认按照升序对记录进行排序，如果您希望按照降序对记录进行排序，可以使用 DESC 关键字。 语法： 1SELECT * FROM 表名称 ORDER BY 列1,列2 DESC; 默认排序为 ASC 升序，DESC 代表降序。 实例： 以字母顺序显示 LASTNAME 名称： 1SELECT * FROM Persons ORDER BY LASTNAME; 空值（NULL）默认排序在有值行之后。 以数字顺序显示ID_P，并以字母顺序显示 LASTNAME 名称： 1SELECT * FROM Persons ORDER BY ID_P,LASTNAME; 以数字降序显示ID_P： 1SELECT * FROM Persons ORDER BY ID_P DESC; 📢 注意： 在第一列中有相同的值时，第二列是以升序排列的。如果第一列中有些值为 null 时，情况也是这样的。 🐱 UPDATE – 更新数据Update 语句用于修改表中的数据。 语法： 1UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值; 实例： 更新某一行中的一个列： 目前 Persons 表有很多字段为 null 的数据，可以通过 UPDATE 为 LASTNAME 是 “Wilson” 的人添加 FIRSTNAME： 1UPDATE Persons SET FirstName = &#x27;Fred&#x27; WHERE LastName = &#x27;Wilson&#x27;; 更新某一行中的若干列： 1UPDATE Persons SET ID_P = 6,city= &#x27;London&#x27; WHERE LastName = &#x27;Wilson&#x27;; 🐨 DELETE – 删除数据DELETE 语句用于删除表中的行。 语法： 1DELETE FROM 表名称 WHERE 列名称 = 值; 实例： 删除某行： 删除 Persons 表中 LastName 为 “Fred Wilson” 的行： 1DELETE FROM Persons WHERE LastName = &#x27;Wilson&#x27;; 删除所有行： 可以在不删除表的情况下删除所有的行。这意味着表的结构、属性和索引都是完整的： 1DELETE FROM table_name; 🐵 TRUNCATE TABLE – 清除表数据如果我们仅仅需要除去表内的数据，但并不删除表本身，那么我们该如何做呢？ 可以使用 TRUNCATE TABLE 命令（仅仅删除表格中的数据）： 语法： 1TRUNCATE TABLE 表名称; 实例： 本例演示如何删除名为 “Persons” 的表。 1TRUNCATE TABLE persons; 🐯 DROP TABLE – 删除表DROP TABLE 语句用于删除表（表的结构、属性以及索引也会被删除）。 语法： 1DROP TABLE 表名称; 实例： 本例演示如何删除名为 “Persons” 的表。 1drop table persons; 从上图可以看出，第一次执行删除时，成功删除了表 persons，第二次执行删除时，报错找不到表 persons，说明表已经被删除了。 🚀 SQL 高级言语学习🚢 LIKE – 查找类似值LIKE 操作符用于在 WHERE 子句中搜索列中的指定模式。 语法： 1SELECT 列名/(*) FROM 表名称 WHERE 列名称 LIKE 值; 实例： Persons 表插入数据： 123456INSERT INTO Persons VALUES (1, &#x27;Gates&#x27;, &#x27;Bill&#x27;, &#x27;Xuanwumen 10&#x27;, &#x27;Beijing&#x27;);INSERT INTO Persons VALUES (2, &#x27;Adams&#x27;, &#x27;John&#x27;, &#x27;Oxford Street&#x27;, &#x27;London&#x27;);INSERT INTO Persons VALUES (3, &#x27;Bush&#x27;, &#x27;George&#x27;, &#x27;Fifth Avenue&#x27;, &#x27;New York&#x27;);INSERT INTO Persons VALUES (4, &#x27;Carter&#x27;, &#x27;Thomas&#x27;, &#x27;Changan Street&#x27;, &#x27;Beijing&#x27;);INSERT INTO Persons VALUES (5, &#x27;Carter&#x27;, &#x27;William&#x27;, &#x27;Xuanwumen 10&#x27;, &#x27;Beijing&#x27;);select * from persons; 1、现在，我们希望从上面的 “Persons” 表中选取居住在以 “N” 开头的城市里的人： 1SELECT * FROM Persons WHERE City LIKE &#x27;N%&#x27;; 2、接下来，我们希望从 “Persons” 表中选取居住在以 “g” 结尾的城市里的人： 1SELECT * FROM Persons WHERE City LIKE &#x27;%g&#x27;; 3、接下来，我们希望从 “Persons” 表中选取居住在包含 “lon” 的城市里的人： 1SELECT * FROM Persons WHERE City LIKE &#x27;%on%&#x27;; 4、通过使用 NOT 关键字，我们可以从 “Persons” 表中选取居住在不包含 “lon” 的城市里的人： 1SELECT * FROM Persons WHERE City NOT LIKE &#x27;%on%&#x27;; 📢 注意： “%” 可用于定义通配符（模式中缺少的字母）。 🚤 IN – 锁定多个值IN 操作符允许我们在 WHERE 子句中规定多个值。 语法： 1SELECT 列名/(*) FROM 表名称 WHERE 列名称 IN (值1,值2,值3); 实例： 现在，我们希望从 Persons 表中选取姓氏为 Adams 和 Carter 的人： 1SELECT * FROM Persons WHERE LastName IN (&#x27;Adams&#x27;,&#x27;Carter&#x27;); ⛵️ BETWEEN – 选取区间数据操作符 BETWEEN … AND 会选取介于两个值之间的数据范围。这些值可以是数值、文本或者日期。 语法： 1SELECT 列名/(*) FROM 表名称 WHERE 列名称 BETWEEN 值1 AND 值2; 实例： 1、查询以字母顺序显示介于 “Adams”（包括）和 “Carter”（不包括）之间的人： 1SELECT * FROM Persons WHERE LastName BETWEEN &#x27;Adams&#x27; AND &#x27;Carter&#x27;; 2、查询上述结果相反的结果，可以使用 NOT： 1SELECT * FROM Persons WHERE LastName NOT BETWEEN &#x27;Adams&#x27; AND &#x27;Carter&#x27;; 📢 注意： 不同的数据库对 BETWEEN…AND 操作符的处理方式是有差异的。 某些数据库会列出介于 “Adams” 和 “Carter” 之间的人，但不包括 “Adams” 和 “Carter” ；某些数据库会列出介于 “Adams” 和 “Carter” 之间并包括 “Adams” 和 “Carter” 的人；而另一些数据库会列出介于 “Adams” 和 “Carter” 之间的人，包括 “Adams” ，但不包括 “Carter” 。 所以，请检查你的数据库是如何处理 BETWEEN….AND 操作符的！ 🚂 AS – 别名通过使用 SQL，可以为列名称和表名称指定别名（Alias），别名使查询程序更易阅读和书写。 语法： 表别名： 1SELECT 列名称/(*) FROM 表名称 AS 别名; 列别名： 1SELECT 列名称 as 别名 FROM 表名称; 实例： 使用表名称别名： 123SELECT p.LastName, p.FirstNameFROM Persons pWHERE p.LastName=&#x27;Adams&#x27; AND p.FirstName=&#x27;John&#x27;; 使用列名别名： 1SELECT LastName &quot;Family&quot;, FirstName &quot;Name&quot; FROM Persons; 📢 注意： 实际应用时，这个 AS 可以省略，但是列别名需要加上 &quot; &quot;。 🚁 JOIN – 多表关联JOIN 用于根据两个或多个表中的列之间的关系，从这些表中查询数据。 有时为了得到完整的结果，我们需要从两个或更多的表中获取结果。我们就需要执行 join。 数据库中的表可通过键将彼此联系起来。主键（Primary Key）是一个列，在这个列中的每一行的值都是唯一的。在表中，每个主键的值都是唯一的。这样做的目的是在不重复每个表中的所有数据的情况下，把表间的数据交叉捆绑在一起。 如图，”Id_P” 列是 Persons 表中的的主键。这意味着没有两行能够拥有相同的 Id_P。即使两个人的姓名完全相同，Id_P 也可以区分他们。 ❤️ 为了下面实验的继续，我们需要再创建一个表：Orders。 1234567create table orders (id_o number,orderno number,id_p number);insert into orders values(1,11111,1);insert into orders values(2,22222,2);insert into orders values(3,33333,3);insert into orders values(4,44444,4);insert into orders values(6,66666,6);select * from orders; 如图，”Id_O” 列是 Orders 表中的的主键，同时，”Orders” 表中的 “Id_P” 列用于引用 “Persons” 表中的人，而无需使用他们的确切姓名。 1select * from persons p,orders o where p.id_p=o.id_p; 可以看到，”Id_P” 列把上面的两个表联系了起来。 语法： 1234select 列名from 表AINNER|LEFT|RIGHT|FULL JOIN 表BON 表A主键列 = 表B外键列; 不同的 SQL JOIN： 下面列出了您可以使用的 JOIN 类型，以及它们之间的差异。 JOIN: 如果表中有至少一个匹配，则返回行 INNER JOIN: 内部连接，返回两表中匹配的行 LEFT JOIN: 即使右表中没有匹配，也从左表返回所有的行 RIGHT JOIN: 即使左表中没有匹配，也从右表返回所有的行 FULL JOIN: 只要其中一个表中存在匹配，就返回行 实例： 如果我们希望列出所有人的定购，可以使用下面的 SELECT 语句： 12345SELECT p.LastName, p.FirstName, o.OrderNoFROM Persons pINNER JOIN Orders oON p.Id_P = o.Id_PORDER BY p.LastName DESC; 🚜 UNION – 合并结果集UNION 操作符用于合并两个或多个 SELECT 语句的结果集。 UNION 语法： 123SELECT 列名 FROM 表AUNIONSELECT 列名 FROM 表B; 📢 注意： UNION 操作符默认为选取不同的值。如果查询结果需要显示重复的值，请使用 UNION ALL。 UNION ALL 语法： 123SELECT 列名 FROM 表AUNION ALLSELECT 列名 FROM 表B; 另外，UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。 为了实验所需，创建 Person_b 表： 1234567891011121314CREATE TABLE Persons_b(Id_P int,LastName varchar(255),FirstName varchar(255),Address varchar(255),City varchar(255));INSERT INTO Persons_b VALUES (1, &#x27;Bill&#x27;, &#x27;Gates&#x27;, &#x27;Xuanwumen 10&#x27;, &#x27;Londo&#x27;);INSERT INTO Persons_b VALUES (2, &#x27;John&#x27;, &#x27;Adams&#x27;, &#x27;Oxford Street&#x27;, &#x27;nBeijing&#x27;);INSERT INTO Persons_b VALUES (3, &#x27;George&#x27;, &#x27;Bush&#x27;, &#x27;Fifth Avenue&#x27;, &#x27;Beijing&#x27;);INSERT INTO Persons_b VALUES (4, &#x27;Thomas&#x27;, &#x27;Carter&#x27;, &#x27;Changan Street&#x27;, &#x27;New York&#x27;);INSERT INTO Persons_b VALUES (5, &#x27;William&#x27;, &#x27;Carter&#x27;, &#x27;Xuanwumen 10&#x27;, &#x27;Beijing&#x27;);select * from persons_b; 实例： 使用 UNION 命令： 列出 persons 和 persons_b 中不同的人： 123select * from personsUNIONselect * from persons_b; 📢 注意： UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。 🚌 NOT NULL – 非空NOT NULL 约束强制列不接受 NULL 值。 NOT NULL 约束强制字段始终包含值。这意味着，如果不向字段添加值，就无法插入新记录或者更新记录。 语法： 1234CREATE TABLE 表(列 int NOT NULL); 如上，创建一个表，设置列值不能为空。 实例： 12create table lucifer (id number not null);insert into lucifer values (NULL); 📢 注意： 如果插入 NULL 值，则会报错 ORA-01400 提示无法插入！ ⭐️ 拓展小知识：NOT NULL 也可以用于查询条件： 1select * from persons where FirstName is not null; 同理，NULL 也可： 1select * from persons where FirstName is null; 感兴趣的朋友，可以自己尝试一下！ 🚐 VIEW – 视图在 SQL 中，视图是基于 SQL 语句的结果集的可视化的表。 视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。我们可以向视图添加 SQL 函数、WHERE 以及 JOIN 语句，我们也可以提交数据，就像这些来自于某个单一的表。 语法： 1234CREATE VIEW 视图名 ASSELECT 列名FROM 表名WHERE 查询条件; 📢 注意： 视图总是显示最近的数据。每当用户查询视图时，数据库引擎通过使用 SQL 语句来重建数据。 实例： 下面，我们将 Persons 表中住在 Beijing 的人筛选出来创建视图： 12create view persons_beijing asselect * from persons where city=&#x27;Beijing&#x27;; 查询上面这个视图： 如果需要更新视图中的列或者其他信息，无需删除，使用 CREATE OR REPLACE VIEW 选项： 1234CREATE OR REPLACE VIEW 视图名 ASSELECT 列名FROM 表名WHERE 查询条件; 实例： 现在需要筛选出，LASTNAME 为 Gates 的记录： 12create or replace view persons_beijing asselect * from persons where lastname=&#x27;Gates&#x27;; 删除视图就比较简单，跟表差不多，使用 DROP 即可： 1drop view persons_beijing; ❤️ 本章要讲的高级语言就先到此为止，不宜一次性介绍太多~ 🎯 SQL 常用函数学习SQL 拥有很多可用于计数和计算的内建函数。 函数的使用语法： 1SELECT function(列) FROM 表; ❤️ 下面就来看看有哪些常用的函数！ 🍔 AVG – 平均值AVG 函数返回数值列的平均值。NULL 值不包括在计算中。 语法： 1SELECT AVG(列名) FROM 表名; 实例： 计算 “orderno” 字段的平均值。 1select avg(orderno) from orders; 当然，也可以用在查询条件中，例如查询低于平均值的记录： 1select * from orders where orderno &lt; (select avg(orderno) from orders); 🍕 COUNT – 汇总行数COUNT() 函数返回匹配指定条件的行数。 语法： count() 中可以有不同的语法： COUNT(*) ：返回表中的记录数。 COUNT(DISTINCT 列名) ：返回指定列的不同值的数目。 COUNT(列名) ：返回指定列的值的数目（NULL 不计入）。 123SELECT COUNT(*) FROM 表名;SELECT COUNT(DISTINCT 列名) FROM 表名;SELECT COUNT(列名) FROM 表名; 实例： COUNT(*) ： 1select count(*) from persons; COUNT(DISTINCT 列名) ： 1select count(distinct city) from persons; COUNT(列名) ： 1select count(city) from persons; 🍘 MAX – 最大值MAX 函数返回一列中的最大值。NULL 值不包括在计算中。 语法： 1SELECT MAX(列名) FROM 表名; MIN 和 MAX 也可用于文本列，以获得按字母顺序排列的最高或最低值。 实例： 1select max(orderno) from orders; 🍢 MIN – 最小值MIN 函数返回一列中的最小值。NULL 值不包括在计算中。 语法： 1SELECT MIN(列名) FROM 表名; 实例： 1select min(orderno) from orders; 🍰 SUM – 求和SUM 函数返回数值列的总数（总额）。 语法： 1SELECT SUM(列名) FROM 表名; 实例： 1select sum(orderno) from orders; 🍪 GROUP BY – 分组GROUP BY 语句用于结合合计函数，根据一个或多个列对结果集进行分组。 语法： 1234SELECT 列名A, 统计函数(列名B)FROM 表名WHERE 查询条件GROUP BY 列名A; 实例： 获取 Persons 表中住在北京的总人数，根据 LASTNAME 分组： 123select lastname,count(city) from personswhere city=&#x27;Beijing&#x27;group by lastname; 如果不加 GROUP BY 则会报错： 也就是常见的 ORA-00937 不是单组分组函数的错误。 🍭 HAVING – 句尾连接在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与合计函数一起使用。 语法： 12345SELECT 列名A, 统计函数(列名B)FROM table_nameWHERE 查询条件GROUP BY 列名AHAVING 统计函数(列名B) 查询条件; 实例： 获取 Persons 表中住在北京的总人数大于 1 的 LASTNAME，根据 LASTNAME 分组： 1234select lastname,count(city) from personswhere city=&#x27;Beijing&#x27;group by lastnamehaving count(city) &gt; 1; 🍷 UCASE&#x2F;UPPER – 大写UCASE/UPPER 函数把字段的值转换为大写。 语法： 1select upper(列名) from 表名; 实例： 选取 “LastName” 和 “FirstName” 列的内容，然后把 “LastName” 列转换为大写： 1select upper(lastname),firstname from persons; 🍶 LCASE&#x2F;LOWER – 小写LCASE/LOWER 函数把字段的值转换为小写。 语法： 1select lower(列名) from 表名; 实例： 选取 “LastName” 和 “FirstName” 列的内容，然后把 “LastName” 列转换为小写： 1select lower(lastname),firstname from persons; 👛 LEN&#x2F;LENGTH – 获取长度LEN/LENGTH 函数返回文本字段中值的长度。 语法： 1select length(列名) from 表名; 实例： 获取 LASTNAME 的值字符长度： 1select length(lastname),lastname from persons; 🍗 ROUND – 数值取舍ROUND 函数用于把数值字段舍入为指定的小数位数。 语法： 1select round(列名,精度) from 表名; 实例： 保留 2 位： 12select round(1.1314,2) from dual;select round(1.1351,2) from dual; 📢 注意：ROUND 取舍是 四舍五入 的！ 取整： 12select round(1.1351,0) from dual;select round(1.56,0) from dual; 🍞 NOW&#x2F;SYSDATE – 当前时间NOW/SYSDATE 函数返回当前的日期和时间。 语法： 1select sysdate from 表名; 实例： 获取当前时间： 1select sysdate from dual; 📢 注意： 如果您在使用 Sql Server 数据库，请使用 getdate() 函数来获得当前的日期时间。 🍺 写在最后**上述如果都学完了的话，可以来做个小测验：SQL 测验**，看看掌握的怎么样！ ❤️ 测验会被记分： 每道题的分值是 1 分。在您完成全部的 20 道题之后，系统会为您的测验打分，并提供您做错的题目的正确答案。其中，绿色为正确答案，而红色为错误答案。 ☞ 现在就开始测验！ 祝您好运。 ⭐️ 将你的得分写在下方的 评论区 中吧，让我看看大家的水平如何？⭐️","tags":["SQL"]},{"title":"python 基础教程","path":"/2024/02/26/python-基础教程/","content":"python 基础教程python 教程 廖雪峰 简介python 是一种简单优雅的脚本语言，包含非常完善的基础代码库, 覆盖网络、文件、GUI、 数据库、文本等, 除了内置库以外还有大量第三方库。 python 的适用范围: 网络应用、脚本任务和其它自动化工具 安装python 是跨平台的，解释型的脚本语言(似乎脚本语言都是解释型和跨平台的)python 有 2.x 和 3.x 两个版本，较多的应用都是基于 2.x 开发的; 安装 python 就是安装 python 的解释器, 得到一个命令行交互环境. mac brew install python3 ubuntu sodu apt-get install python3 window 直接到官网下载对应安装包 安装后将 python 安装目录，添加到环境变量, 然后打开命令行，输入 python ， 进去交互环境 注意 windows 用户在 git bash 下，输入 python，不能进入到 python 交互环境, 执行 winpty python 进入交互环境 在命令行中输入 python 进入交互模式 123&gt; python&gt;&gt;&gt; print(&#x27;hello world&#x27;)&gt;&gt;&gt; exit() 执行 python 脚本文件, 命令行下python hello.py 开始菜单可以找到 python 专用 CLI python 解释器python 代码文件以.py为后缀，由 python 解释器解释执行。 python 有多种解释器: CPython 官方解释器，C 语言开发的，所以叫 CPython, 命令行下输入 python 就是进入 CPython 解释器环境 IPython 增强版的 CPython PyPy 执行速度较快 Jython 把 python 编译成 java 字节码执行 IronPython 运行在.NET 平台的 pyton 解释器 Hello World可在命令行交互环境执行，或保存为 hello.py 文件 12345678910111213&gt; python&gt;&gt;&gt;print(&#x27;hello world&#x27;)&gt;&gt;&gt;exit()&gt; python hello.py#mac 或 linux上还可直接运行 python文件，如：// hello.py#!/usr/bin/env python3print(&#x27;hello world&#x27;)&gt; chmod a+x hello.py&gt; ./hello.py 输出123print(&#x27;hello python&#x27;)print(&#x27;nice&#x27;, &#x27;to&#x27;, &#x27;meet&#x27;, &#x27;you&#x27;) # 可打印多个字符串 同 console.logprint(&#x27;100+200=&#x27;, 100+200) # 逗号分隔的每个表达式间加空格 输入123name = input(&#x27;input your name:&#x27;) # 然后输入 &#x27;sindy&#x27; python3# name = raw_input(&#x27;input your name:&#x27;) # python2print(name) 语法python 的语法比较简单: 用缩进表示代码块; 不用括号,花括号划分代码块 不用分号表示语句结束 标识符大小写敏感 声明变量不需要 var 等关键字 1234567# print absolute valuea = -120if a &gt;= 0: print(a)else: print(-a) 数据类型和变量python 的数据类型包括: 整数、浮点数、字符串、字节型、布尔值、空值、列表、字典和自定义类型 123456789101112131415161718192021222324252627282930313233343536371, 100, -80, 0xfa # 整数1.23 1.23e9, 1.2e-5 # 浮点数# 字符串 单双引号互相包含&quot;what&#x27;s your name&quot;&#x27;I\\&#x27;m &quot;OK&quot;&#x27;# raw string 内部的特殊字符都做普通字符对待r&#x27;\\the-school &#x27;# 三引号 可输出换回字符串&#x27;&#x27;&#x27;line1,line2&#x27;&#x27;&#x27;r&#x27;&#x27;&#x27;line one \\twill not escape&#x27;&#x27;&#x27;# 字节型b&#x27;ABC&#x27;len(&#x27;abc&#x27;) # 3b&#x27;hello&#x27;.decode(&#x27;ascii&#x27;)len(b&#x27;good&#x27;) #4# 布尔值True False# 逻辑运算符# and or not# 空值None# 条件判断if age &gt;= 18: print(&#x27;adult&#x27;)else: print(&#x27;teenager&#x27;) python 是弱类型(动态类型)语言 1234a = 100 # 整数print(a)a = &#x27;hello&#x27; # 字符串print(a) python 中常量习惯用全大些字母表示, 如 PI=3.1415, 并非真正意义的常量(同 JS) python 的两种除法： 1234567print(10 / 3) #3.33.. 普通除法 结果为浮点数print(10 // 3) #3 地板除 结果为整数 整除(有小数 则向下取整) 结果为整数print(20 / 3)print(20 // 3) #6print(9 / 3) #3.0 /除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数：print(10 % 3) #1 模运算，取余数 python 的整数和浮点数没有大小限制 字符串和编码字符编码因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用 8 个比特（bit）作为一个字节（byte） ASCII 1 个字节，最大 255 由于计算机是美国人发明的，因此，最早只有 127 个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为 ASCII 编码，比如大写字母 A 的编码是 65，小写字母 z 的编码是 122 GB2312 处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和 ASCII 编码冲突，所以，中国制定了 GB2312 编码，用来把中文编进去 Unicode 最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要 4 个字节） 全世界有上百种语言，日本把日文编到 Shift_JIS 里，韩国把韩文编到 Euc-kr 里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码 因此，Unicode 应运而生。Unicode 把所有语言都统一到一套编码里，这样就不会再有乱码问题了 UTF-8 用于存储和传输 英文 1 个字节 中文 3 个字节 统一成 Unicode 编码，解决了乱码问题；但是，如果你写的文本基本上全部是英文的话，用 Unicode 编码比 ASCII 编码需要多一倍的存储空间，在存储和传输上就十分不划算。所以，本着节约的精神，又出现了把 Unicode 编码转化为“可变长编码”的 UTF-8 编码。UTF-8 编码把一个 Unicode 字符根据不同的数字大小编码成 1-6 个字节，常用的英文字母被编码成 1 个字节，汉字通常是 3 个字节，只有很生僻的字符才会被编码成 4-6 个字节。如果你要传输的文本包含大量英文字符，用 UTF-8 编码就能节省空间： 在计算机内存中，统一使用 Unicode 编码，当需要保存到硬盘或者需要传输的时候，就转换为 UTF-8 编码。 用记事本编辑的时候，从文件读取的 UTF-8 字符被转换为 Unicode 字符到内存里，编辑完成后，保存的时候再把 Unicode 转换为 UTF-8 保存到文件 浏览网页的时候，服务器会把动态生成的 Unicode 内容转换为 UTF-8 再传输到浏览器, 所以你看到很多网页的源码上会有类似&lt;meta charset=&quot;UTF-8&quot; /&gt;的信息，表示该网页正是用的 UTF-8 编码。 Python 的字符串在最新的 Python 3 版本中，字符串是以 Unicode 编码的，也就是说，Python 的字符串支持多语言 12345print(&#x27;包含中文的str&#x27;)print(ord(&#x27;A&#x27;)) # 字符对应的编码print(chr(66)) # 编码对应的字符# 知道字符的编码，可用十六进制 输出字符print(&#x27;\\u4e2d\\u6587&#x27;) 由于 Python 的字符串，在内存中以 Unicode 表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把 str 变为以字节为单位的 bytes 用带 b 前缀的单引号或双引号表示bytes类型 12strVal = &#x27;Hello&#x27;byteVal = b&#x27;Hello&#x27; # bytes的每个字符都只占用一个字节。 以 Unicode 表示的 str 通过 encode()方法可以编码为指定的 bytes 123print(&#x27;ABC&#x27;.encode(&#x27;ascii&#x27;)) # b&#x27;ABC&#x27;print(&#x27;中文&#x27;.encode(&#x27;utf-8&#x27;)) # b&#x27;\\xe4\\xb8\\xad\\xe6\\x96\\x87&#x27;&#x27;中文&#x27;.encode(&#x27;ascii&#x27;) # 报错 中文不能编码为ascii的bytes 反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是 bytes。要把 bytes 变为 str，就需要用 decode()方法： 123456&gt;&gt;&gt; b&#x27;ABC&#x27;.decode(&#x27;ascii&#x27;)&#x27;ABC&#x27;&gt;&gt;&gt; b&#x27;\\xe4\\xb8\\xad\\xe6\\x96\\x87&#x27;.decode(&#x27;utf-8&#x27;)&#x27;中文&#x27;&gt;&gt;&gt; b&#x27;\\xe4\\xb8\\xad\\xff&#x27;.decode(&#x27;utf-8&#x27;, errors=&#x27;ignore&#x27;) # 忽略错误的字节 len()函数计算的是 str 的字符数，不是字符串占用的字节数，如果换成 bytes，len()函数就计算字节数 12345678910&gt;&gt;&gt; len(&#x27;ABC&#x27;)3&gt;&gt;&gt; len(&#x27;中文&#x27;)2&gt;&gt;&gt; len(b&#x27;ABC&#x27;)3&gt;&gt;&gt; len(b&#x27;\\xe4\\xb8\\xad\\xe6\\x96\\x87&#x27;)6&gt;&gt;&gt; len(&#x27;中文&#x27;.encode(&#x27;utf-8&#x27;))6 可见，1 个中文字符经过 UTF-8 编码后通常会占用 3 个字节，而 1 个英文字符只占用 1 个字节 由于 Python 源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为 UTF-8 编码。当 Python 解释器读取源代码时，为了让它按 UTF-8 编码读取，我们通常在文件开头写上这两行： 123#!/usr/bin/env python3 ## 告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；# -*- coding: utf-8 -*- ## 告诉Python解释器，按照UTF-8编码读取源代码 格式化字符串%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。 在 Python 中，采用的格式化方式和 C 语言是一致的，用%实现 常见的占位符有： 占位符 替换内容 %d 整数 %f 浮点数 %s 字符串 %x 十六进制整数 123456789101112131415161718192021# %d 整数 %f浮点数 %g 整数或科学计数法显示print(&#x27;Hello, %s&#x27; % &#x27;world&#x27;)# 多个变量占位 值用列表print(&#x27;Hi %s, you have spent $%d&#x27; % （&#x27;sindy&#x27;, 1000))print(&#x27;normal number: %g&#x27; % 123)print(&#x27;big number: %g&#x27; % 1234567)print(&#x27;float number: %f&#x27; % 12.2235)print(&#x27;float number: %.2f&#x27; % 12.2225)print(&#x27;float number: %+.2f&#x27; % -12.6135)print(&#x27;float number: % .2f&#x27; % 12.5685)print(&#x27;%2d-%02d&#x27; % (3, 1))print(&#x27;%.2f&#x27; % 3.1415926)# 不太确定应该用什么占位符，%s永远起作用，它会把任何数据类型转换为字符串print(&#x27;Age: %s. Gender: %s&#x27; % (25, True))# 转义，用%%来表示一个%print(&#x27;growth rate: %d %%&#x27; % 7) format()它会用传入的参数依次替换字符串内的占位符{0}、{1}…… 1&gt;&gt;&gt; &#x27;Hello, &#123;0&#125;, 成绩提升了 &#123;1:.1f&#125;%&#x27;.format(&#x27;小明&#x27;, 17.125) 列表(list)和元组(tuple)列表是元素的有序集合，可增删元素 等同 js 的数组, 且元素不要求数据类型相同 1234567891011121314151617181920roles = [&#x27;nami&#x27;, &#x27;zoro&#x27;, &#x27;lufy&#x27;]print(roles)len(roles) # 3roles[10] # 索引越界会报错 IndexErrorroles[-1] # 最后一个元素roles.append(&#x27;robin&#x27;) # 在末尾追加元素print(roles)roles.insert(1, &#x27;sandge&#x27;) # 在指定位置插入元素print(roles)print(roles.pop()) # 删除末尾元素print(roles)print(roles.pop(1)) # 删除指定位置元素print(roles)roles[1] = &#x27;jobar&#x27; # 修改元素print(roles)langs = [&#x27;python&#x27;, &#x27;java&#x27;, [&#x27;asp&#x27;, &#x27;php&#x27;], &#x27;scheme&#x27;] # 二维数组 tuple 和 list 很相似，不过元组的元素是不可修改的, 所以元组没有append(), insert()之类的方法 123456colors = (&#x27;yellow&#x27;, &#x27;green&#x27;, &#x27;red&#x27;)colors2 = () # 空元组nums = (1,) # 只有1个数字的元组，nums = (1) 括号会被认为是数字求值， 所以要加个,friends = (&#x27;idle&#x27;, &#x27;sandy&#x27;, [&#x27;lucy&#x27;, 8])friends[2][1] = 18print(friends) # 复合数据类型可修改 条件判断1234567891011121314151617age = 3if age &gt;= 18: print(&#x27;your age is&#x27;, age) print(&#x27;adult&#x27;)elif age &gt;= 6: print(&#x27;teenager&#x27;)else: print(&#x27;your age is&#x27;, age) print(&#x27;kid&#x27;)s = input(&#x27;birth: &#x27;)birth = int(s) # 转换为数值型if birth &lt; 2000: print(&#x27;00前&#x27;)else: print(&#x27;00后&#x27;) 循环12345678910111213141516171819202122232425262728293031names = [&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;]for name in names: print(name)for i in range(10): print(i)sum = 0n = 99while n &gt; 0: sum = sum + n n = n - 2print(sum)n = 1while n &lt;= 100: if n &gt; 10: # 当n = 11时，条件满足，执行break语句 break # break语句会结束当前循环 print(n) n = n + 1print(&#x27;END&#x27;)n = 0while n &lt; 10: n = n + 1 if n % 2 == 0: # 如果n是偶数，执行continue语句 continue # continue语句会直接继续下一轮循环，后续的print()语句不会执行 print(n) 字典 dictdict 全称 dictionary，在其他语言中也称为 map，使用键-值（key-value）存储，具有极快的查找速度。 同 js 的对象 1234567891011role = &#123;&#x27;name&#x27;: &#x27;rufy&#x27;, &#x27;age&#x27;: 18, &#x27;skill&#x27;: &#x27;stretch&#x27;&#125; # 属性名的引号不能省略role[&#x27;age&#x27;] = 19# role.age = 20 这样修改属性值报错 :(print(role)if(&#x27;age&#x27; in role): print(&#x27;yes&#x27;)role.get(&#x27;age&#x27;) # 若没有age字段 返回Nonerole.get(&#x27;age&#x27;, 10) # 没有age字段 返回默认值 在 Python 代码中几乎无处不在，正确使用 dict 非常重要，需要牢记的第一条就是 dict 的 key 必须是不可变对象。 这是因为 dict 根据 key 来计算 value 的存储位置，如果每次计算相同的 key 得出的结果不同，那 dict 内部就完全混乱了。这个通过 key 计算位置的算法称为哈希算法（Hash）。 要保证 hash 的正确性，作为 key 的对象就不能变。在 Python 中，字符串、整数等都是不可变的，因此，可以放心地作为 key。而 list 是可变的，就不能作为 key 集合 setset 是无序不重复的元素集合 1234567s = set([1,2,3])print(s) # &#123;1, 2, 3&#125;s.add(4) # 添加元素s2 = set([3,4,5])print(s &amp; s2) # 交集print(s | s2) # 并集 set 和 dict 的唯一区别仅在于没有存储对应的 value，但是，set 的原理和 dict 一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证 set 内部“不会有重复元素”。试试把 list 放入 set，看看是否会报错。 函数Python 内置了很多有用的函数，我们可以直接调用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119&gt;&gt;&gt;help(abs) # 查看函数帮助abs(-120)abs(-1, 2) # 入参数量不对 会报错abs(&#x27;ABC&#x27;) # 入参类型不对 会报错min(1,2)max(2,3) # min max不限定参数个数# 数据类型转换int(&#x27;12&#x27;)float(&#x27;12.33&#x27;)str(100)bool(1)bool(&#x27;&#x27;)hex(100)# 函数定义def myabs(x): if x &gt;= 0: return x else: return -xdef my_abs2(x): # 参数类型检查 if not isinstance(x, (int, float)): raise TypeError(&#x27;bad operand type&#x27;) if x &gt;= 0: return x else: return -xmyabs(-9) # 函数调用# 空函数def noop(): pass # pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来# 返回多个值import mathdef move(x, y, step, angle=0): nx = x + step * math.cos(angle) ny = y - step * math.sin(angle) return nx, ny # 实际返回的是一个tuplex, y = move(100, 100, 60, math.pi / 6) # 解构赋值print(x, y)r = move(100, 100, 60, math.pi / 6)print(r)# 位置参数 x n , 参数默认值def power(x, n = 2): s = 1 while n &gt; 0: n = n - 1 s = s * x return sdef enroll(name, gender, age=6, city=&#x27;Beijing&#x27;): print(&#x27;name:&#x27;, name) print(&#x27;gender:&#x27;, gender) print(&#x27;age:&#x27;, age) print(&#x27;city:&#x27;, city)# 多个默认参数 用参数名只指定某个参数值enroll(&#x27;Adam&#x27;, &#x27;M&#x27;, city=&#x27;Tianjin&#x27;)# 默认参数必须是不可变对象，不然容易掉坑def add_end(L=[]): L.append(&#x27;END&#x27;) return Ladd_end()add_end() # [&#x27;END&#x27;, &#x27;END&#x27;] 每次调用时，默认参数指向的地址不变# 可变参数 参数个数可变def calc(*numbers): sum = 0 for n in numbers: sum = sum + n * n return sumcalc(1,2) # 参数会被自动组装为tuplecalc()# tuple 或 list 展开作为可变参数传入nums = [1,2,3]calc(*nums)# 关键字参数 类似js函数的optionsdef person(name, age, **kw): print(&#x27;name:&#x27;, name, &#x27;age:&#x27;, age, &#x27;other:&#x27;, kw)person(&#x27;Adam&#x27;, 45, gender=&#x27;M&#x27;, job=&#x27;Engineer&#x27;) # 关键字参数会被组装为dict对象kw# dict展开作为关键字参数传入extra = &#123;&#x27;city&#x27;: &#x27;Beijing&#x27;, &#x27;job&#x27;: &#x27;Engineer&#x27;&#125;person(&#x27;Jack&#x27;, 24, **extra)# 命名关键字参数，约束关键字参数只能包含指定字段# 组装成dict, 函数内部再解构为字段同名的变量def person(name, age, *, city, job): print(name, age, city, job)person(&#x27;jack&#x27;, 23, job=&#x27;worker&#x27;, city=&#x27;beijing&#x27;)# 如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了def person2(name, age, *args, city, job): print(name, age, args, city, job)person2(&#x27;jack&#x27;, 12, &#x27;hello&#x27;, &#x27;world&#x27;, city=&#x27;beijing&#x27;, job=&#x27;accounting&#x27;)# 命名关键字参数可以有缺省值def person(name, age, *, city=&#x27;Beijing&#x27;, job): print(name, age, city, job)person(&#x27;Jack&#x27;, 24, job=&#x27;Engineer&#x27;) 参数组合在 Python 中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这 5 种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。 123456789101112131415161718192021222324252627def f1(a, b, c=0, *args, **kw): print(&#x27;a =&#x27;, a, &#x27;b =&#x27;, b, &#x27;c =&#x27;, c, &#x27;args =&#x27;, args, &#x27;kw =&#x27;, kw)def f2(a, b, c=0, *, d, **kw): print(&#x27;a =&#x27;, a, &#x27;b =&#x27;, b, &#x27;c =&#x27;, c, &#x27;d =&#x27;, d, &#x27;kw =&#x27;, kw)&gt;&gt;&gt; f1(1, 2)a = 1 b = 2 c = 0 args = () kw = &#123;&#125;&gt;&gt;&gt; f1(1, 2, c=3)a = 1 b = 2 c = 3 args = () kw = &#123;&#125;&gt;&gt;&gt; f1(1, 2, 3, &#x27;a&#x27;, &#x27;b&#x27;)a = 1 b = 2 c = 3 args = (&#x27;a&#x27;, &#x27;b&#x27;) kw = &#123;&#125;&gt;&gt;&gt; f1(1, 2, 3, &#x27;a&#x27;, &#x27;b&#x27;, x=99)a = 1 b = 2 c = 3 args = (&#x27;a&#x27;, &#x27;b&#x27;) kw = &#123;&#x27;x&#x27;: 99&#125;&gt;&gt;&gt; f2(1, 2, d=99, ext=None)a = 1 b = 2 c = 0 d = 99 kw = &#123;&#x27;ext&#x27;: None&#125;&gt;&gt;&gt; args = (1, 2, 3, 4)&gt;&gt;&gt; kw = &#123;&#x27;d&#x27;: 99, &#x27;x&#x27;: &#x27;#&#x27;&#125;&gt;&gt;&gt; f1(*args, **kw)a = 1 b = 2 c = 3 args = (4,) kw = &#123;&#x27;d&#x27;: 99, &#x27;x&#x27;: &#x27;#&#x27;&#125;&gt;&gt;&gt; args = (1, 2, 3)&gt;&gt;&gt; kw = &#123;&#x27;d&#x27;: 88, &#x27;x&#x27;: &#x27;#&#x27;&#125;&gt;&gt;&gt; f2(*args, **kw)a = 1 b = 2 c = 3 d = 88 kw = &#123;&#x27;x&#x27;: &#x27;#&#x27;&#125;# 对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的 Python 的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。 默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！ 要注意定义可变参数和关键字参数的语法： *args 是可变参数，args 接收的是一个 tuple； **kw 是关键字参数，kw 接收的是一个 dict。 以及调用函数时如何传入可变参数和关键字参数的语法： 可变参数既可以直接传入：func(1, 2, 3)，又可以先组装 list 或 tuple，再通过args 传入：func((1, 2, 3))； 关键字参数既可以直接传入：func(a&#x3D;1, b&#x3D;2)，又可以先组装 dict，再通过kw 传入：func({‘a’: 1, ‘b’: 2})。 使用*args 和**kw 是 Python 的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。 命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。 定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*，否则定义的将是位置参数。 递归函数在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。 使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出 123456def fact(n): if n==1: return 1 return n * fact(n - 1)print(fact(10)) 解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。 尾递归是指，在函数返回的时候，调用自身本身，并且，return 语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。 上面的 fact(n)函数由于 return n * fact(n - 1)引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中： 123456789def fact(n): return fact_iter(n, 1)def fact_iter(num, product): if num == 1: return product return fact_iter(num - 1, num * product)fact(100) 遗憾的是，大多数编程语言没有针对尾递归做优化，Python 解释器也没有做优化，所以，即使把上面的 fact(n)函数改成尾递归方式，也会导致栈溢出。 尾递归事实上和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环。 1234567891011## 利用递归函数移动汉诺塔:def move(n, a, b, c): if n == 1: print(&#x27;move&#x27;, a, &#x27;--&gt;&#x27;, c) else: move(n-1, a, c, b) move(1, a, b, c) move(n-1, b, a, c)move(4, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;) 高级特性切片12345678910111213L = [&#x27;Michael&#x27;, &#x27;Sarah&#x27;, &#x27;Tracy&#x27;, &#x27;Bob&#x27;, &#x27;Jack&#x27;]# list[start:end:step]L[0:3] # 前3个元素同 L[:3]L[-3:] # 后3个元素L[-2:-1] # 倒数切片L[-1] # 末尾元素L[:10:2] # 前10个数，每两个取一个L[::5] # 所有数，每5个取一个L[:] # 取所有，即复制一个list#tuple和字符串也是一种list，同样可用切片操作(0, 1, 2, 3, 4, 5)[:3]&#x27;ABCDEFG&#x27;[:3] 迭代如果给定一个 list 或 tuple，我们可以通过 for 循环来遍历这个 list 或 tuple，这种遍历我们称为迭代（Iteration）。 Python 的 for 循环抽象程度要高于 C 的 for 循环，因为 Python 的 for 循环不仅可以用在 list 或 tuple 上，还可以作用在其他可迭代对象上。 1234567891011d = &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;for key in d: print(&#x27;key:&#x27;, key)for val in d.values(): print(&#x27;val:&#x27;, val)for key,val in d.items(): print(&#x27;key:&#x27;, key, &#x27; val:&#x27;, val)for c in &#x27;ABCD&#x27;: print(&#x27;c:&#x27;, c) 当我们使用 for 循环时，只要作用于一个可迭代对象，for 循环就可以正常运行，而我们不太关心该对象究竟是 list 还是其他数据类型 1234567891011121314151617# 判断对象是否可迭代&gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; isinstance(&#x27;abc&#x27;, Iterable) # str是否可迭代True&gt;&gt;&gt; isinstance([1,2,3], Iterable) # list是否可迭代True&gt;&gt;&gt; isinstance(123, Iterable) # 整数是否可迭代Falsefor i, value in enumerate([&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]): print(i, value)# for循环里，同时引用了两个变量，在Python里是很常见的for x,y in[(1,2), (3,4)]: print(x, y) 列表生成式列表生成式即 List Comprehensions，是 Python 内置的非常简单却强大的可以用来创建 list 的生成式 123456789101112131415list(range(1, 11)) # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10][x * x for x in range(1, 11)] # [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 类似js map[x * x for x in range(1, 11) if x % 2 == 0] # [4, 16, 36, 64, 100] js arr filter and map[m + n for m in &#x27;ABC&#x27; for n in &#x27;XYZ&#x27;] # [&#x27;AX&#x27;, &#x27;AY&#x27;, &#x27;AZ&#x27;, &#x27;BX&#x27;, &#x27;BY&#x27;, &#x27;BZ&#x27;, &#x27;CX&#x27;, &#x27;CY&#x27;, &#x27;CZ&#x27;] 笛卡尔积import os # 导入os模块，模块的概念后面讲到[d for d in os.listdir(&#x27;.&#x27;)] # os.listdir可以列出文件和目录d = &#123;&#x27;hi&#x27;: &#x27;hello&#x27;, &#x27;age&#x27;: &#x27;12&#x27;, &#x27;name&#x27;: &#x27;lufy&#x27;&#125;[k + &#x27;=&#x27; + v for k, v in d.items()] #[&#x27;y=B&#x27;, &#x27;x=A&#x27;, &#x27;z=C&#x27;]L = [&#x27;Hello&#x27;, &#x27;World&#x27;, &#x27;IBM&#x27;, &#x27;Apple&#x27;]print([s.lower() for s in L]) 生成器要创建一个 generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个 generator： 同 es6 的 generator通过 next()函数获得 generator 的下一个返回值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748L = [x * x for x in range(10)]print(L)g = (x * x for x in range(10))print(g)print(next(g))# generator也是可迭代的for n in g: print(n)# 著名的斐波拉契数列（Fibonacci），除第一个和第二个数外，任意一个数都可由前两个数相加得到def fib(max): n, a, b = 0, 0, 1 while n &lt; max: print(b) a, b = b, a + b n = n + 1 return &#x27;done&#x27;# 函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generatordef fib(max): n, a, b = 0, 0, 1 while n &lt; max: yield b a, b = b, a + b n = n + 1 return &#x27;done&#x27;def odd(): print(&#x27;step 1&#x27;) yield 1 print(&#x27;step 2&#x27;) yield(3) print(&#x27;step 3&#x27;) yield(5)og = odd()for n in og: print(n)g = fib(6)while True: try: x = next(g) print(&#x27;g:&#x27;, x) except StopIteration as e: print(&#x27;Generator return value:&#x27;, e.value) break generator 是非常强大的工具，在 Python 中，可以简单地把列表生成式改成 generator，也可以通过函数实现复杂逻辑的 generator。 迭代器用于 for 循环的数据类型有以下几种： 一类是集合数据类型，如 list、tuple、dict、set、str 等； 一类是 generator，包括生成器和带 yield 的 generator function。 12345from collections import Iterableprint(isinstance([], Iterable)) // Trueprint(isinstance(&#123;&#125;, Iterable)) // Trueprint(isinstance(&#x27;abc&#x27;, Iterable)) 生成器都是 Iterator 对象，但 list、dict、str 虽然是 Iterable，却不是 Iterator。 把 list、dict、str 等 Iterable 变成 Iterator 可以使用 iter()函数： 123isinstance(iter([]), Iterator) // Trueisinstance(iter(&#x27;abc&#x27;), Iterator) // True# 注意区分可迭代 和 迭代对象 iter() 你可能会问，为什么 list、dict、str 等数据类型不是 Iterator？ 这是因为 Python 的 Iterator 对象表示的是一个数据流，Iterator 对象可以被 next()函数调用并不断返回下一个数据，直到没有数据时抛出 StopIteration 错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过 next()函数实现按需计算下一个数据，所以 Iterator 的计算是惰性的，只有在需要返回下一个数据时它才会计算。 凡是可作用于 for 循环的对象都是 Iterable 类型； 凡是可作用于 next()函数的对象都是 Iterator 类型，它们表示一个惰性计算的序列； 集合数据类型如 list、dict、str 等是 Iterable 但不是 Iterator，不过可以通过 iter()函数获得一个 Iterator 对象。 Python 的 for 循环本质上就是通过不断调用 next()函数实现的 123456789101112131415for x in [1, 2, 3, 4, 5]: pass# 等价于# 首先获得Iterator对象:it = iter([1, 2, 3, 4, 5])# 循环:while True: try: # 获得下一个值: x = next(it) except StopIteration: # 遇到StopIteration就退出循环 break 函数式编程我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元 而函数式编程（请注意多了一个“式”字）——Functional Programming，虽然也可以归结到面向过程的程序设计，但其思想更接近数学计算 对应到编程语言，就是越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如 C 语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如 Lisp 语言。 函数式编程就是一种抽象程度很高的编程范式, 函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！ Python 对函数式编程提供部分支持。由于 Python 允许使用变量，因此，Python 不是纯函数式编程语言。 纯函数: 相同的输入，就会得到相同的输出，对外部没有副作用的函数 高级函数变量可以指向函数abs(-10)是函数调用，而abs是函数本身; 函数本身也可以赋值给变量，即：变量可以指向函数。 12f = absprint(f(-200)) 函数名也是变量函数名其实就是指向函数的变量 12345&gt;&gt;&gt; abs = 10&gt;&gt;&gt; abs(-10)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: &#x27;int&#x27; object is not callable 注：由于 abs 函数实际上是定义在 import builtins 模块中的，所以要让修改 abs 变量的指向在其它模块也生效，要用 import builtins; builtins.abs &#x3D; 10。 传入函数可以接受函数作为参数的函数，称为高阶函数 12345678910111213141516171819202122232425262728293031323334353637383940def add(x, y, f): return f(x) + f(y)# map map(f, list)def f2(x): return x * xr = map(f2, [1,2,3]) # 返回map对象 同js arr.mapprint(list(r), type(r))print(list(map(str, [1,2,3])))# reduce reduce(f, list)from functools import reducedef add(x, y): return x + yprint(reduce(add, [1,3,5,7]))# lamda 同js匿名函数from functools import reduceDIGITS = &#123;&#x27;0&#x27;: 0, &#x27;1&#x27;: 1, &#x27;2&#x27;: 2, &#x27;3&#x27;: 3, &#x27;4&#x27;: 4, &#x27;5&#x27;: 5, &#x27;6&#x27;: 6, &#x27;7&#x27;: 7, &#x27;8&#x27;: 8, &#x27;9&#x27;: 9&#125;def char2num(s): return DIGITS[s]def str2int(s): return reduce(lambda x, y: x * 10 + y, map(char2num, s))# filter filter(f, list)def is_odd(n): return n % 2 == 1# filter()函数返回的是一个Iterator，也就是一个惰性序列，所以要强迫filter()完成计算结果，需要用list()函数获得所有结果并返回listlist(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))# sorted sorted(list, keyFn)sorted([&#x27;bob&#x27;, &#x27;about&#x27;, &#x27;Zoo&#x27;, &#x27;Credit&#x27;], key=str.lower) # 升序sorted([&#x27;bob&#x27;, &#x27;about&#x27;, &#x27;Zoo&#x27;, &#x27;Credit&#x27;], key=str.lower, reverse=True) # 降序 函数作为返回值高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。 1234567def lazy_sum(*args): def sum(): ax = 0 for n in args: ax = ax + n return ax return sum 当 lazy_sum 返回函数 sum 时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力 闭包当一个函数返回了一个函数后，其内部的局部变量还被新函数引用 123456789101112def count(): fs = [] for i in range(1, 4): def f(): return i*i fs.append(f) return fsf1, f2, f3 = count()f1() #9f2() #9f3() #9 匿名函数在 Python 中，对匿名函数提供了有限支持, 匿名函数有个限制，就是只能有一个表达式，不用写 return，返回值就是该表达式的结果 比 js 的匿名函数弱 123456list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))def build(x, y): return lambda: x * x + y * yf = lambda x: x * x 装饰器由于函数也是一个对象，而且函数对象可以被赋值给变量，所以，通过变量也能调用该函数; 函数对象有一个name属性，可以拿到函数的名字 1234567def now(): print(&#x27;2019-09-02&#x27;)f = nowf()print(now.__name__, f.__name__) # now now 不修改 now()函数的定义，又可以代码运行期间动态增加功能，称之为“装饰器”（Decorator）。 本质上，decorator 就是一个返回函数的高阶函数 123456789101112def log(func): def wrapper(*args, **kw): print(&#x27;call %s():&#x27; % func.__name__) return func(*args, **kw) return wrapper # 返回装饰了目标函数的函数# 借助Python的@语法，把decorator置于函数的定义处@logdef now2(): print(&#x27;2019-01-09&#x27;)now2() # 调用now()函数，不仅会运行now()函数本身，还会在运行now()函数前打印一行日志 把@log放到now()函数的定义处，相当于执行了语句 now=log(now) 12345678910111213141516171819202122232425# 可接受参数的装饰器def log(text): def decorator(func): def wrapper(*args, **kw): print(&#x27;%s %s():&#x27; % (text, func.__name__)) return func(*args, **kw) return wrapper return decorator# now = log(&#x27;execute&#x27;)(now)@log(&#x27;execute&#x27;) # 返回的结果作为装饰器def now(): print(&#x27;2019-11-12&#x27;)# 修正__name__的值import functoolsdef log(func): # wrapper.__name__ = func.__name__ @functools.wraps(func) def wrapper(*args, **kw): print(&#x27;call %s():&#x27; % func.__name__) return func(*args, **kw) return wrapper 在面向对象（OOP）的设计模式中，decorator 被称为装饰模式。OOP 的装饰模式需要通过继承和组合来实现，而 Python 除了能支持 OOP 的 decorator 外，直接从语法层次支持 decorator。Python 的 decorator 可以用函数实现，也可以用类实现。 decorator 可以增强函数的功能，定义起来虽然有点复杂，但使用起来非常灵活和方便。 偏函数在介绍函数参数的时候，我们讲到，通过设定参数的默认值，可以降低函数调用的难度。而偏函数也可以做到这一点 123456789101112131415161718# int(num, base)def int2(x, base=2): return int(x, base)# functools.partial就是帮助我们创建一个偏函数的，不需要我们自己定义int2()import functoolsint2 = functools.partial(int, base=2) # 预绑定末尾参数的函数# 固定了int()函数的关键字参数base# 相当于kw = &#123;&#x27;base&#x27;: 2&#125;init(&#x27;1001&#x27;, **kw)max2 = functools.partial(max, 10)# 实际上会把10作为*args的一部分自动加到左边max2(5,6)# args = (10, 5, 6) 当函数的参数个数太多，需要简化时，使用functools.partial可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。 模块为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在 Python 中，一个.py 文件就称之为一个模块（Module）。 模块化有什么好处？ 最大的好处是大大提高了代码的可维护性。 其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括 Python 内置的模块和来自第三方的模块。 使用模块还可以避免函数名和变量名冲突。 你也许还想到，如果不同的人编写的模块名相同怎么办？为了避免模块名冲突，Python 又引入了按目录来组织模块的方法，称为包（Package） 包作为模块的命名空间，避免模块名冲突 请注意，每一个包目录下面都会有一个__init__.py的文件，这个文件是必须存在的，否则，Python 就把这个目录当成普通目录，而不是一个包。__init__.py可以是空文件，也可以有 Python 代码，因为__init__.py本身就是一个模块 包也可以有多级结构，如mycompanry.web.util 使用模块Python 本身就内置了很多非常有用的模块 1234567891011121314151617181920#!/usr/bin/env python3# -*- coding: utf-8 -*-&#x27; a test module &#x27;__author__ = &#x27;Michael Liao&#x27;import sysdef test(): args = sys.argv if len(args)==1: print(&#x27;Hello, world!&#x27;) elif len(args)==2: print(&#x27;Hello, %s!&#x27; % args[1]) else: print(&#x27;Too many arguments!&#x27;)if __name__==&#x27;__main__&#x27;: test() 作用域在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，有的函数和变量我们希望仅仅在模块内部使用(_约定用_前缀标识_)。 正常的函数和变量名是公开的（public），可以被直接引用，比如：abc，x123，PI 等； __author__，__name__等是特殊变量，如: __doc__可访问文档注释，自定义的变量一般不要用__xx__格式； 实际上模块内的所有东西都是可访问的，_私有前缀也只是习惯约定 1234567891011def _private_1(name): return &#x27;Hello, %s&#x27; % namedef _private_2(name): return &#x27;Hi, %s&#x27; % namedef greeting(name): if len(name) &gt; 3: return _private_1(name) else: return _private_2(name) 安装第三方模块在 Python 中，安装第三方模块，是通过包管理工具 pip 完成的。 pip install Pillow 更多内容","tags":["python"],"categories":["python"]},{"title":"react","path":"/react/index.html","content":"react introducea very popular lib for building ui"}]