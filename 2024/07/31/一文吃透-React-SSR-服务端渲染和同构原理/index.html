
<!DOCTYPE html><html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.27.0" theme-name="Stellar" theme-version="1.27.0">
  
  <meta name="generator" content="Hexo 7.1.1">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>一文吃透 React SSR 服务端渲染和同构原理 - JKK随笔</title>

  
    <meta name="description" content="原文地址javascript - 一文吃透 React SSR 服务端渲染和同构原理 - 前端张大胖-技术实践和探索 - SegmentFault 思否  全网最完整的 React SSR 同构技术原理解析与实践，从零开始手把手带你打造自己的同构应用开发骨架，帮助大家彻底深入理解服务端渲染及底层实现原理，学完本课程，你也可以打造自己的同构框架。  写在前面前段时间一直在研究react ssr技术">
<meta property="og:type" content="article">
<meta property="og:title" content="一文吃透 React SSR 服务端渲染和同构原理">
<meta property="og:url" content="https://panzhenjie.fun/2024/07/31/%E4%B8%80%E6%96%87%E5%90%83%E9%80%8F-React-SSR-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E5%92%8C%E5%90%8C%E6%9E%84%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="JKK随笔">
<meta property="og:description" content="原文地址javascript - 一文吃透 React SSR 服务端渲染和同构原理 - 前端张大胖-技术实践和探索 - SegmentFault 思否  全网最完整的 React SSR 同构技术原理解析与实践，从零开始手把手带你打造自己的同构应用开发骨架，帮助大家彻底深入理解服务端渲染及底层实现原理，学完本课程，你也可以打造自己的同构框架。  写在前面前段时间一直在研究react ssr技术">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://segmentfault.com/img/remote/1460000021980719">
<meta property="og:image" content="https://segmentfault.com/img/remote/1460000021980718">
<meta property="og:image" content="https://segmentfault.com/img/remote/1460000021980720">
<meta property="article:published_time" content="2024-07-31T05:54:30.000Z">
<meta property="article:modified_time" content="2024-10-11T14:06:02.627Z">
<meta property="article:author" content="stephenykk">
<meta property="article:tag" content="React">
<meta property="article:tag" content="SSR">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://segmentfault.com/img/remote/1460000021980719">
  
  
  
  <meta name="keywords" content="React,SSR">

  <!-- feed -->
  

  <link rel="stylesheet" href="/css/main.css?v=1.27.0">

  

  

  
</head>
<body>

<div class="l_body s:aa content tech" id="start" layout="post" ><aside class="l_left"><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/rainbow64@3x.webp);"></div><img  referrerpolicy="no-referrer" no-lazy class="avatar" src="https://avatars.githubusercontent.com/u/7259892?s=400&u=01563911436a79d809f95ca8d1191c8a7ecc6f56&v=4" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">JKK随笔</div><div class="sub normal cap">搬砖工</div><div class="sub hover cap" style="opacity:0"> 但行好事 莫问前程</div></a></div></header>

<div class="nav-area">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="站内搜索"></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div>


<nav class="menu dis-select"></nav>
</div>
<div class="widgets">


<widget class="widget-wrapper post-list"><div class="widget-header dis-select"><span class="name">最近更新</span></div><div class="widget-body fs14"><a class="item title" href="/2024/04/10/curl%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/"><span class="title">curl实用教程</span></a><a class="item title" href="/2024/03/12/%E5%8D%81%E5%88%86%E9%92%9F%E5%AD%A6%E4%BC%9AWebSocket/"><span class="title">十分钟学会WebSocket</span></a><a class="item title" href="/2024/02/26/Python%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"><span class="title">Python基础教程</span></a><a class="item title" href="/2024/07/31/%E4%B8%80%E6%96%87%E5%90%83%E9%80%8F-React-SSR-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E5%92%8C%E5%90%8C%E6%9E%84%E5%8E%9F%E7%90%86/"><span class="title">一文吃透 React SSR 服务端渲染和同构原理</span></a><a class="item title" href="/2024/03/26/Hexo-Stellar%E4%B8%BB%E9%A2%98%E6%A0%87%E7%AD%BE%E5%85%A5%E9%97%A8/"><span class="title">Hexo Stellar主题标签使用入门</span></a><a class="item title" href="/2024/03/07/Grid%E5%B8%83%E5%B1%80%E8%AF%A6%E8%A7%A3/"><span class="title">Grid布局详解</span></a><a class="item title" href="/2024/03/01/Nginx%E5%92%8CPHP%E7%9A%84%E9%85%8D%E7%BD%AE/"><span class="title">Nginx和PHP的配置</span></a><a class="item title" href="/2024/04/12/SVG%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88%E5%9B%BE%E8%A7%A3%E7%89%88%EF%BC%89/"><span class="title">SVG快速入门（图解版）</span></a><a class="item title" href="/2024/03/12/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E5%85%A5%E9%97%A8NextJs/"><span class="title">手把手带你入门NextJs</span></a><a class="item title" href="/2024/04/12/Canvas%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%A7%A3/"><span class="title">Canvas入门知识图解</span></a></div></widget>
</div>

</div></aside><div class="l_main" id="main">





<div class="article banner top"><img  referrerpolicy="no-referrer" class="bg lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/images/banner_camera.jpg">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" href="/">文章</a></div>
<div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2024-07-31T05:54:30.000Z">2024-07-31</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2024-10-11T14:06:02.627Z">2024-10-11</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>一文吃透 React SSR 服务端渲染和同构原理</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content"><blockquote>
<p>原文地址<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000020417285">javascript - 一文吃透 React SSR 服务端渲染和同构原理 - 前端张大胖-技术实践和探索 - SegmentFault 思否</a></p>
</blockquote>
<p>全网最完整的 React SSR 同构技术原理解析与实践，从零开始手把手带你打造自己的同构应用开发骨架，帮助大家彻底深入理解服务端渲染及底层实现原理，学完本课程，你也可以打造自己的同构框架。</p>
<hr>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>前段时间一直在研究<code>react ssr</code>技术，然后写了一个完整的<code>ssr</code>开发骨架。今天写文，主要是把我的研究成果的精华内容整理落地，另外通过再次梳理希望发现更多优化的地方，也希望可以让更多的人少踩一些坑，让跟多的人理解和掌握这个技术。</p>
<p>相信看过本文（前提是能对你的胃口，也能较好的消化吸收）你一定会对 <code>react ssr</code> 服务端渲染技术有一个深入的理解，可以打造自己的脚手架，更可以用来改造自己的实际项目，当然这不仅限于 <code>react</code> ，其他框架都一样，毕竟原理都是相似的。</p>
<h2 id="为什么要服务端渲染-ssr"><a href="#为什么要服务端渲染-ssr" class="headerlink" title="为什么要服务端渲染(ssr)"></a>为什么要服务端渲染(ssr)</h2><p>至于为什么要服务端渲染，我相信大家都有所闻，而且每个人都能说出几点来。</p>
<h3 id="首屏等待"><a href="#首屏等待" class="headerlink" title="首屏等待"></a>首屏等待</h3><p>在 SPA 模式下，所有的数据请求和 Dom 渲染都在浏览器端完成，所以当我们第一次访问页面的时候很可能会存在“白屏”等待，而服务端渲染所有数据请求和 html内容已在服务端处理完成，浏览器收到的是完整的 html 内容，可以更快的看到渲染内容，在服务端完成数据请求肯定是要比在浏览器端效率要高的多。</p>
<h3 id="没考虑SEO的感受"><a href="#没考虑SEO的感受" class="headerlink" title="没考虑SEO的感受"></a>没考虑SEO的感受</h3><p>有些网站的流量来源主要还是靠搜索引擎，所以网站的 SEO 还是很重要的，而 SPA 模式对搜索引擎不够友好，要想彻底解决这个问题只能采用服务端直出。改变不了别人（搜索yinqing），只能改变自己。</p>
<h3 id="SSR-SPA-体验升级"><a href="#SSR-SPA-体验升级" class="headerlink" title="SSR + SPA 体验升级"></a>SSR + SPA 体验升级</h3><p>只实现 <code>SSR</code> 其实没啥意义，技术上没有任何发展和进步，否则 <code>SPA</code> 技术就不会出现。</p>
<p>但是单纯的 <code>SPA</code>又不够完美，所以最好的方案就是这两种体验和技术的结合，第一次访问页面是服务端渲染，基于第一次访问后续的交互就是 <code>SPA</code> 的效果和体验，还不影响<code>SEO</code> 效果，这就有点完美了。</p>
<p>单纯实现 <code>ssr</code> 很简单，毕竟这是传统技术，也不分语言，随便用 php 、jsp、asp、node 等都可以实现。</p>
<p>但是要实现两种技术的结合，同时可以最大限度的重用代码（同构），减少开发维护成本，那就需要采用 <code>react</code> 或者 <code>vue</code> 等前端框架相结合 <code>node (ssr)</code> 来实现。</p>
<p>本文主要说 <code>React SSR 技术</code> ,当然 <code>vue</code> 也一样，只是技术栈不同而已。</p>
<h2 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h2><p>整体来说 <code>react</code> 服务端渲染原理不复杂，其中最核心的内容就是同构。</p>
<p><code>node server</code> 接收客户端请求，得到当前的<code>req url path</code>,然后在已有的路由表内查找到对应的组件，拿到需要请求的数据，将数据作为 <code>props</code><br>、<code>context</code>或者<code>store</code> 形式传入组件，然后基于 <code>react</code> 内置的服务端渲染api <code>renderToString() or renderToNodeStream()</code> 把组件渲染为 <code>html字符串</code>或者 <code>stream 流</code>, 在把最终的 <code>html</code> 进行输出前需要将数据注入到浏览器端(注水)，server 输出(response)后浏览器端可以得到数据(脱水)，浏览器开始进行渲染和节点对比，然后执行组件的<code>componentDidMount</code> 完成组件内事件绑定和一些交互，浏览器重用了服务端输出的 <code>html 节点</code>，整个流程结束。</p>
<p>技术点确实不少，但更多的是架构和工程层面的，需要把各个知识点进行链接和整合。</p>
<p>这里放一个架构图</p>
<p><img  referrerpolicy="no-referrer" class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://segmentfault.com/img/remote/1460000021980719"></p>
<h2 id="react-ssr"><a href="#react-ssr" class="headerlink" title="react ssr"></a>react ssr</h2><h3 id="从-ejs-开始"><a href="#从-ejs-开始" class="headerlink" title="从 ejs 开始"></a>从 ejs 开始</h3><p>实现 ssr 很简单，先看一个 <code>node ejs</code>的栗子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// index.html</span><br>&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>   &lt;meta charset=&quot;UTF-8&quot;&gt;<br>   &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>   &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;<br>   &lt;title&gt;react ssr &lt;%= title %&gt;&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>   &lt;%=  data %&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> <span class="hljs-comment">//node ssr</span><br> <span class="hljs-keyword">const</span> ejs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;ejs&#x27;</span>);<br> <span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><br>http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (req.<span class="hljs-property">url</span> === <span class="hljs-string">&#x27;/&#x27;</span>) &#123;<br>        res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, &#123;<br>            <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;text/html&#x27;</span> <br>        &#125;);<br>        <span class="hljs-comment">// 渲染文件 index.ejs</span><br>        ejs.<span class="hljs-title function_">renderFile</span>(<span class="hljs-string">&#x27;./views/index.ejs&#x27;</span>, &#123;<br>            <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;react ssr&#x27;</span>, <br>            <span class="hljs-attr">data</span>: <span class="hljs-string">&#x27;首页&#x27;</span>&#125;, <br>            <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (err ) &#123;<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res.<span class="hljs-title function_">end</span>(data);<br>            &#125;<br>        &#125;)<br>    &#125;<br>&#125;).<span class="hljs-title function_">listen</span>(<span class="hljs-number">8080</span>);<br></code></pre></td></tr></table></figure>

<h3 id="jsx-到字符串"><a href="#jsx-到字符串" class="headerlink" title="jsx 到字符串"></a>jsx 到字符串</h3><p>上面我们结合 <code>ejs模板引擎</code> ，实现了一个服务端渲染的输出，html 和 数据直接输出到客户端。</p>
<p>参考以上，我们结合 <code>react组件</code> 来实现服务端渲染直出，使用 <code>jsx</code> 来代替 <code>ejs</code>，之前是在 html 里使用 <code>ejs</code> 来绑定数据，现在改写成使用<code>jsx</code> 来绑定数据,使用 react 内置 api 来把组件渲染为 html 字符串，其他没有差别。</p>
<p>为什么react 组件可以被转换为 html字符串呢？</p>
<p>简单的说我们写的 jsx 看上去就像在写 html（其实写的是对象） 标签，其实经过编译后都会转换成<code>React.createElement</code>方法，最终会被转换成一个对象(虚拟DOM)，而且和平台无关，有了这个对象，想转换成什么那就看心情了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span>  <span class="hljs-title class_">React</span>  = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;react&#x27;</span>);<br><br><span class="hljs-keyword">const</span> &#123; renderToString&#125;  = <span class="hljs-built_in">require</span>( <span class="hljs-string">&#x27;react-dom/server&#x27;</span>);<br><br><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><br><span class="hljs-comment">//组件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>)&#123;<br>        <span class="hljs-variable language_">super</span>(props);<br>    &#125;<br><br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;this.props.data.title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>    &#125;<br>&#125;<br> <br><span class="hljs-comment">//模拟数据的获取</span><br><span class="hljs-keyword">const</span> fetch = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">title</span>:<span class="hljs-string">&#x27;react ssr&#x27;</span>,<br>        <span class="hljs-attr">data</span>:[]<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//服务</span><br>http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (req.<span class="hljs-property">url</span> === <span class="hljs-string">&#x27;/&#x27;</span>) &#123;<br>        res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, &#123;<br>            <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;text/html&#x27;</span><br>        &#125;);<br><br>        <span class="hljs-keyword">const</span> data = <span class="hljs-title function_">fetch</span>();<br><br>        <span class="hljs-keyword">const</span> html = <span class="hljs-title function_">renderToString</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Index</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;data&#125;/</span>&gt;</span></span>);<br>        res.<span class="hljs-title function_">end</span>(html);<br>    &#125;<br>&#125;).<span class="hljs-title function_">listen</span>(<span class="hljs-number">8080</span>);<br></code></pre></td></tr></table></figure>

<p><strong>ps</strong>:以上代码不能直接运行，需要结合babel 使用 @babel&#x2F;preset-react 进行转换</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br>npx babel script.<span class="hljs-property">js</span> --out-file script-compiled.<span class="hljs-property">js</span> --presets=@babel/preset-react<br><br></code></pre></td></tr></table></figure>

<h2 id="引出问题"><a href="#引出问题" class="headerlink" title="引出问题"></a>引出问题</h2><p>在上面非常简单的就是实现了 <code>react ssr</code> ,把<code>jsx</code>作为模板引擎，不要小看上面的一小段代码，他可以帮我们引出一系列的问题，这也是完整实现 <code>react ssr</code> 的基石。</p>
<ul>
<li>双端路由如何维护？</li>
</ul>
<p>首先我们会发现我在 <code>server</code> 端定义了路由 ‘&#x2F;‘，但是在 <code>react SPA</code> 模式下我们需要使用<code>react-router</code>来定义路由。那是不是就需要维护两套路由呢？</p>
<ul>
<li>获取数据的方法和逻辑写在哪里？</li>
</ul>
<p>发现数据获取的<code>fetch</code> 写的独立的方法，和组件没有任何关联，我们更希望的是每个路由都有自己的 fetch 方法。</p>
<ul>
<li>服务端 html 节点无法重用</li>
</ul>
<p>虽然组件在服务端得到了数据，也能渲染到浏览器内，但是当浏览器端进行组件渲染的时候直出的内容会一闪而过消失。</p>
<p>好了，问题有了，接下来我们就一步一步的来解决这些问题。</p>
<h2 id="同构才是核心"><a href="#同构才是核心" class="headerlink" title="同构才是核心"></a>同构才是核心</h2><p><code>react ssr</code> 的核心就是同构，没有同构的 ssr 是没有意义的。</p>
<p>所谓同构就是采用一套代码，构建双端（server 和 client）逻辑，最大限度的重用代码，不用维护两套代码。而传统的服务端渲染是无法做到的，react 的出现打破了这个瓶颈，并且现在已经得到了比较广泛的应用。</p>
<h3 id="路由同构"><a href="#路由同构" class="headerlink" title="路由同构"></a>路由同构</h3><p>双端使用同一套路由规则，<code>node server</code> 通过<code>req url path</code> 进行组件的查找，得到需要渲染的组件。</p>
<p>&#x2F;&#x2F;组件和路由配置 ，供双端使用 routes-config.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Detail</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&#123;<br><br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>detail<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br><br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>index<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">const</span> routes = [<br>  <br>            &#123;<br>                <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/&quot;</span>,<br>                <span class="hljs-attr">exact</span>: <span class="hljs-literal">true</span>,<br>                <span class="hljs-attr">component</span>: <span class="hljs-title class_">Home</span><br>            &#125;,<br>            &#123;<br>                <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/detail&#x27;</span>, <span class="hljs-attr">exact</span>: <span class="hljs-literal">true</span>,<br>                <span class="hljs-attr">component</span>:<span class="hljs-title class_">Detail</span>,<br>            &#125;,<br>            &#123;<br>                <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/detail/:a/:b&#x27;</span>, <span class="hljs-attr">exact</span>: <span class="hljs-literal">true</span>,<br>                <span class="hljs-attr">component</span>: <span class="hljs-title class_">Detail</span><br>            &#125;<br>         <br>];<br><br><span class="hljs-comment">//导出路由表</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> routes;<br></code></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;客户端 路由组件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> routes <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./routes-config.js&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Layout</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Switch</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">                        &#123;</span><br><span class="language-xml">                            routes.map((item,index)=&gt;&#123;</span><br><span class="language-xml">                                return <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&#123;item.path&#125;</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;index&#125;</span> <span class="hljs-attr">exact</span>=<span class="hljs-string">&#123;item.exact&#125;</span> <span class="hljs-attr">render</span>=<span class="hljs-string">&#123;item.component&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></span><br><span class="language-xml">                            &#125;)</span><br><span class="language-xml">                        &#125;</span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">Switch</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">Layout</span>&gt;</span></span><br>    );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure>

<p><strong>node server 进行组件查找</strong></p>
<p>路由匹配其实就是对 组件<code>path</code> 规则的匹配，如果规则不复杂可以自己写，如果情况很多种还是使用官方提供的库来完成。</p>
<p><strong><code>matchRoutes(routes, pathname)</code></strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//引入官方库</span><br><span class="hljs-keyword">import</span> &#123; matchRoutes &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-router-config&quot;</span>;<br><span class="hljs-keyword">import</span> routes <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./routes-config.js&#x27;</span>;<br><br><span class="hljs-keyword">const</span> path = req.<span class="hljs-property">path</span>;<br><br><span class="hljs-keyword">const</span> branch = <span class="hljs-title function_">matchRoutes</span>(routes, path);<br><br><span class="hljs-comment">//得到要渲染的组件</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Component</span> = branch[<span class="hljs-number">0</span>].<span class="hljs-property">route</span>.<span class="hljs-property">component</span>;<br> <br><br><span class="hljs-comment">//node server </span><br>http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <br>        <span class="hljs-keyword">const</span> url = req.<span class="hljs-property">url</span>;<br>        <span class="hljs-comment">//简单容错，排除图片等资源文件的请求</span><br>        <span class="hljs-keyword">if</span>(url.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;.&#x27;</span>)&gt;-<span class="hljs-number">1</span>) &#123; res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;&#x27;</span>); <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<br><br>        res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, &#123;<br>            <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;text/html&#x27;</span><br>        &#125;);<br>        <span class="hljs-keyword">const</span> data = <span class="hljs-title function_">fetch</span>();<br><br>        <span class="hljs-comment">//查找组件</span><br>        <span class="hljs-keyword">const</span> branch =  <span class="hljs-title function_">matchRoutes</span>(routes,url);<br>        <br>        <span class="hljs-comment">//得到组件</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-title class_">Component</span> = branch[<span class="hljs-number">0</span>].<span class="hljs-property">route</span>.<span class="hljs-property">component</span>;<br><br>        <span class="hljs-comment">//将组件渲染为 html 字符串</span><br>        <span class="hljs-keyword">const</span> html = <span class="hljs-title function_">renderToString</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Component</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;data&#125;/</span>&gt;</span></span>);<br><br>        res.<span class="hljs-title function_">end</span>(html);<br>        <br> &#125;).<span class="hljs-title function_">listen</span>(<span class="hljs-number">8080</span>);<br></code></pre></td></tr></table></figure>

<p>可以看下<code>matchRoutes方法</code>的返回值,其中<code>route.component</code> 就是 要渲染的组件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br>[<br>    &#123; <br>    <br>    <span class="hljs-attr">route</span>:<br>        &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/detail&#x27;</span>, <span class="hljs-attr">exact</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">component</span>: [<span class="hljs-title class_">Function</span>: <span class="hljs-title class_">Detail</span>] &#125;,<br>    <span class="hljs-attr">match</span>:<br>        &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/detail&#x27;</span>, <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/detail&#x27;</span>, <span class="hljs-attr">isExact</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">params</span>: &#123;&#125; &#125; <br>        <br>    &#125;<br>   ]<br></code></pre></td></tr></table></figure>

<p><code>react-router-config</code> 这个库由react 官方维护，功能是实现嵌套路由的查找，代码没有多少，有兴趣可以看看。</p>
<p><strong>文章走到这里，相信你已经知道了路由同构，所以上面的第一个问题 ： 【双端路由如何维护？】 解决了。</strong></p>
<h3 id="数据同构（预取同构）"><a href="#数据同构（预取同构）" class="headerlink" title="数据同构（预取同构）"></a>数据同构（预取同构）</h3><p>这里开始解决我们最开始发现的第二个问题 - 【获取数据的方法和逻辑写在哪里？】</p>
<p>数据预取同构，解决双端如何使用同一套数据请求方法来进行数据请求。</p>
<p>先说下流程，在查找到要渲染的组件后，需要预先得到此组件所需要的数据，然后将数据传递给组件后，再进行组件的渲染。</p>
<p>我们可以通过给组件定义静态方法来处理，组件内定义异步数据请求的方法也合情合理，同时声明为静态（static），在 server 端和组件内都也可以直接通过组件（function） 来进行访问。</p>
<p>比如 <code>Index.getInitialProps</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-comment">//组件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>)&#123;<br>        <span class="hljs-variable language_">super</span>(props);<br>    &#125;<br><br>    <span class="hljs-comment">//数据预取方法  静态 异步 方法</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span>  <span class="hljs-title function_">getInitialProps</span>(<span class="hljs-params">opt</span>) &#123;<br>        <span class="hljs-keyword">const</span> fetch1 =<span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/xxx.com/a&#x27;</span>);<br>        <span class="hljs-keyword">const</span> fetch2 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/xxx.com/b&#x27;</span>);<br><br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">res</span>:[fetch1,fetch2]<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;this.props.data.title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//node server </span><br>http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <br>        <span class="hljs-keyword">const</span> url = req.<span class="hljs-property">url</span>;<br>        <span class="hljs-keyword">if</span>(url.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;.&#x27;</span>)&gt;-<span class="hljs-number">1</span>) &#123; res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;&#x27;</span>); <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<br><br>        res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, &#123;<br>            <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;text/html&#x27;</span><br>        &#125;);<br>        <br>        <span class="hljs-comment">//组件查找</span><br>        <span class="hljs-keyword">const</span> branch =  <span class="hljs-title function_">matchRoutes</span>(routes,url);<br>        <br>        <span class="hljs-comment">//得到组件</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-title class_">Component</span> = branch[<span class="hljs-number">0</span>].<span class="hljs-property">route</span>.<span class="hljs-property">component</span>;<br>    <br>        <span class="hljs-comment">//数据预取</span><br>        <span class="hljs-keyword">const</span> data = <span class="hljs-title class_">Component</span>.<span class="hljs-title function_">getInitialProps</span>(branch[<span class="hljs-number">0</span>].<span class="hljs-property">match</span>.<span class="hljs-property">params</span>);<br>      <br>        <span class="hljs-comment">//传入数据，渲染组件为 html 字符串</span><br>        <span class="hljs-keyword">const</span> html = <span class="hljs-title function_">renderToString</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Component</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;data&#125;/</span>&gt;</span></span>);<br><br>        res.<span class="hljs-title function_">end</span>(html);<br><br> &#125;).<span class="hljs-title function_">listen</span>(<span class="hljs-number">8080</span>);<br></code></pre></td></tr></table></figure>

<p>另外还有在声明路由的时候把数据请求方法关联到路由中，比如定一个 loadData 方法，然后在查找到路由后就可以判断是否存在<code>loadData</code>这个方法。</p>
<p>看下参考代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">loadBranchData</span> = (<span class="hljs-params">location</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> branch = <span class="hljs-title function_">matchRoutes</span>(routes, location.<span class="hljs-property">pathname</span>)<br><br>  <span class="hljs-keyword">const</span> promises = branch.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">&#123; route, match &#125;</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> route.<span class="hljs-property">loadData</span><br>      ? route.<span class="hljs-title function_">loadData</span>(match)<br>      : <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-literal">null</span>)<br>  &#125;)<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(promises)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面这种方式实现上没什么问题，但从职责划分的角度来说有些不够清晰，我还是比较喜欢直接通过组件来得到异步方法。</p>
<p>好了，到这里我们的第二个问题 - 【获取数据的方法和逻辑写在哪里？】 解决了。</p>
<h3 id="渲染同构"><a href="#渲染同构" class="headerlink" title="渲染同构"></a>渲染同构</h3><p>假设我们现在基于上面已经实现的代码，同时我们也使用 webpack 进行了配置，对代码进行了转换和打包，整个服务可以跑起来。</p>
<p>路由能够正确匹配，数据预取正常，服务端可以直出组件的 html ，浏览器加载 js 代码正常，查看网页源代码能看到 html 内容，好像我们的整个流程已经走完。</p>
<p>但是当浏览器端的 js 执行完成后，发现数据重新请求了，组件的重新渲染导致页面看上去有些闪烁。</p>
<p>这是因为在浏览器端，双端节点对比失败，导致组件重新渲染，也就是只有当服务端和浏览器端渲染的组件具有相同的<code>props</code> 和 DOM 结构的时候，组件才能只渲染一次。</p>
<p>刚刚我们实现了双端的数据预取同构，但是数据也仅仅是服务端有，浏览器端是没有这个数据，当客户端进行首次组件渲染的时候没有初始化的数据，渲染出的节点肯定和服务端直出的节点不同，导致组件重新渲染。</p>
<h4 id="数据注水"><a href="#数据注水" class="headerlink" title="数据注水"></a>数据注水</h4><p>在服务端将预取的数据注入到浏览器，使浏览器端可以访问到，客户端进行渲染前将数据传入对应的组件即可，这样就保证了<code>props</code>的一致。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> <br><span class="hljs-comment">//node server  参考代码</span><br>http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <br>        <span class="hljs-keyword">const</span> url = req.<span class="hljs-property">url</span>;<br>        <span class="hljs-keyword">if</span>(url.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;.&#x27;</span>)&gt;-<span class="hljs-number">1</span>) &#123; res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;&#x27;</span>); <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<br><br>        res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, &#123;<br>            <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;text/html&#x27;</span><br>        &#125;);<br><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(url);<br>       <br>        <span class="hljs-comment">//查找组件</span><br>        <span class="hljs-keyword">const</span> branch =  <span class="hljs-title function_">matchRoutes</span>(routes,url);<br>        <span class="hljs-comment">//得到组件</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-title class_">Component</span> = branch[<span class="hljs-number">0</span>].<span class="hljs-property">route</span>.<span class="hljs-property">component</span>;<br><br>        <span class="hljs-comment">//数据预取</span><br>        <span class="hljs-keyword">const</span> data = <span class="hljs-title class_">Component</span>.<span class="hljs-title function_">getInitialProps</span>(branch[<span class="hljs-number">0</span>].<span class="hljs-property">match</span>.<span class="hljs-property">params</span>);<br><br>        <span class="hljs-comment">//组件渲染为 html</span><br>        <span class="hljs-keyword">const</span> html = <span class="hljs-title function_">renderToString</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Component</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;data&#125;/</span>&gt;</span></span>);<br><br>        <span class="hljs-comment">//数据注水</span><br>        <span class="hljs-keyword">const</span> propsData = <span class="hljs-string">`&lt;textarea style=&quot;display:none&quot; id=&quot;krs-server-render-data-BOX&quot;&gt;<span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(data)&#125;</span>&lt;/textarea&gt;`</span>;<br><br>        <span class="hljs-comment">// 通过 ejs 模板引擎将数据注入到页面</span><br>        ejs.<span class="hljs-title function_">renderFile</span>(<span class="hljs-string">&#x27;./index.html&#x27;</span>, &#123;<br>            <span class="hljs-attr">htmlContent</span>: html,  <br>            propsData<br>        &#125;,  <span class="hljs-comment">// 渲染的数据key: 对应到了ejs中的index</span><br>            <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>                <span class="hljs-keyword">if</span> (err) &#123;<br>                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>                    res.<span class="hljs-title function_">end</span>(data);<br>                &#125;<br>            &#125;)<br><br> &#125;).<span class="hljs-title function_">listen</span>(<span class="hljs-number">8080</span>);<br> <br> <span class="hljs-comment">//node ejs html</span><br> <br> &lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br><br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;<br>&lt;/head&gt;<br><br>&lt;body&gt;<br>    &lt;div id=&quot;rootEle&quot;&gt;<br>        &lt;%- htmlContent %&gt; //组件 html内容<br>    &lt;/div&gt;<br>    <br>    &lt;%- propsData %&gt; //组件 init  state ，现在是个字符串<br>&lt;/body&gt;<br><br>&lt;/html&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure>

<p>需要借助 ejs 模板，将数据绑定到页面上，为了防止 <code>XSS</code>攻击，这里我把数据写到了 <code>textarea</code> 标签里。</p>
<p>下图中，我看着明文数据难受，对数据做了base64编码 ，用之前需要转码，看个人需要。<br><img  referrerpolicy="no-referrer" class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://segmentfault.com/img/remote/1460000021980718"></p>
<h4 id="数据脱水"><a href="#数据脱水" class="headerlink" title="数据脱水"></a>数据脱水</h4><p>上一步数据已经注入到了浏览器端，这一步要在客户端组件渲染前先拿到数据，并且传入组件就可以了。</p>
<p>客户端可以直接使用<code>id=krs-server-render-data-BOX</code> 进行数据获取。</p>
<p>第一个方法简单粗暴，可直接在组件内的<code>constructor 构造函数</code> 内进行获取，如果怕代码重复，可以写一个高阶组件。</p>
<p>第二个方法可以通过 context 传递，只需要在入口处传入，在组件中声明 <code>static contextType</code> 即可。</p>
<p>我是采用context 传递，为了后面方便集成 <code>redux</code> 状态管理 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-comment">// 定义 context 生产者 组件</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>,&#123;createContext&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">RootContext</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./route-context&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props,context</span>) &#123;<br>        <span class="hljs-variable language_">super</span>(props);<br>    &#125;<br><br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">RootContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.props.initialData||&#123;&#125;&#125;</span>&gt;</span></span><br><span class="language-xml">            &#123;this.props.children&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">RootContext.Provider</span>&gt;</span></span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//入口  app.js</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">BrowserRouter</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Routes</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Provider</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./provider&#x27;</span>;<br><br><br><span class="hljs-comment">//渲染入口  接收脱水数据</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">renderUI</span>(<span class="hljs-params">initialData</span>) &#123;<br>    <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">hydrate</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">BrowserRouter</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Provider</span> <span class="hljs-attr">initialData</span>=<span class="hljs-string">&#123;initialData&#125;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Routes</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">BrowserRouter</span>&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;rootEle&#x27;</span>), <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>    &#125;);<br>&#125;<br><br><span class="hljs-comment">//函数执行入口</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">entryIndex</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable constant_">APP_INIT_DATA</span> = &#123;&#125;;<br>    <span class="hljs-keyword">let</span> state = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-comment">//取得数据</span><br>    <span class="hljs-keyword">let</span> stateText = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;krs-server-render-data-BOX&#x27;</span>);<br><br>    <span class="hljs-keyword">if</span> (stateText) &#123;<br>        <span class="hljs-variable constant_">APP_INIT_DATA</span> = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(stateText.<span class="hljs-property">value</span> || <span class="hljs-string">&#x27;&#123;&#125;&#x27;</span>);<br>    &#125;<br><br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable constant_">APP_INIT_DATA</span>) &#123;<span class="hljs-comment">//客户端渲染</span><br>        <br>        <span class="hljs-title function_">renderUI</span>(<span class="hljs-variable constant_">APP_INIT_DATA</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//入口执行</span><br><span class="hljs-title function_">entryIndex</span>();<br><br></code></pre></td></tr></table></figure>

<p>行文至此，核心的内容已经基本说完，剩下的就是组件内如何使用脱水的数据。</p>
<p>下面通过 <code>context</code> 拿到数据 , 代码仅供参考，可根据自己的需求来进行封装和调整。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./css/index.scss&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props, context</span>) &#123;<br>        <span class="hljs-variable language_">super</span>(props, context);<br><br>        <span class="hljs-comment">//将context 存储到 state </span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<br>            ... context<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">//设置此参数 才能拿到 context 数据</span><br>    <span class="hljs-keyword">static</span> contextType = <span class="hljs-title class_">RootContext</span>;<br><br>    <span class="hljs-comment">//数据预取方法</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> <span class="hljs-title function_">getInitialProps</span>(<span class="hljs-params">krsOpt</span>) &#123;<br><br>        <span class="hljs-keyword">if</span> (__SERVER__) &#123;<br>            <span class="hljs-comment">//如果是服务端渲染的话  可以做的处理,node 端设置的全局变量</span><br>        &#125;<br><br>        <span class="hljs-keyword">const</span> fetch1 = fetch.<span class="hljs-title function_">postForm</span>(<span class="hljs-string">&#x27;/fe_api/filed-manager/get-detail-of-type&#x27;</span>, &#123;<br>            <span class="hljs-attr">data</span>: &#123; <span class="hljs-attr">ofTypeId</span>: <span class="hljs-number">4000</span> &#125;<br>        &#125;);<br><br>        <span class="hljs-keyword">const</span> fecth2 = fetch.<span class="hljs-title function_">postForm</span>(<span class="hljs-string">&#x27;/fe_api/filed-manager/get-detail-of-type&#x27;</span>, &#123;<br>            <span class="hljs-attr">data</span>: &#123; <span class="hljs-attr">ofTypeId</span>: <span class="hljs-number">2000</span> &#125;<br>        &#125;);<br><br>        <span class="hljs-keyword">const</span> resArr = <span class="hljs-keyword">await</span> fetch.<span class="hljs-title function_">multipleFetch</span>(fetch1, fecth2);<br>        <span class="hljs-comment">//返回所有数据</span><br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">page</span>: &#123;&#125;,<br>            <span class="hljs-attr">fetchData</span>: resArr<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">isSSR</span>) &#123; <span class="hljs-comment">//非服务端渲染需要自身进行数据获取</span><br>            <span class="hljs-title class_">Index</span>.<span class="hljs-title function_">getInitialProps</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">krsOpt</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>                    ...data<br>                &#125;, <span class="hljs-function">() =&gt;</span> &#123;<br>                   <span class="hljs-comment">//可有的一些操作</span><br>                &#125;);<br>            &#125;);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br><br>        <span class="hljs-comment">//得到 state 内的数据，进行逻辑判断和容错，然后渲染</span><br>        <span class="hljs-keyword">const</span> &#123; page, fetchData &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>;<br>        <span class="hljs-keyword">const</span> [res] = fetchData || [];<br><br>        <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;detailBox&quot;</span>&gt;</span></span><br><span class="language-xml">            &#123;</span><br><span class="language-xml">                res &amp;&amp; res.data.map(item =&gt; &#123;</span><br><span class="language-xml">                    return <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;item.id&#125;</span>&gt;</span>&#123;item.keyId&#125;:&#123;item.keyName&#125;---&#123;item.setContent&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                &#125;)</span><br><span class="language-xml">            &#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<p>到此我们的第三个问题：【服务端 html 节点无法重用 】已经解决,但人不够完美，请继续看。</p>
<h2 id="css-过滤"><a href="#css-过滤" class="headerlink" title="css 过滤"></a>css 过滤</h2><p>我们在写组件的时候大部分都会导入相关的 css 文件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./css/index.scss&#x27;</span>;<span class="hljs-comment">//导入css</span><br><br><span class="hljs-comment">//组件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>)&#123;<br>        <span class="hljs-variable language_">super</span>(props);<br>    &#125;<br><br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span>  <span class="hljs-title function_">getInitialProps</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> fetch1 =<span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/xxx.com/a&#x27;</span>);<br>        <span class="hljs-keyword">const</span> fetch2 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/xxx.com/b&#x27;</span>);<br><br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">res</span>:[fetch1,fetch2]<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;this.props.data.title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>但是这个 <code>css</code> 文件在服务端无法执行，其实想想在服务端本来就不需要渲染 css 。为什么不直接干掉？ 所以为了方便，我这里写了一个<code>babel</code> 插件，在编译的时候干掉 css 的导入代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 删除 css 的引入</span><br><span class="hljs-comment"> * 可能社区已经有现成的插件但是不想费劲儿找了，还是自己写一个吧。 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">&#123; types: babelTypes &#125;</span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;no-require-css&quot;</span>,<br>        <span class="hljs-attr">visitor</span>: &#123;<br>            <span class="hljs-title class_">ImportDeclaration</span>(path, state) &#123;<br>                <span class="hljs-keyword">let</span> importFile = path.<span class="hljs-property">node</span>.<span class="hljs-property">source</span>.<span class="hljs-property">value</span>;<br>                <span class="hljs-keyword">if</span>(importFile.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;.scss&#x27;</span>)&gt;-<span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-comment">// 干掉css 导入</span><br>                    path.<span class="hljs-title function_">remove</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;;<br>&#125;;<br><br><span class="hljs-comment">//.babelrc 中使用</span><br><br> <span class="hljs-string">&quot;plugins&quot;</span>: [<br>                <span class="hljs-string">&quot;./webpack/babel/plugin/no-require-css&quot;</span>  <span class="hljs-comment">//引入        </span><br>            ]<br></code></pre></td></tr></table></figure>

<h2 id="动态路由的-SSR"><a href="#动态路由的-SSR" class="headerlink" title="动态路由的 SSR"></a>动态路由的 SSR</h2><p>现在要说一个更加核心的内容，也是本文的一个压轴亮点，可以说是<strong>全网唯一</strong>,我之前也看过很多文章和资料都没有细说这一块儿的实现。</p>
<p>不知道你有没有发现，上面我们已经一步一步的实现了 <code>React SSR 同构</code> 的完整流程，但是总感觉少点什么东西。</p>
<p><code>SPA</code>模式下大部分都会实现组件分包和按需加载，防止所有代码打包在一个文件过大影响页面的加载和渲染，影响用户体验。</p>
<p>那么基于 <code>SSR</code> 的组件按需加载如何实现呢？</p>
<p>当然我们所限定按需的粒度是路由级别的，请求不同的路由动态加载对应的组件。</p>
<h3 id="如何实现组件的按需加载？"><a href="#如何实现组件的按需加载？" class="headerlink" title="如何实现组件的按需加载？"></a>如何实现组件的按需加载？</h3><p>在 <code>webpack2</code> 时期主要使用<code>require.ensure</code>方法来实现按需加载，他会单独打包指定的文件，在当下 <code>webpack4</code>，有了更加规范的的方式实现按需加载，那就是动态导入 <code>import(&#39;./xx.js&#39;)</code>,当然实现的效果和 <code>require.ensure</code>是相同的。</p>
<p>咱们这里只说如何借助这个规范实现按需加载的路由，关于动态导入的实现原理先按下不表。</p>
<p>我们都知道 <code>import</code> 方法传入一个js文件地址，返回值是一个 <code>promise</code> 对象，然后在 <code>then</code> 方法内回调得到按需的组件。他的原理其实就是通过 jsonp 的方式，动态请求脚本，然后在回调内得到组件。</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade">import(<span class="hljs-string">&#x27;../index&#x27;</span>).then(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>    <span class="hljs-comment">//xxxx</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<p>那现在我们已经得到了几个比较有用的信息。</p>
<ul>
<li>如何加载脚本 - <code>import 结合 webpack</code> 自动完成</li>
<li>脚本是否加载完成 - 通过在 <code>then</code> 方法回调进行处理</li>
<li>获取异步按组件 - 通过在 <code>then</code> 方法回调内获取</li>
</ul>
<p>我们可以试着把上面的逻辑抽象成为一个组件，然后在路由配置的地方进行导入后，那么是不是就完成了组件的按需加载呢？</p>
<p>先看下按需加载组件, 目的是在 <code>import</code> 完成的时候得到按需的组件，然后更改容器组件的 <code>state</code>，将这个<code>异步组件</code>进行渲染。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 按需加载的容器组件</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@class</span> <span class="hljs-variable">Bundle</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@extends</span> &#123;<span class="hljs-type">Component</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Async</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>        <span class="hljs-variable language_">super</span>(props);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<br>            <span class="hljs-attr">COMPT</span>: <span class="hljs-literal">null</span><br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-title function_">UNSAFE_componentWillMount</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">//执行组件加载</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">COMPT</span>) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">load</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>);<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-title function_">load</span>(<span class="hljs-params">props</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>            <span class="hljs-attr">COMPT</span>: <span class="hljs-literal">null</span><br>        &#125;);<br>        <span class="hljs-comment">//注意这里，返回Promise对象; C.default 指向按需组件</span><br>        props.<span class="hljs-title function_">load</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">C</span>) =&gt;</span> &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>                <span class="hljs-attr">COMPT</span>: C.<span class="hljs-property">default</span> ? C.<span class="hljs-property">default</span> : <span class="hljs-variable constant_">COMPT</span><br>            &#125;);<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">COMPT</span> ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-title function_">children</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">COMPT</span>) : <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>正在加载......<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>Async</code> 容器组件接收一个 props 传过来的 load 方法，返回值是 <code>Promise</code>类型，用来动态导入组件。</p>
<p>在生命周期 <code>UNSAFE_componentWillMount</code> 得到按需的组件，并将组件存储到 <code>state.COMPT</code>内,同时在 <code>render</code> 方法中判断这个状态的可用性，然后调用<code>this.props.children</code> 方法进行渲染。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//调用</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">LazyPageCom</span> = (<span class="hljs-params">props</span>) =&gt; (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Async</span> <span class="hljs-attr">load</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> import(&#x27;../index&#x27;)&#125;&gt;</span><br><span class="language-xml">        &#123;(C) =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">C</span> &#123;<span class="hljs-attr">...props</span>&#125; /&gt;</span>&#125;//返回函数组件</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Async</span>&gt;</span></span><br>);<br></code></pre></td></tr></table></figure>

<p>当然这只是其中一种方法，也有很多是通过 <code>react-loadable 库</code>来进行实现，但是实现思路基本相同,有兴趣的可以看下源码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//参考代码</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Loadable</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-loadable&#x27;</span>;<br><br><span class="hljs-comment">//loading 组件</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Loading</span> =(<span class="hljs-params"></span>)=&gt;&#123;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>loading<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    ) <br>&#125;<br><br><span class="hljs-comment">//导出组件</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Loadable</span>(&#123;<br>    <span class="hljs-attr">loader</span>:<span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../index&#x27;</span>),<br>    <span class="hljs-attr">loading</span>:<span class="hljs-title class_">Loading</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<p>到这里我们已经实现了组件的按需加载，剩下就是配置到路由。</p>
<p>看下伪代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-comment">//index.js</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br><br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>detail<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//detail.js</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Detail</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br><br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>detail<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//routes.js</span><br><br><span class="hljs-comment">//按需加载 index 组件</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">AyncIndex</span> = (<span class="hljs-params">props</span>) =&gt; (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Async</span> <span class="hljs-attr">load</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> import(&#x27;../index&#x27;)&#125;&gt;</span><br><span class="language-xml">        &#123;(C) =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">C</span> &#123;<span class="hljs-attr">...props</span>&#125; /&gt;</span>&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Async</span>&gt;</span></span><br>);<br><br><span class="hljs-comment">//按需加载 detai 组件</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">AyncDetail</span> = (<span class="hljs-params">props</span>) =&gt; (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Async</span> <span class="hljs-attr">load</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> import(&#x27;../index&#x27;)&#125;&gt;</span><br><span class="language-xml">        &#123;(C) =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">C</span> &#123;<span class="hljs-attr">...props</span>&#125; /&gt;</span>&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Async</span>&gt;</span></span><br>);<br><br><span class="hljs-keyword">const</span> routes = [<br><br>    &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/&quot;</span>,<br>        <span class="hljs-attr">exact</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-title class_">AyncIndex</span><br>    &#125;,<br>    &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/detail&#x27;</span>, <span class="hljs-attr">exact</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-title class_">AyncDetail</span>,<br>    &#125;<br>];<br></code></pre></td></tr></table></figure>

<p>结合路由的按需加载已经配置完成，先不管 server端 是否需要进行调整，此时的代码是可以运行的，按需也是 ok 的。</p>
<p>但是ssr无效了，查看网页源代码无内容。</p>
<h3 id="动态路由-SSR-双端配置"><a href="#动态路由-SSR-双端配置" class="headerlink" title="动态路由 SSR 双端配置"></a>动态路由 SSR 双端配置</h3><p><code>ssr</code>无效了,这是什么原因呢？</p>
<p>上面我们在做路由同构的时候，双端使用的是同一个 route配置文件<code>routes-config.js</code>,现在组件改成了按需加载，所以在路由查找后得到的组件发生改变了 - <code>AyncDetail,AyncIndex</code>，根本无法转换出组件内容。</p>
<h4 id="ssr-模式下-server-端如何处理路由按需加载"><a href="#ssr-模式下-server-端如何处理路由按需加载" class="headerlink" title="ssr 模式下 server 端如何处理路由按需加载"></a>ssr 模式下 server 端如何处理路由按需加载</h4><p>其实很简单，也是参考客户端的处理方式，对路由配置进行二次处理。server 端在进行组件查找前，强制执行 <code>import</code> 方法，得到一个全新的静态路由表，再去进行组件的查找。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-comment">//获得静态路由</span><br><br><span class="hljs-keyword">import</span> routes <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;routes-config.js&#x27;</span>;<span class="hljs-comment">//得到动态路由的配置</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getStaticRoutes</span>(<span class="hljs-params"></span>) &#123;<br><br>    <span class="hljs-keyword">const</span> staticRoutes = [];<span class="hljs-comment">//存放新路由</span><br><br>    <span class="hljs-keyword">for</span> (; i &lt; len; i++) &#123;<br>        <span class="hljs-keyword">let</span> item = routes[i];<br>       <br>        <span class="hljs-comment">//存放静态路由</span><br>        staticRoutes.<span class="hljs-title function_">push</span>(&#123;<br>            ...item,<br>            ...&#123;<br>                <span class="hljs-attr">component</span>: (<span class="hljs-keyword">await</span> item.<span class="hljs-title function_">component</span>().<span class="hljs-property">props</span>.<span class="hljs-title function_">load</span>()).<span class="hljs-property">default</span><br>            &#125;<br>        &#125;);<br>  <br>    &#125;<br>    <span class="hljs-keyword">return</span> staticRoutes; <span class="hljs-comment">//返回静态路由</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>如今我们离目标更近了一步，<code>server</code>端已兼容了按需路由的查找。但是还没完！</p>
<p>我们这个时候访问页面的话，ssr 生效了，查看网页源代码可以看到对应的 html 内容。</p>
<p>但是页面上会显示直出的内容，然后显示<code>&lt;span&gt;正在加载......&lt;/span&gt;</code> ,瞬间又变成直出的内容。</p>
<p>### ssr 模式下 client 端如何处理路由按需加载</p>
<p>这个是为什么呢？</p>
<p>是不是看的有点累了，再坚持一下就成功了。</p>
<p>其实有问题才是最好的学习方式，问题解决了，路就通了。</p>
<p>首先我们知道浏览器端会对已有的节点进行双端对比，如果对比失败就会重新渲染，这很明显就是个问题。</p>
<p>咱分析一下，首先服务端直出了 html 内容，而此时浏览器端js执行完后需要做按需加载，在按需加载前的组件默认的内容就是<code>&lt;span&gt;正在加载......&lt;/span&gt;</code> 这个缺省内容和服务端直出的 html 内容完全不同，所以对比失败，页面会渲染成 <code>&lt;span&gt;正在加载......&lt;/span&gt;</code>,然后按需加载完成后组件再次渲染，此时渲染的就是真正的组件了。</p>
<p><strong>如何解决呢？</strong></p>
<p>其实也并不复杂，只是不确定是否可行，试过就知道。</p>
<p>既然客户端需要处理按需，那么我们等这个按需组件加载完后再进行渲染是不是就可以了呢？</p>
<p>答案是：可以的！</p>
<p><strong>如何按需呢？</strong></p>
<p>向“服务端同学”学习，找到对应的组件并强制 执行<code>import</code>按需，只是这里不是转换为静态路由，只找到按需的组件完成动态加载即可。</p>
<p>既然有了思路，那就撸起代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>,&#123;createContext&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">RootContext</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./route-context&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props,context</span>) &#123;<br>        <span class="hljs-variable language_">super</span>(props);<br>    &#125;<br><br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">RootContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.props.initialData||&#123;&#125;&#125;</span>&gt;</span></span><br><span class="language-xml">            &#123;this.props.children&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">RootContext.Provider</span>&gt;</span></span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//入口  app.js</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">BrowserRouter</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Routes</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Provider</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./provider&#x27;</span>;<br><br><br><span class="hljs-comment">//渲染入口</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">renderUI</span>(<span class="hljs-params">initialData</span>) &#123;<br>    <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">hydrate</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">BrowserRouter</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Provider</span> <span class="hljs-attr">initialData</span>=<span class="hljs-string">&#123;initialData&#125;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Routes</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">BrowserRouter</span>&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;rootEle&#x27;</span>), <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>    &#125;);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">entryIndex</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable constant_">APP_INIT_DATA</span> = &#123;&#125;;<br>    <span class="hljs-keyword">let</span> state = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-comment">//取得数据</span><br>    <span class="hljs-keyword">let</span> stateText = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;krs-server-render-data-BOX&#x27;</span>);<br>    <br>    <span class="hljs-comment">//数据脱水</span><br>    <span class="hljs-keyword">if</span> (stateText) &#123;<br>        <span class="hljs-variable constant_">APP_INIT_DATA</span> = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(stateText.<span class="hljs-property">value</span> || <span class="hljs-string">&#x27;&#123;&#125;&#x27;</span>);<br>    &#125;<br><br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable constant_">APP_INIT_DATA</span>) &#123;<span class="hljs-comment">//客户端渲染</span><br>        <br>        - <span class="hljs-title function_">renderUI</span>(<span class="hljs-literal">true</span>, <span class="hljs-variable constant_">APP_INIT_DATA</span>);<br>        <span class="hljs-comment">//查找组件</span><br>        + <span class="hljs-title function_">matchComponent</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">location</span>.<span class="hljs-property">pathname</span>, <span class="hljs-title function_">routesConfig</span>()).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>            <span class="hljs-title function_">renderUI</span>(<span class="hljs-literal">true</span>, <span class="hljs-variable constant_">APP_INIT_DATA</span>);<br>        &#125;);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//执行入口</span><br><span class="hljs-title function_">entryIndex</span>();<br></code></pre></td></tr></table></figure>

<p><code>matchComponent</code> 是我封装的一个组件查找的方法，在文章开始已经介绍过类似的实现，代码就不贴了。</p>
<p><strong>核心亮点说完，整个流程基本结束，剩下的都是些有的没的了，我打算要收工了。</strong></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="SEO-支持"><a href="#SEO-支持" class="headerlink" title="SEO 支持"></a>SEO 支持</h3><p>页面的 <code>SEO</code> 效果取决于页面的主体内容和页面的 TDK（标题 title,描述 description,关键词 keyword）以及关键词的分布和密度，现在我们实现了 <code>ssr</code>所以页面的主体内容有了，那如何设置页面的标题并且让每个页面（路由）的标题都不同呢？</p>
<p>只要我们每请求一个路由的时候返回不同的 <code>tdk</code> 就可以了。</p>
<p>这里我在所对应组件数据预取的方法内加了约定，返回的数据为固定格式，必须包含 <code>page 对象</code>，page 对象内包含 tdk 的信息。</p>
<p>看代码瞬间就明白。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./css/index.scss&#x27;</span>;<br><br><span class="hljs-comment">//组件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>)&#123;<br>        <span class="hljs-variable language_">super</span>(props);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span>  <span class="hljs-title function_">getInitialProps</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> fetch1 =<span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/xxx.com/a&#x27;</span>);<br>        <span class="hljs-keyword">const</span> fetch2 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/xxx.com/b&#x27;</span>);<br><br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">page</span>:&#123;<br>                <span class="hljs-attr">tdk</span>:&#123;<br>                    <span class="hljs-attr">title</span>:<span class="hljs-string">&#x27;标题&#x27;</span>,<br>                    <span class="hljs-attr">keyword</span>:<span class="hljs-string">&#x27;关键词&#x27;</span>,<br>                    <span class="hljs-attr">description</span>:<span class="hljs-string">&#x27;描述&#x27;</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-attr">res</span>:[fetch1,fetch2]<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;this.props.data.title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样你的 <code>tdk</code> 可以根据你的需要设置成静态还是从接口拿到的。然后可以在 <code>esj</code> 模板里进行绑定，也可以在 <code>componentDidMount</code>通过 js<br><code>document.title=this.state.page.tdk.title</code>设置页面的标题。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;ie=edge&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;keywords&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;&lt;%=page.tdk.keyword%&gt;&quot;</span> /&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;description&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;content=&quot;</span>&lt;%=<span class="hljs-string">page.tdk.description%</span>&gt;</span>&quot; /&gt;<br>   <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>&lt;%=page.tdk.title%&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;rootEle&quot;</span>&gt;</span><br>       &lt;%- htmlContent %&gt;<br>   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>   &lt;%- propsData %&gt;<br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br>&lt;%page.staticSource.js.forEach(function(item)&#123;%&gt;<br></code></pre></td></tr></table></figure>

<h3 id="fetch-同构"><a href="#fetch-同构" class="headerlink" title="fetch 同构"></a>fetch 同构</h3><p>可以使用<code>isomorphic-fetch</code>、<code>axios</code>或者<code>whatwg-fetch + node-fetch</code> 等库来实现支持双端的 <code>fetch 数据请求</code>，这里推荐使用<code>axios</code> 主要是比较方便。</p>
<h2 id="TODO-和-思考"><a href="#TODO-和-思考" class="headerlink" title="TODO 和 思考"></a>TODO 和 思考</h2><p>没有介绍结合 <code>redux</code> 状态管理的 <code>ssr</code> 实现，其实也不复杂，关键还是看业务中是否需要使用redux，因为文中已经实现了使用 <code>context</code> 传递数据，直接改成按<code>store</code> 传递也很容易,但是更多的还是对 <code>react-redux</code> 的应用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-comment">//渲染入口 代码仅供参考 </span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">renderUI</span>(<span class="hljs-params">initialData</span>) &#123;<br>   <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">hydrate</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">BrowserRouter</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Provider</span> <span class="hljs-attr">store</span>=<span class="hljs-string">&#123;initialData&#125;</span>&gt;</span></span><br><span class="language-xml">       <span class="hljs-tag">&lt;<span class="hljs-name">Routes</span> /&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">BrowserRouter</span>&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;rootEle&#x27;</span>), <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>   &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>服务端同构渲染虽然可以提升首屏的出现时间，利于 SEO，对低端用户友好，但是开发复杂度有所提高，代码需要兼容双端运行（runtime）,还有一些库只能在浏览器端运行，在服务端加载会直接报错，这种情况就需要进行做一些特殊处理。</p>
<p>同时也会大大的增加服务端负载，当然这都容易解决，可以改用<code>renderToNodeStream()</code> 方法通过流式输出来提升服务端渲染性能，可以进行监控和扩容，所以是否需要 ssr 模式，还要看具体的产品线和用户定位。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>本文最初从 react ssr 的整体实现原理上进行说明，然后逐步的抛出问题，循序渐进的逐步解决，最终完成了整个<code>React SSR</code> 所需要处理的技术点，同时对每个技术点和问题做了详细的说明。</p>
<p>但实现方式并不唯一，还有很多其他的方式， 比如 <code>next.js</code>, <code>umi.js</code>,但是原理相似，具体差异我会接下来进行对比后输出。</p>
<h2 id="源码参考"><a href="#源码参考" class="headerlink" title="源码参考"></a>源码参考</h2><p>由于上面文中的代码较为零散，恐怕不能直接运行。为了方便大家的参考和学习，我把涉及到代码进行整理、完善和修改，增加了一些基础配置和工程化处理，目前已形成一个完整的开发骨架，可以直接运行看效果，所有的代码都在这个骨架里，欢迎star 欢迎 下载，交流学习。</p>
<p>项目代码地址: <a target="_blank" rel="noopener" href="https://github.com/Bigerfe/koa-react-ssr">https://github.com/Bigerfe/koa-react-ssr</a></p>
<h2 id="说点感想"><a href="#说点感想" class="headerlink" title="说点感想"></a>说点感想</h2><p>很多东西都可以基于你现有的知识创造出来。</p>
<p>只要明白了其中的原理，然后梳理出实现的思路，剩下的就是撸代码了，期间会大量的自动或被动的从你现有的知识库里进行调取，一步一步的，只要不怕麻烦，都能搞得定。</p>
<p>这也是我为什么上来先要说下<code>reac ssr 原理</code> 的原因，因为它指导了我的实践。</p>
<p>全文都是自己亲手一个一个码出，也全部都是出自本人的理解，但个人文采有限，所以导致很多表达说的都是大白话，表达不够清楚的地方还请指出和斧正，但是真正的核心已全部涵盖。</p>
<p>希望本文的内容对你有所帮助，也可以对得住我这个自信的标题。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://github.com/ReactTrain">https://github.com/ReactTrain</a>…<br><a target="_blank" rel="noopener" href="https://reacttraining.com/rea">https://reacttraining.com/rea</a>…<br><a target="_blank" rel="noopener" href="https://blog.seosiwei.com/det">https://blog.seosiwei.com/det</a>…<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/47c">https://www.jianshu.com/p/47c</a>…</p>
<hr>
<p>更多精彩好玩有用的前端内容，请关注公众号《前端张大胖》</p>
<p><img  referrerpolicy="no-referrer" class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://segmentfault.com/img/remote/1460000021980720"></p>

<div class="article-footer fs14">
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    
    <section id="share">
      <div class="header"><span>分享文章</span></div>
      <div class="body">
        <div class="link"><input class="copy-area" readonly="true" id="copy-link" value="https://panzhenjie.fun/2024/07/31/%E4%B8%80%E6%96%87%E5%90%83%E9%80%8F-React-SSR-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E5%92%8C%E5%90%8C%E6%9E%84%E5%8E%9F%E7%90%86/" /></div>
        <div class="social-wrap dis-select"><a class="social share-item wechat" onclick="util.toggle(&quot;qrcode-wechat&quot)"><img  referrerpolicy="no-referrer" class="lazy"  src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/b32ef3da1162a.svg" /></a><a class="social share-item weibo" target="_blank" rel="external nofollow noopener noreferrer" href="https://service.weibo.com/share/share.php?url=https://panzhenjie.fun/2024/07/31/%E4%B8%80%E6%96%87%E5%90%83%E9%80%8F-React-SSR-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E5%92%8C%E5%90%8C%E6%9E%84%E5%8E%9F%E7%90%86/&title=一文吃透 React SSR 服务端渲染和同构原理 - JKK随笔&summary=
原文地址javascript - 一文吃透 React SSR 服务端渲染和同构原理 - 前端张大胖-技术实践和探索 - SegmentFault 思否

全网最完整的 React SSR 同构技术原理解析与实践，从零开始手把手带你..."><img  referrerpolicy="no-referrer" class="lazy"  src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/80c07e4dbb303.svg" /></a><a class="social share-item email" href="mailto:?subject=一文吃透 React SSR 服务端渲染和同构原理 - JKK随笔&amp;body=https://panzhenjie.fun/2024/07/31/%E4%B8%80%E6%96%87%E5%90%83%E9%80%8F-React-SSR-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E5%92%8C%E5%90%8C%E6%9E%84%E5%8E%9F%E7%90%86/"><img  referrerpolicy="no-referrer" class="lazy"  src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/a1b00e20f425d.svg" /></a><a class="social share-item link" onclick="util.copy(&quot;copy-link&quot;, &quot;复制成功&quot;)"><img  referrerpolicy="no-referrer" class="lazy"  src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/8411ed322ced6.svg" /></a></div>
        
        <div class="qrcode" id="qrcode-wechat" style="opacity:0;height:0">
          <img  referrerpolicy="no-referrer" class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://api.qrserver.com/v1/create-qr-code/?size=256x256&data=https://panzhenjie.fun/2024/07/31/%E4%B8%80%E6%96%87%E5%90%83%E9%80%8F-React-SSR-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E5%92%8C%E5%90%8C%E6%9E%84%E5%8E%9F%E7%90%86/"/>
        </div>
        
      </div>
    </section>
    </div>
</article>
<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"></div><div class="item" id="next"><div class="note">较早文章</div><a href="/2024/04/12/Canvas%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%A7%A3/">Canvas入门知识图解</a></div></section></div>

<div class="related-wrap" id="related-posts">
    <section class='header'>
      <div class='title cap theme'>您可能感兴趣的文章</div>
    </section>
    <section class='body'>
    <div class="related-posts"><a class="item" href="\2024\02\28\2023再看React状态管理库\" title="2023再看React状态管理库"><span class="title">2023再看React状态管理库</span></a><a class="item" href="\2024\02\28\[React进阶]API全面解读与基础实践\" title="[React进阶]API全面解读与基础实践"><span class="title">[React进阶]API全面解读与基础实践</span></a><a class="item" href="\2024\03\12\Nextjs项目最佳实践\" title="Nextjs项目最佳实践"><span class="title">Nextjs项目最佳实践</span></a><a class="item" href="\2024\03\12\手把手带你入门NextJs\" title="手把手带你入门NextJs"><span class="title">手把手带你入门NextJs</span></a><a class="item" href="\2024\04\01\163邮箱发邮件550错误解决方法\" title="163邮箱发邮件550错误解决方法"><span class="title">163邮箱发邮件550错误解决方法</span></a></div></section></div>


  <div class="related-wrap md-text" id="comments">
    <section class='header cmt-title cap theme'>
      <p>快来参与讨论吧~</p>

    </section>
    <section class='body cmt-body utterances'>
      

<svg class="loading" style="vertical-align:middle;fill:currentColor;overflow:hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg>

<div id="utterances" repo="stephenykk/discussion" issue-term="pathname" theme="preferred-color-scheme"></div>

    </section>
  </div>



<footer class="page-footer footnote"><hr><div class="text"><p>本站由 <a href="/">stephenykk</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.27.0">Stellar 1.27.0</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">



<widget class="widget-wrapper toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span><a class="cap-action" onclick="sidebar.toggleTOC()" ><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="toc-text">写在前面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93-ssr"><span class="toc-text">为什么要服务端渲染(ssr)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A6%96%E5%B1%8F%E7%AD%89%E5%BE%85"><span class="toc-text">首屏等待</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B2%A1%E8%80%83%E8%99%91SEO%E7%9A%84%E6%84%9F%E5%8F%97"><span class="toc-text">没考虑SEO的感受</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SSR-SPA-%E4%BD%93%E9%AA%8C%E5%8D%87%E7%BA%A7"><span class="toc-text">SSR + SPA 体验升级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="toc-text">核心原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#react-ssr"><span class="toc-text">react ssr</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E-ejs-%E5%BC%80%E5%A7%8B"><span class="toc-text">从 ejs 开始</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jsx-%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">jsx 到字符串</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E5%87%BA%E9%97%AE%E9%A2%98"><span class="toc-text">引出问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%9E%84%E6%89%8D%E6%98%AF%E6%A0%B8%E5%BF%83"><span class="toc-text">同构才是核心</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%90%8C%E6%9E%84"><span class="toc-text">路由同构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%90%8C%E6%9E%84%EF%BC%88%E9%A2%84%E5%8F%96%E5%90%8C%E6%9E%84%EF%BC%89"><span class="toc-text">数据同构（预取同构）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E5%90%8C%E6%9E%84"><span class="toc-text">渲染同构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B3%A8%E6%B0%B4"><span class="toc-text">数据注水</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%84%B1%E6%B0%B4"><span class="toc-text">数据脱水</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#css-%E8%BF%87%E6%BB%A4"><span class="toc-text">css 过滤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E7%9A%84-SSR"><span class="toc-text">动态路由的 SSR</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E7%9A%84%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD%EF%BC%9F"><span class="toc-text">如何实现组件的按需加载？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1-SSR-%E5%8F%8C%E7%AB%AF%E9%85%8D%E7%BD%AE"><span class="toc-text">动态路由 SSR 双端配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ssr-%E6%A8%A1%E5%BC%8F%E4%B8%8B-server-%E7%AB%AF%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E8%B7%AF%E7%94%B1%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD"><span class="toc-text">ssr 模式下 server 端如何处理路由按需加载</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SEO-%E6%94%AF%E6%8C%81"><span class="toc-text">SEO 支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fetch-%E5%90%8C%E6%9E%84"><span class="toc-text">fetch 同构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TODO-%E5%92%8C-%E6%80%9D%E8%80%83"><span class="toc-text">TODO 和 思考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%90%8E"><span class="toc-text">最后</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%8F%82%E8%80%83"><span class="toc-text">源码参考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E7%82%B9%E6%84%9F%E6%83%B3"><span class="toc-text">说点感想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">参考资料</span></a></li></ol></div><div class="widget-footer">

<a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 12c0-4.714 0-7.071 1.464-8.536C4.93 2 7.286 2 12 2c4.714 0 7.071 0 8.535 1.464C22 4.93 22 7.286 22 12c0 4.714 0 7.071-1.465 8.535C19.072 22 16.714 22 12 22s-7.071 0-8.536-1.465C2 19.072 2 16.714 2 12Z"/><path stroke-linecap="round" stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/></g></svg><span>回到顶部</span></a></div></widget>
</div></aside><div class='float-panel blur'>
  <button type='button' style='display:none' class='laptop-only rightbar-toggle mobile' onclick='sidebar.rightbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg>
  </button>
  <button type='button' style='display:none' class='mobile-only leftbar-toggle mobile' onclick='sidebar.leftbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
</div><div class="scripts">
<script type="text/javascript">
  const ctx = {
    date_suffix: {
      just: `刚刚`,
      min: `分钟前`,
      hour: `小时前`,
      day: `天前`,
    },
    root : `/`,
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg`,
  };
  const deps = {
    jquery: `https://cdn.bootcdn.net/ajax/libs/jquery/3.7.1/jquery.min.js`,
    marked: `https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js`
  }
  

</script>

<script type="text/javascript">
  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },
    
    onLoading: (el) => {
      if (el) {
        $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      let retryTimes = 3;
      utils.onLoading(el);
      function req() {
        return new Promise((resolve, reject) => {
          let status = 0; // 0 等待 1 完成 2 超时
          let timer = setTimeout(() => {
            if (status === 0) {
              status = 2;
              timer = null;
              reject('请求超时');
              if (retryTimes == 0) {
                onFailure();
              }
            }
          }, 5000);
          fetch(url).then(function(response) {
            if (status !== 2) {
              clearTimeout(timer);
              resolve(response);
              timer = null;
              status = 1;
            }
            if (response.ok) {
              return response.json();
            }
            throw new Error('Network response was not ok.');
          }).then(function(data) {
            retryTimes = 0;
            utils.onLoadSuccess(el);
            callback(data);
          }).catch(function(error) {
            if (retryTimes > 0) {
              retryTimes -= 1;
              setTimeout(() => {
                req();
              }, 5000);
            } else {
              utils.onLoadFailure(el);
              onFailure();
            }
          });
        });
      }
      req();
    },
  };
</script>

<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>

<!-- required -->
<script src="/js/main.js?v=1.27.0" async></script>

<!-- optional -->

  <script>
  function loadUtterances() {
    const els = document.querySelectorAll("#comments #utterances");
    if (els.length === 0) return;
    els.forEach((el, i) => {
      try {
        el.innerHTML = '';
      } catch (error) {
        console.error(error);
      }
      var script = document.createElement('script');
      script.src = 'https://utteranc.es/client.js';
      script.async = true;
      for (let key of Object.keys(el.attributes)) {
        let attr = el.attributes[key];
        if (['class', 'id'].includes(attr.name) === false) {
          script.setAttribute(attr.name, attr.value);
        }
      }
      el.appendChild(script);
    });
  }
  window.addEventListener('DOMContentLoaded', (event) => {
      loadUtterances();
  });
</script>




<script defer>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?527d24f1a4c0bef6256d4231fa3c74ac";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
<script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer src="https://cdn.bootcdn.net/ajax/libs/flying-pages/2.1.2/flying-pages.min.js"></script><script defer src="https://cdn.bootcdn.net/ajax/libs/vanilla-lazyload/17.8.4/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });
</script><script>
  ctx.fancybox = {
    selector: `.timenode p>img`,
    css: `https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.22/fancybox/fancybox.min.css`,
    js: `https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.22/fancybox/fancybox.umd.min.js`
  };
  var selector = '[data-fancybox]:not(.error)';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const els = document.getElementsByClassName('ds-memos');
    if (els != undefined && els.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || null
        }
      });
    })
  }
</script><script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          loop: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script><script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>


<!-- inject -->

</div></body></html>
